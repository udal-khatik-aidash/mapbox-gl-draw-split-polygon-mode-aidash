{"version":3,"file":"index.js","sources":["../node_modules/@turf/clone/dist/es/index.js","../node_modules/@turf/invariant/dist/es/index.js","../node_modules/@turf/boolean-clockwise/dist/es/index.js","../node_modules/@turf/meta/node_modules/@turf/helpers/dist/es/index.js","../node_modules/@turf/meta/dist/es/index.js","../node_modules/@turf/rewind/dist/es/index.js","../node_modules/@turf/rewind/node_modules/@turf/helpers/dist/es/index.js","../node_modules/point-in-polygon-hao/dist/pointInPolygon.mjs","../node_modules/robust-predicates/esm/util.js","../node_modules/robust-predicates/esm/orient2d.js","../node_modules/polygon-splitter/dist/polygonsplitter.mjs","../node_modules/@mapbox/mapbox-gl-draw/src/constants.js","../node_modules/@turf/helpers/dist/esm/index.js","../node_modules/sweepline-intersections/dist/sweeplineIntersections.esm.js","../node_modules/@turf/line-intersect/dist/esm/index.js","../node_modules/@turf/boolean-disjoint/node_modules/@turf/invariant/dist/esm/index.js","../node_modules/@turf/boolean-disjoint/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js","../node_modules/@turf/boolean-disjoint/node_modules/@turf/meta/dist/esm/index.js","../node_modules/@turf/boolean-disjoint/node_modules/@turf/polygon-to-line/dist/esm/index.js","../node_modules/@turf/boolean-disjoint/dist/esm/index.js","../node_modules/@turf/line-offset/node_modules/@turf/meta/dist/esm/index.js","../node_modules/@turf/line-offset/dist/esm/index.js","../node_modules/@turf/line-offset/node_modules/@turf/invariant/dist/esm/index.js","../node_modules/@turf/line-to-polygon/node_modules/@turf/meta/dist/esm/index.js","../node_modules/@turf/line-to-polygon/node_modules/@turf/bbox/dist/esm/index.js","../node_modules/@turf/line-to-polygon/node_modules/@turf/clone/dist/esm/index.js","../node_modules/@turf/line-to-polygon/dist/esm/index.js","../node_modules/@turf/line-to-polygon/node_modules/@turf/invariant/dist/esm/index.js","../node_modules/bignumber.js/bignumber.mjs","../node_modules/splaytree-ts/dist/esm/index.js","../node_modules/polyclip-ts/dist/esm/index.js","../node_modules/@turf/difference/dist/esm/index.js","../node_modules/@turf/difference/node_modules/@turf/meta/dist/esm/index.js","../src/constants.js","../src/utils.js","../src/mode.js","../src/customDrawStyles.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js","../node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_point.js","../node_modules/mapbox-gl-draw-passing-mode/src/passing_draw_point.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/is_event_at_coordinates.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js","../node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_line_string.js","../node_modules/mapbox-gl-draw-passing-mode/src/passing_draw_line_string.js","../node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_polygon.js","../node_modules/mapbox-gl-draw-passing-mode/src/passing_draw_polygon.js","../node_modules/mapbox-gl-draw-select-mode/src/constants.js","../node_modules/mapbox-gl-draw-select-mode/src/mode.js","../node_modules/mapbox-gl-draw-select-mode/src/index.js","../src/index.js"],"sourcesContent":["/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @name clone\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    switch (geojson.type) {\n        case \"Feature\":\n            return cloneFeature(geojson);\n        case \"FeatureCollection\":\n            return cloneFeatureCollection(geojson);\n        case \"Point\":\n        case \"LineString\":\n        case \"Polygon\":\n        case \"MultiPoint\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n        case \"GeometryCollection\":\n            return cloneGeometry(geojson);\n        default:\n            throw new Error(\"unknown GeoJSON type\");\n    }\n}\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson) {\n    var cloned = { type: \"Feature\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"properties\":\n            case \"geometry\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add properties & geometry last\n    cloned.properties = cloneProperties(geojson.properties);\n    cloned.geometry = cloneGeometry(geojson.geometry);\n    return cloned;\n}\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties) {\n    var cloned = {};\n    if (!properties) {\n        return cloned;\n    }\n    Object.keys(properties).forEach(function (key) {\n        var value = properties[key];\n        if (typeof value === \"object\") {\n            if (value === null) {\n                // handle null\n                cloned[key] = null;\n            }\n            else if (Array.isArray(value)) {\n                // handle Array\n                cloned[key] = value.map(function (item) {\n                    return item;\n                });\n            }\n            else {\n                // handle generic Object\n                cloned[key] = cloneProperties(value);\n            }\n        }\n        else {\n            cloned[key] = value;\n        }\n    });\n    return cloned;\n}\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson) {\n    var cloned = { type: \"FeatureCollection\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"features\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add features\n    cloned.features = geojson.features.map(function (feature) {\n        return cloneFeature(feature);\n    });\n    return cloned;\n}\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry) {\n    var geom = { type: geometry.type };\n    if (geometry.bbox) {\n        geom.bbox = geometry.bbox;\n    }\n    if (geometry.type === \"GeometryCollection\") {\n        geom.geometries = geometry.geometries.map(function (g) {\n            return cloneGeometry(g);\n        });\n        return geom;\n    }\n    geom.coordinates = deepSlice(geometry.coordinates);\n    return geom;\n}\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice(coords) {\n    var cloned = coords;\n    if (typeof cloned[0] !== \"object\") {\n        return cloned.slice();\n    }\n    return cloned.map(function (coord) {\n        return deepSlice(coord);\n    });\n}\nexport default clone;\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoords } from \"@turf/invariant\";\n/**\n * Takes a ring and return true or false whether or not the ring is clockwise or counter-clockwise.\n *\n * @name booleanClockwise\n * @param {Feature<LineString>|LineString|Array<Array<number>>} line to be evaluated\n * @returns {boolean} true/false\n * @example\n * var clockwiseRing = turf.lineString([[0,0],[1,1],[1,0],[0,0]]);\n * var counterClockwiseRing = turf.lineString([[0,0],[1,0],[1,1],[0,0]]);\n *\n * turf.booleanClockwise(clockwiseRing)\n * //=true\n * turf.booleanClockwise(counterClockwiseRing)\n * //=false\n */\nexport default function booleanClockwise(line) {\n    var ring = getCoords(line);\n    var sum = 0;\n    var i = 1;\n    var prev;\n    var cur;\n    while (i < ring.length) {\n        prev = cur || ring[0];\n        cur = ring[i];\n        sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);\n        i++;\n    }\n    return sum > 0;\n}\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { feature, lineString, isObject, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\n","import clone from '@turf/clone';\nimport booleanClockwise from '@turf/boolean-clockwise';\nimport { featureEach, geomEach } from '@turf/meta';\nimport { getCoords } from '@turf/invariant';\nimport { isObject, featureCollection } from '@turf/helpers';\n\n/**\n * Rewind {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon} outer ring counterclockwise and inner rings clockwise (Uses {@link http://en.wikipedia.org/wiki/Shoelace_formula|Shoelace Formula}).\n *\n * @name rewind\n * @param {GeoJSON} geojson input GeoJSON Polygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.reverse=false] enable reverse winding\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} rewind Polygon\n * @example\n * var polygon = turf.polygon([[[121, -29], [138, -29], [138, -18], [121, -18], [121, -29]]]);\n *\n * var rewind = turf.rewind(polygon);\n *\n * //addToMap\n * var addToMap = [rewind];\n */\nfunction rewind(geojson, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var reverse = options.reverse || false;\n  var mutate = options.mutate || false;\n\n  // validation\n  if (!geojson) throw new Error(\"<geojson> is required\");\n  if (typeof reverse !== \"boolean\")\n    throw new Error(\"<reverse> must be a boolean\");\n  if (typeof mutate !== \"boolean\")\n    throw new Error(\"<mutate> must be a boolean\");\n\n  // prevent input mutation\n  if (mutate === false) geojson = clone(geojson);\n\n  // Support Feature Collection or Geometry Collection\n  var results = [];\n  switch (geojson.type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        rewindFeature(geometry, reverse);\n      });\n      return geojson;\n    case \"FeatureCollection\":\n      featureEach(geojson, function (feature) {\n        featureEach(rewindFeature(feature, reverse), function (result) {\n          results.push(result);\n        });\n      });\n      return featureCollection(results);\n  }\n  // Support Feature or Geometry Objects\n  return rewindFeature(geojson, reverse);\n}\n\n/**\n * Rewind\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Geometry or Feature\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {Geometry|Feature<any>} rewind Geometry or Feature\n */\nfunction rewindFeature(geojson, reverse) {\n  var type = geojson.type === \"Feature\" ? geojson.geometry.type : geojson.type;\n\n  // Support all GeoJSON Geometry Objects\n  switch (type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        rewindFeature(geometry, reverse);\n      });\n      return geojson;\n    case \"LineString\":\n      rewindLineString(getCoords(geojson), reverse);\n      return geojson;\n    case \"Polygon\":\n      rewindPolygon(getCoords(geojson), reverse);\n      return geojson;\n    case \"MultiLineString\":\n      getCoords(geojson).forEach(function (lineCoords) {\n        rewindLineString(lineCoords, reverse);\n      });\n      return geojson;\n    case \"MultiPolygon\":\n      getCoords(geojson).forEach(function (lineCoords) {\n        rewindPolygon(lineCoords, reverse);\n      });\n      return geojson;\n    case \"Point\":\n    case \"MultiPoint\":\n      return geojson;\n  }\n}\n\n/**\n * Rewind LineString - outer ring clockwise\n *\n * @private\n * @param {Array<Array<number>>} coords GeoJSON LineString geometry coordinates\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {void} mutates coordinates\n */\nfunction rewindLineString(coords, reverse) {\n  if (booleanClockwise(coords) === reverse) coords.reverse();\n}\n\n/**\n * Rewind Polygon - outer ring counterclockwise and inner rings clockwise.\n *\n * @private\n * @param {Array<Array<Array<number>>>} coords GeoJSON Polygon geometry coordinates\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {void} mutates coordinates\n */\nfunction rewindPolygon(coords, reverse) {\n  // outer ring\n  if (booleanClockwise(coords[0]) !== reverse) {\n    coords[0].reverse();\n  }\n  // inner rings\n  for (var i = 1; i < coords.length; i++) {\n    if (booleanClockwise(coords[i]) === reverse) {\n      coords[i].reverse();\n    }\n  }\n}\n\nexport default rewind;\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","function pointInPolygon(p, polygon) {\n    var i = 0;\n    var ii = 0;\n    var k = 0;\n    var f = 0;\n    var u1 = 0;\n    var v1 = 0;\n    var u2 = 0;\n    var v2 = 0;\n    var currentP = null;\n    var nextP = null;\n\n    var x = p[0];\n    var y = p[1];\n\n    var numContours = polygon.length;\n    for (i; i < numContours; i++) {\n        ii = 0;\n        var contourLen = polygon[i].length - 1;\n        var contour = polygon[i];\n\n        currentP = contour[0];\n        if (currentP[0] !== contour[contourLen][0] &&\n            currentP[1] !== contour[contourLen][1]) {\n            throw new Error('First and last coordinates in a ring must be the same')\n        }\n\n        u1 = currentP[0] - x;\n        v1 = currentP[1] - y;\n\n        for (ii; ii < contourLen; ii++) {\n            nextP = contour[ii + 1];\n\n            v2 = nextP[1] - y;\n\n            if ((v1 < 0 && v2 < 0) || (v1 > 0 && v2 > 0)) {\n                currentP = nextP;\n                v1 = v2;\n                u1 = currentP[0] - x;\n                continue\n            }\n\n            u2 = nextP[0] - p[0];\n\n            if (v2 > 0 && v1 <= 0) {\n                f = (u1 * v2) - (u2 * v1);\n                if (f > 0) { k = k + 1; }\n                else if (f === 0) { return 0 }\n            } else if (v1 > 0 && v2 <= 0) {\n                f = (u1 * v2) - (u2 * v1);\n                if (f < 0) { k = k + 1; }\n                else if (f === 0) { return 0 }\n            } else if (v2 === 0 && v1 < 0) {\n                f = (u1 * v2) - (u2 * v1);\n                if (f === 0) { return 0 }\n            } else if (v1 === 0 && v2 < 0) {\n                f = u1 * v2 - u2 * v1;\n                if (f === 0) { return 0 }\n            } else if (v1 === 0 && v2 === 0) {\n                if (u2 <= 0 && u1 >= 0) {\n                    return 0\n                } else if (u1 <= 0 && u2 >= 0) {\n                    return 0\n                }\n            }\n            currentP = nextP;\n            v1 = v2;\n            u1 = u2;\n        }\n    }\n\n    if (k % 2 === 0) { return false }\n    return true\n}\n\nexport default pointInPolygon;\n","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    if (detleft === 0 || detright === 0 || (detleft > 0) !== (detright > 0)) return det;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","import rewind from '@turf/rewind';\nimport inside from 'point-in-polygon-hao';\nimport { orient2d } from 'robust-predicates';\n\nvar Edge = function Edge(p1, p2, edgeType, index, contourId) {\r\n  this.p1 = p1;\r\n  this.p2 = p2;\r\n  this.edgeType = edgeType;\r\n  this.originalIndex = index;\r\n\r\n  this.polygonContourId = contourId;\r\n  this.interiorRing = false;\r\n\r\n  this.minX = Math.min(p1.p[0], p2.p[0]);\r\n  this.minY = Math.min(p1.p[1], p2.p[1]);\r\n\r\n  this.maxX = Math.max(p1.p[0], p2.p[0]);\r\n  this.maxY = Math.max(p1.p[1], p2.p[1]);\r\n\r\n  this.intersectionPoints = [];\r\n  this.nextEdge = null;\r\n};\n\nvar Point = function Point(p) {\r\n  this.p = p;\r\n};\n\nvar Contour = function Contour(contourId, coords) {\n  this.id = contourId;\n  this.rawCoords = coords;\n};\n\nfunction fillQueue(polygon, line, polyEdges, lineEdges, polylineBbox) {\r\n  var numberOfRingsInPolygon = 0;\r\n  var contours = [];\r\n\r\n  var linegeom = line.type === 'Feature' ? line.geometry : line;\r\n  var linecoords = linegeom.type === 'LineString' ? [linegeom.coordinates] : linegeom.coordinates;\r\n\r\n  var edgeCount = 0;\r\n\r\n  for (var i = 0; i < linecoords.length; i++) {\r\n\r\n    var lineLength = linecoords[i].length - 1;\r\n    var p1 = new Point(linecoords[i][0]);\r\n    var p2 = null;\r\n    var prevEdge = {nextEdge: null};\r\n\r\n    for (var ii = 0; ii < lineLength; ii++) {\r\n      p2 = new Point(linecoords[i][ii + 1]);\r\n      p1.nextPoint = p2;\r\n      p2.prevPoint = p1;\r\n      var e = new Edge(p1, p2, 'polyline', edgeCount, null);\r\n      lineEdges.push(e);\r\n      prevEdge.nextEdge = e;\r\n      e.prevEdge = prevEdge;\r\n      polylineBbox[0] = Math.min(polylineBbox[0], p1.p[0]);\r\n      polylineBbox[1] = Math.min(polylineBbox[1], p1.p[1]);\r\n      polylineBbox[2] = Math.max(polylineBbox[2], p1.p[0]);\r\n      polylineBbox[3] = Math.max(polylineBbox[3], p1.p[1]);\r\n\r\n      p1 = p2;\r\n      edgeCount = edgeCount + 1;\r\n      prevEdge = e;\r\n    }\r\n    polylineBbox[0] = Math.min(polylineBbox[0], linecoords[i][lineLength][0]);\r\n    polylineBbox[1] = Math.min(polylineBbox[1], linecoords[i][lineLength][1]);\r\n    polylineBbox[2] = Math.max(polylineBbox[2], linecoords[i][lineLength][0]);\r\n    polylineBbox[3] = Math.max(polylineBbox[3], linecoords[i][lineLength][1]);\r\n  }\r\n\r\n  var polygeom = polygon.type === 'Feature' ? polygon.geometry : polygon;\r\n  var polycoords = polygeom.type === 'Polygon' ? [polygeom.coordinates] : polygeom.coordinates;\r\n\r\n  var polyLength = polycoords.length;\r\n\r\n  for (var i$1 = 0; i$1 < polyLength; i$1++) {\r\n\r\n    var polyLenth2 = polycoords[i$1].length;\r\n\r\n    for (var ii$1 = 0; ii$1 < polyLenth2; ii$1++) {\r\n      numberOfRingsInPolygon = numberOfRingsInPolygon + 1;\r\n\r\n      var polygonSet = polycoords[i$1][ii$1];\r\n      var polyLenth3 = polygonSet.length;\r\n      \r\n      contours.push(new Contour(numberOfRingsInPolygon, polygonSet));\r\n\r\n      var firstPoint = new Point(polygonSet[0]);\r\n      var p1$1 = firstPoint;\r\n      var p2$1 = (void 0), e$1 = null;\r\n      var prevEdge$1 = {nextEdge: null, prevEdge: null};\r\n      var firstEdge = null;\r\n\r\n      for (var iii = 1; iii < polyLenth3; iii++) {\r\n        p2$1 = new Point(polygonSet[iii]);\r\n        p1$1.nextPoint = p2$1;\r\n        p2$1.prevPoint = p1$1;\r\n\r\n        e$1 = new Edge(p1$1, p2$1, 'polygon', edgeCount, numberOfRingsInPolygon);\r\n        prevEdge$1.nextEdge = e$1;\r\n        e$1.prevEdge = prevEdge$1;\r\n        if (iii === 1) { firstEdge = e$1; }\r\n\r\n        if (ii$1 > 0) { e$1.interiorRing = true; }\r\n        e$1.intersectPolylineBbox = edgeIntersectsBbox(e$1, polylineBbox);\r\n        polyEdges.push(e$1);\r\n\r\n        p1$1 = p2$1;\r\n        edgeCount = edgeCount + 1;\r\n        prevEdge$1 = e$1;\r\n      }\r\n\r\n      e$1.nextEdge = firstEdge;\r\n      firstEdge.prevEdge = e$1;\r\n      p2$1.nextPoint = firstPoint.nextPoint;\r\n      firstPoint.prevPoint = p2$1.prevPoint;\r\n    }\r\n  }\r\n  return contours\r\n}\r\n\r\nfunction edgeIntersectsBbox(edge, bbox) {\r\n  if (edge.maxX < bbox[0]) { return false }\r\n  if (edge.minX > bbox[2]) { return false }\r\n  if (edge.maxY < bbox[1]) { return false }\r\n  if (edge.minY > bbox[3]) { return false }\r\n  return true\r\n}\n\nvar IntersectionPoint = function IntersectionPoint(p, edge1, edge2, isHeadingIn) {\r\n  this.p = p;\r\n  this.polylineEdge = edge1;\r\n  this.polygonEdge = edge2;\r\n  this.isHeadingIn = isHeadingIn;\r\n\r\n  this.distanceFromPolylineEdgeStart = distance(this.polylineEdge.p1.p, this.p);\r\n  this.distanceFromPolygonEdgeStart = distance(this.polygonEdge.p1.p, this.p);\r\n\r\n  this.polygonEdge.intersectionPoints.push(this);\r\n  this.polylineEdge.intersectionPoints.push(this);\r\n\r\n  this.visitCount = 0;\r\n};\r\n\r\nIntersectionPoint.prototype.incrementVisitCount = function incrementVisitCount () {\r\n  this.visitCount = this.visitCount + 1;\r\n};\r\n\r\nfunction distance(p1, p2) {\r\n  var xs = p2[0] - p1[0];\r\n  var ys = p2[1] - p1[1];\r\n  xs *= xs;\r\n  ys *= ys;\r\n\r\n  return Math.sqrt(xs + ys)\r\n}\n\nfunction findIntersectionPoints(polygonEdges, lineEdges, intersectingPoints) {\r\n  var i, ii, iii;\r\n  var count = lineEdges.length;\r\n  var polyCount = polygonEdges.length;\r\n  for (i = 0; i < count; i++) {\r\n    var lineEdge = lineEdges[i];\r\n\r\n    for (ii = 0; ii < polyCount; ii++) {\r\n      var polygonEdge = polygonEdges[ii];\r\n      if (!polygonEdge.intersectPolylineBbox) { continue }\r\n\r\n      if (polygonEdge.maxX < lineEdge.minX || polygonEdge.minX > lineEdge.maxX) { continue }\r\n      if (polygonEdge.maxY < lineEdge.minY || polygonEdge.minY > lineEdge.maxY) { continue }\r\n      var intersection = getEdgeIntersection(lineEdge, polygonEdge);\r\n      if (intersection !== null) {\r\n        for (iii = 0; iii < intersection.length; iii++) {\r\n          var isHeadingIn = orient2d(polygonEdge.p1.p[0], polygonEdge.p1.p[1], polygonEdge.p2.p[0], polygonEdge.p2.p[1], lineEdge.p1.p[0], lineEdge.p1.p[1]);\r\n          var ip = new IntersectionPoint(intersection[iii], lineEdge, polygonEdge, isHeadingIn > 0);\r\n          intersectingPoints.push(ip);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  lineEdges.forEach(function (edge) {\r\n    edge.intersectionPoints.sort(function (a, b) {\r\n      return a.distanceFromPolylineEdgeStart - b.distanceFromPolylineEdgeStart\r\n    });\r\n  });\r\n\r\n  polygonEdges.forEach(function (edge) {\r\n    edge.intersectionPoints.sort(function (a, b) {\r\n      return a.distanceFromPolygonEdgeStart - b.distanceFromPolygonEdgeStart\r\n    });\r\n  });\r\n}\r\n\r\nvar EPSILON = 1e-9;\r\n\r\nfunction crossProduct(a, b) {\r\n  return (a[0] * b[1]) - (a[1] * b[0])\r\n}\r\n\r\nfunction dotProduct(a, b) {\r\n  return (a[0] * b[0]) + (a[1] * b[1])\r\n}\r\n\r\nfunction toPoint(p, s, d) {\r\n  return [\r\n    p[0] + s * d[0],\r\n    p[1] + s * d[1]\r\n  ]\r\n}\r\n\r\nfunction getEdgeIntersection(lineEdge, potentialEdge, noEndpointTouch) {\r\n  var va = [lineEdge.p2.p[0] - lineEdge.p1.p[0], lineEdge.p2.p[1] - lineEdge.p1.p[1]];\r\n  var vb = [potentialEdge.p2.p[0] - potentialEdge.p1.p[0], potentialEdge.p2.p[1] - potentialEdge.p1.p[1]];\r\n\r\n  var e = [potentialEdge.p1.p[0] - lineEdge.p1.p[0], potentialEdge.p1.p[1] - lineEdge.p1.p[1]];\r\n  var kross = crossProduct(va, vb);\r\n  var sqrKross = kross * kross;\r\n  var sqrLenA  = dotProduct(va, va);\r\n\r\n  if (sqrKross > 0) {\r\n\r\n    var s = crossProduct(e, vb) / kross;\r\n    if (s < 0 || s > 1) { return null }\r\n    var t = crossProduct(e, va) / kross;\r\n    if (t < 0 || t > 1) { return null }\r\n    if (s === 0 || s === 1) {\r\n      // on an endpoint of line segment a\r\n      return noEndpointTouch ? null : [toPoint(lineEdge.p1.p, s, va)]\r\n    }\r\n    if (t === 0 || t === 1) {\r\n      // on an endpoint of line segment b\r\n      return noEndpointTouch ? null : [toPoint(potentialEdge.p1.p, t, vb)]\r\n    }\r\n    return [toPoint(lineEdge.p1.p, s, va)]\r\n  }\r\n\r\n  var sqrLenE = dotProduct(e, e);\r\n  kross = crossProduct(e, va);\r\n  sqrKross = kross * kross;\r\n\r\n  if (sqrKross > EPSILON * sqrLenA * sqrLenE) { return null }\r\n\r\n  var sa = dotProduct(va, e) / sqrLenA;\r\n  var sb = sa + dotProduct(va, vb) / sqrLenA;\r\n  var smin = Math.min(sa, sb);\r\n  var smax = Math.max(sa, sb);\r\n\r\n  if (smin <= 1 && smax >= 0) {\r\n\r\n    if (smin === 1) { return noEndpointTouch ? null : [toPoint(lineEdge.p1.p, smin > 0 ? smin : 0, va)] }\r\n\r\n    if (smax === 0) { return noEndpointTouch ? null : [toPoint(lineEdge.p1.p, smax < 1 ? smax : 1, va)] }\r\n\r\n    if (noEndpointTouch && smin === 0 && smax === 1) { return null }\r\n\r\n    return [\r\n      toPoint(lineEdge.p1.p, smin > 0 ? smin : 0, va),\r\n      toPoint(lineEdge.p1.p, smax < 1 ? smax : 1, va)\r\n    ]\r\n  }\r\n\r\n  return null\r\n}\n\n// import { _debugCandidatePoly, _debugIntersectionPoint, _debugLinePoints, _debugIntersectionPoints, _debugPolyStart } from './debug'\r\n\r\nfunction index (polygon, line) {\r\n  var poly = rewind(polygon);\r\n\r\n  var intersections = [];\r\n  var polygonEdges = [];\r\n  var polylineEdges = [];\r\n  var polylineBbox = [Infinity, Infinity, Infinity, Infinity];\r\n\r\n  var contours = fillQueue(poly, line, polygonEdges, polylineEdges, polylineBbox);\r\n\r\n  findIntersectionPoints(polygonEdges, polylineEdges, intersections);\r\n\r\n  if (intersections.length === 0) {\r\n    return polygon\r\n  }\r\n\r\n  // Track the number of intersections per contour\r\n  // This is useful for holes or outerrings that aren't intersected\r\n  // so that we can manually add them back in at the end\r\n  var numberIntersectionsByRing = {};\r\n  contours.forEach(function (c) { return numberIntersectionsByRing[c.id] = 0; }); //eslint-disable-line\r\n  intersections.forEach(function (i) {\r\n    var id = i.polygonEdge.polygonContourId;\r\n    numberIntersectionsByRing[id] = numberIntersectionsByRing[id] + 1;\r\n  });\r\n\r\n\r\n  var infiniteLoopGuard = 0;\r\n  var outPolys = [];\r\n  // _debugIntersectionPoints(intersections)\r\n  // Start the rewiring of the outputs from the first intersection point along the polyline line\r\n  // This step makes a difference (eg see the another.geojson harness file)\r\n  var firstPolyStart = null;\r\n  for (var index = 0; index < polylineEdges.length; index++) {\r\n    var pe = polylineEdges[index];\r\n    if (pe.intersectionPoints.length > 0) {\r\n      firstPolyStart = pe.intersectionPoints[0];\r\n      break\r\n    }\r\n  }\r\n\r\n  var polyStart = firstPolyStart;\r\n  var nextPolyStart = {visitCount: 1};\r\n  // Basically we're going to walk our way around the outside of the polygon\r\n  // to find new output polygons until we get back to the beginning\r\n  while (firstPolyStart !== nextPolyStart) {\r\n    if (infiniteLoopGuard > intersections.length * 2) {\r\n      break\r\n    }\r\n    infiniteLoopGuard = infiniteLoopGuard++;\r\n\r\n    // If we've already visited this intersection point a couple of times we've\r\n    // already used it in it's two output polygons\r\n\r\n    if (nextPolyStart.visitCount >= 2) {\r\n      var unvisitedPolyFound = false;\r\n      for (var index$1 = 0; index$1 < intersections.length; index$1++) {\r\n        var intersection = intersections[index$1];\r\n        if (intersection.visitCount < 2) {\r\n          polyStart = intersection;\r\n          unvisitedPolyFound = true;\r\n          break\r\n        }\r\n      }\r\n      if (!unvisitedPolyFound) { break }\r\n    }\r\n\r\n    polyStart.visitCount = polyStart.visitCount + 1;\r\n    var outPoly = [];\r\n    outPolys.push(outPoly);\r\n    outPoly.push(polyStart.p);\r\n\r\n    polyStart.visitCount = polyStart.visitCount + 1;\r\n    var nextIntersection = walkPolygonForwards(polyStart, outPoly);\r\n    // _debugCandidatePoly(outPolys)\r\n    // After we've walked the first stretch of the polygon we now have the\r\n    // starting point for our next output polygon\r\n    nextPolyStart = nextIntersection;\r\n\r\n\r\n    // Although sometimes we walk all the way around the outside\r\n    // because our split line goes from outer to inner ring\r\n    var override = false;\r\n    if (nextIntersection === nextPolyStart && intersections.length === 2) {\r\n      for (var index$2 = 0; index$2 < intersections.length; index$2++) {\r\n        var intersection$1 = intersections[index$2];\r\n        if (intersection$1.visitCount < 2) {\r\n          override = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // An ouput polygon has to contain at least 1 stretch from the original polygon\r\n    // and one stretch from the polyline\r\n    // However it can contain many stretches of each\r\n    // So we walk continually from polyline to polygon collecting the output\r\n    while (nextIntersection !== polyStart || override) {\r\n      var methodForPolyline = nextIntersection.isHeadingIn ? walkPolylineForwards : walkPolylineBackwards;\r\n      nextIntersection = methodForPolyline(nextIntersection, outPoly);\r\n      // _debugCandidatePoly(outPolys)\r\n\r\n      if (nextIntersection !== polyStart) {\r\n        nextIntersection = walkPolygonForwards(nextIntersection, outPoly);\r\n        // _debugCandidatePoly(outPolys)\r\n      }\r\n      override = false;\r\n    }\r\n\r\n    if (nextPolyStart.visitCount >= 2) {\r\n      var unvisitedPolyFound$1 = false;\r\n      for (var index$3 = 0; index$3 < intersections.length; index$3++) {\r\n        var intersection$2 = intersections[index$3];\r\n        if (intersection$2.visitCount < 2) {\r\n          polyStart = intersection$2;\r\n          unvisitedPolyFound$1 = true;\r\n          break\r\n        }\r\n      }\r\n      if (unvisitedPolyFound$1) {\r\n        nextPolyStart = polyStart;\r\n      }\r\n    }\r\n\r\n    // Finally we set the next start point based on what we found earlier\r\n    polyStart = nextPolyStart;\r\n  }\r\n\r\n  var outCoordinates = outPolys.map(function (poly) { return [poly]; });\r\n\r\n  var keys = Object.keys(numberIntersectionsByRing);\r\n  for (var index$4 = 0; index$4 < keys.length; index$4++) {\r\n    var key = keys[index$4];\r\n    var value = numberIntersectionsByRing[key];\r\n    if (value === 0) {\r\n      var edge = findFirstPolygonEdge(polygonEdges, parseInt(key));\r\n      var ring = findRingFromEdge(edge, contours);\r\n      createAsHoleOrAddAsNewOuterRing(ring, outCoordinates);\r\n    }\r\n  }\r\n\r\n  return {\r\n    type: 'Feature',\r\n    properties: {},\r\n    geometry: {\r\n      type: 'MultiPolygon',\r\n      coordinates: outCoordinates\r\n    }\r\n  }\r\n}\r\n\r\nfunction findFirstPolygonEdge(polygonEdges, contourId) {\r\n  for (var index = 0; index < polygonEdges.length; index++) {\r\n    var edge = polygonEdges[index];\r\n    if (edge.polygonContourId === contourId) { return edge }\r\n  }\r\n}\r\n\r\nfunction findRingFromEdge(edge, contours) {\r\n  var contour = contours.find(function (c) { return c.id === edge.polygonContourId; });\r\n  return contour.rawCoords\r\n}\r\n\r\nfunction createAsHoleOrAddAsNewOuterRing(unusedRing, outCoordinates) {\r\n  for (var index = 0; index < outCoordinates.length; index++) {\r\n    var existingRing = outCoordinates[index];\r\n    if (inside(unusedRing[0], [existingRing[0]])) {\r\n      existingRing.push(unusedRing);\r\n      return\r\n    }\r\n  }\r\n  // If no match is found push it as a new outer ring\r\n  outCoordinates.push([unusedRing]);\r\n}\r\n\r\n// Walk around the polygon collecting vertices\r\nfunction walkPolygonForwards(intersectionPoint, outPoly) {\r\n  var nextEdge = intersectionPoint.polygonEdge;\r\n  if (nextEdge.intersectionPoints.length > 1) {\r\n    // _debugIntersectionPoint(intersectionPoint)\r\n    var lastPointOnEdge = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];\r\n    if (lastPointOnEdge !== intersectionPoint) {\r\n      var currentIndex = findIndexOfIntersectionPoint(intersectionPoint, nextEdge.intersectionPoints);\r\n      var nextIp = nextEdge.intersectionPoints[currentIndex + 1];\r\n      outPoly.push(nextIp.p);\r\n      nextIp.incrementVisitCount();\r\n      return nextIp\r\n    }\r\n  }\r\n  var condition = true;\r\n  while (condition) {\r\n    outPoly.push(nextEdge.p2.p);\r\n    nextEdge = nextEdge.nextEdge;\r\n    if (nextEdge === null) { return intersectionPoint }\r\n    else if (nextEdge.intersectionPoints.length > 0) { condition = false; }\r\n  }\r\n  nextEdge.intersectionPoints[0].incrementVisitCount();\r\n  outPoly.push(nextEdge.intersectionPoints[0].p);\r\n  return nextEdge.intersectionPoints[0]\r\n}\r\n\r\n// Given a set of intersections find the next one\r\nfunction findIndexOfIntersectionPoint(intersection, intersections) {\r\n  for (var index = 0; index < intersections.length; index++) {\r\n    var int = intersections[index];\r\n    if (int === intersection) { return index }\r\n  }\r\n  return null\r\n}\r\n\r\n\r\nfunction walkPolylineBackwards(intersectionPoint, outPoly) {\r\n  var nextEdge = intersectionPoint.polylineEdge;\r\n  if (nextEdge.intersectionPoints.length === 2) {\r\n    var lastPointOnEdge = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];\r\n    // debugger\r\n    if (lastPointOnEdge === intersectionPoint) {\r\n      var nextIntersection = nextEdge.intersectionPoints[0];\r\n      outPoly.push(nextIntersection.p);\r\n      nextIntersection.incrementVisitCount();\r\n      return nextIntersection\r\n    } else {\r\n      outPoly.push(lastPointOnEdge.p);\r\n      lastPointOnEdge.incrementVisitCount();\r\n      return lastPointOnEdge\r\n    }\r\n  } else if (nextEdge.intersectionPoints.length > 2) {\r\n    // _debugIntersectionPoint(intersectionPoint)\r\n\r\n    var lastPointOnEdge$1 = nextEdge.intersectionPoints[0];\r\n    if (lastPointOnEdge$1 !== intersectionPoint) {\r\n      var currentIndex = findIndexOfIntersectionPoint(intersectionPoint, nextEdge.intersectionPoints);\r\n      var nextIntersection$1 = nextEdge.intersectionPoints[currentIndex - 1];\r\n      outPoly.push(nextIntersection$1.p);\r\n      nextIntersection$1.incrementVisitCount();\r\n      return nextIntersection$1\r\n    }\r\n  }\r\n  var condition = true;\r\n  while (condition) {\r\n    outPoly.push(nextEdge.p1.p);\r\n    nextEdge = nextEdge.prevEdge;\r\n    if (nextEdge.originalIndex === undefined) { return intersectionPoint }\r\n    else if (nextEdge.intersectionPoints.length > 0) {\r\n      condition = false;\r\n    }\r\n  }\r\n  if (nextEdge.originalIndex === undefined) { return intersectionPoint }\r\n  var lastIntersection = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];\r\n  lastIntersection.incrementVisitCount();\r\n  outPoly.push(lastIntersection.p);\r\n  return lastIntersection\r\n}\r\n\r\nfunction walkPolylineForwards(intersectionPoint, outPoly) {\r\n  var nextEdge = intersectionPoint.polylineEdge;\r\n\r\n  if (nextEdge.intersectionPoints.length > 1) {\r\n    // _debugIntersectionPoint(intersectionPoint)\r\n    var lastPointOnEdge = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];\r\n    if (lastPointOnEdge !== intersectionPoint) {\r\n      var currentIndex = findIndexOfIntersectionPoint(intersectionPoint, nextEdge.intersectionPoints);\r\n      var nextIp = nextEdge.intersectionPoints[currentIndex + 1];\r\n      outPoly.push(nextIp.p);\r\n      nextIp.incrementVisitCount();\r\n      return nextIp\r\n    }\r\n  }\r\n  var condition = true;\r\n  while (condition) {\r\n    outPoly.push(nextEdge.p2.p);\r\n    nextEdge = nextEdge.nextEdge;\r\n    if (nextEdge === null) { return intersectionPoint }\r\n    else if (nextEdge.intersectionPoints.length > 0) { condition = false; }\r\n  }\r\n  if (nextEdge === undefined) { return intersectionPoint }\r\n  var lastIntersection = nextEdge.intersectionPoints[0];\r\n  lastIntersection.incrementVisitCount();\r\n  outPoly.push(lastIntersection.p);\r\n  return lastIntersection\r\n}\n\nexport { index as default };\n","export const classes = {\n  CONTROL_BASE: 'mapboxgl-ctrl',\n  CONTROL_PREFIX: 'mapboxgl-ctrl-',\n  CONTROL_BUTTON: 'mapbox-gl-draw_ctrl-draw-btn',\n  CONTROL_BUTTON_LINE: 'mapbox-gl-draw_line',\n  CONTROL_BUTTON_POLYGON: 'mapbox-gl-draw_polygon',\n  CONTROL_BUTTON_POINT: 'mapbox-gl-draw_point',\n  CONTROL_BUTTON_TRASH: 'mapbox-gl-draw_trash',\n  CONTROL_BUTTON_COMBINE_FEATURES: 'mapbox-gl-draw_combine',\n  CONTROL_BUTTON_UNCOMBINE_FEATURES: 'mapbox-gl-draw_uncombine',\n  CONTROL_GROUP: 'mapboxgl-ctrl-group',\n  ATTRIBUTION: 'mapboxgl-ctrl-attrib',\n  ACTIVE_BUTTON: 'active',\n  BOX_SELECT: 'mapbox-gl-draw_boxselect'\n};\n\nexport const sources = {\n  HOT: 'mapbox-gl-draw-hot',\n  COLD: 'mapbox-gl-draw-cold'\n};\n\nexport const cursors = {\n  ADD: 'add',\n  MOVE: 'move',\n  DRAG: 'drag',\n  POINTER: 'pointer',\n  NONE: 'none'\n};\n\nexport const types = {\n  POLYGON: 'polygon',\n  LINE: 'line_string',\n  POINT: 'point'\n};\n\nexport const geojsonTypes = {\n  FEATURE: 'Feature',\n  POLYGON: 'Polygon',\n  LINE_STRING: 'LineString',\n  POINT: 'Point',\n  FEATURE_COLLECTION: 'FeatureCollection',\n  MULTI_PREFIX: 'Multi',\n  MULTI_POINT: 'MultiPoint',\n  MULTI_LINE_STRING: 'MultiLineString',\n  MULTI_POLYGON: 'MultiPolygon'\n};\n\nexport const modes = {\n  DRAW_LINE_STRING: 'draw_line_string',\n  DRAW_POLYGON: 'draw_polygon',\n  DRAW_POINT: 'draw_point',\n  SIMPLE_SELECT: 'simple_select',\n  DIRECT_SELECT: 'direct_select',\n  STATIC: 'static'\n};\n\nexport const events = {\n  CREATE: 'draw.create',\n  DELETE: 'draw.delete',\n  UPDATE: 'draw.update',\n  SELECTION_CHANGE: 'draw.selectionchange',\n  MODE_CHANGE: 'draw.modechange',\n  ACTIONABLE: 'draw.actionable',\n  RENDER: 'draw.render',\n  COMBINE_FEATURES: 'draw.combine',\n  UNCOMBINE_FEATURES: 'draw.uncombine'\n};\n\nexport const updateActions = {\n  MOVE: 'move',\n  CHANGE_COORDINATES: 'change_coordinates'\n};\n\nexport const meta = {\n  FEATURE: 'feature',\n  MIDPOINT: 'midpoint',\n  VERTEX: 'vertex'\n};\n\nexport const activeStates = {\n  ACTIVE: 'true',\n  INACTIVE: 'false'\n};\n\nexport const interactions = [\n  'scrollZoom',\n  'boxZoom',\n  'dragRotate',\n  'dragPan',\n  'keyboard',\n  'doubleClickZoom',\n  'touchZoomRotate'\n];\n\nexport const LAT_MIN = -90;\nexport const LAT_RENDERED_MIN = -85;\nexport const LAT_MAX = 90;\nexport const LAT_RENDERED_MAX = 85;\nexport const LNG_MIN = -270;\nexport const LNG_MAX = 270;\n","// index.ts\nvar earthRadius = 63710088e-1;\nvar factors = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: 360 / (2 * Math.PI),\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1e3,\n  kilometres: earthRadius / 1e3,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1e3,\n  millimetres: earthRadius * 1e3,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936\n};\nvar areaFactors = {\n  acres: 247105e-9,\n  centimeters: 1e4,\n  centimetres: 1e4,\n  feet: 10.763910417,\n  hectares: 1e-4,\n  inches: 1550.003100006,\n  kilometers: 1e-6,\n  kilometres: 1e-6,\n  meters: 1,\n  metres: 1,\n  miles: 386e-9,\n  nauticalmiles: 29155334959812285e-23,\n  millimeters: 1e6,\n  millimetres: 1e6,\n  yards: 1.195990046\n};\nfunction feature(geom, properties, options = {}) {\n  const feat = { type: \"Feature\" };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\nfunction geometry(type, coordinates, _options = {}) {\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\nfunction point(coordinates, properties, options = {}) {\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n  const geom = {\n    type: \"Point\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction points(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return point(coords, properties);\n    }),\n    options\n  );\n}\nfunction polygon(coordinates, properties, options = {}) {\n  for (const ring of coordinates) {\n    if (ring.length < 4) {\n      throw new Error(\n        \"Each LinearRing of a Polygon must have 4 or more Positions.\"\n      );\n    }\n    if (ring[ring.length - 1].length !== ring[0].length) {\n      throw new Error(\"First and last Position are not equivalent.\");\n    }\n    for (let j = 0; j < ring[ring.length - 1].length; j++) {\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  const geom = {\n    type: \"Polygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction polygons(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return polygon(coords, properties);\n    }),\n    options\n  );\n}\nfunction lineString(coordinates, properties, options = {}) {\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  const geom = {\n    type: \"LineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction lineStrings(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return lineString(coords, properties);\n    }),\n    options\n  );\n}\nfunction featureCollection(features, options = {}) {\n  const fc = { type: \"FeatureCollection\" };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\nfunction multiLineString(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiLineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPoint(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPoint\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPolygon(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPolygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction geometryCollection(geometries, properties, options = {}) {\n  const geom = {\n    type: \"GeometryCollection\",\n    geometries\n  };\n  return feature(geom, properties, options);\n}\nfunction round(num, precision = 0) {\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  const multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\nfunction radiansToLength(radians, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\nfunction lengthToRadians(distance, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\nfunction bearingToAzimuth(bearing) {\n  let angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\nfunction azimuthToBearing(angle) {\n  angle = angle % 360;\n  if (angle > 180) {\n    return angle - 360;\n  } else if (angle < -180) {\n    return angle + 360;\n  }\n  return angle;\n}\nfunction radiansToDegrees(radians) {\n  const normalisedRadians = radians % (2 * Math.PI);\n  return normalisedRadians * 180 / Math.PI;\n}\nfunction degreesToRadians(degrees) {\n  const normalisedDegrees = degrees % 360;\n  return normalisedDegrees * Math.PI / 180;\n}\nfunction convertLength(length, originalUnit = \"kilometers\", finalUnit = \"kilometers\") {\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nfunction convertArea(area, originalUnit = \"meters\", finalUnit = \"kilometers\") {\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n  const startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n  const finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n  return area / startFactor * finalFactor;\n}\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nfunction isObject(input) {\n  return input !== null && typeof input === \"object\" && !Array.isArray(input);\n}\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach((num) => {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\nfunction validateId(id) {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\nexport {\n  areaFactors,\n  azimuthToBearing,\n  bearingToAzimuth,\n  convertArea,\n  convertLength,\n  degreesToRadians,\n  earthRadius,\n  factors,\n  feature,\n  featureCollection,\n  geometry,\n  geometryCollection,\n  isNumber,\n  isObject,\n  lengthToDegrees,\n  lengthToRadians,\n  lineString,\n  lineStrings,\n  multiLineString,\n  multiPoint,\n  multiPolygon,\n  point,\n  points,\n  polygon,\n  polygons,\n  radiansToDegrees,\n  radiansToLength,\n  round,\n  validateBBox,\n  validateId\n};\n//# sourceMappingURL=index.js.map","class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nfunction checkWhichEventIsLeft (e1, e2) {\n    if (e1.p.x > e2.p.x) return 1\n    if (e1.p.x < e2.p.x) return -1\n\n    if (e1.p.y !== e2.p.y) return e1.p.y > e2.p.y ? 1 : -1\n    return 1\n}\n\nfunction checkWhichSegmentHasRightEndpointFirst (seg1, seg2) {\n    if (seg1.rightSweepEvent.p.x > seg2.rightSweepEvent.p.x) return 1\n    if (seg1.rightSweepEvent.p.x < seg2.rightSweepEvent.p.x) return -1\n\n    if (seg1.rightSweepEvent.p.y !== seg2.rightSweepEvent.p.y) return seg1.rightSweepEvent.p.y < seg2.rightSweepEvent.p.y ? 1 : -1\n    return 1\n}\n\nclass Event {\n\n    constructor (p, featureId, ringId, eventId) {\n        this.p = {\n            x: p[0],\n            y: p[1]\n        };\n        this.featureId = featureId;\n        this.ringId = ringId;\n        this.eventId = eventId;\n\n        this.otherEvent = null;\n        this.isLeftEndpoint = null;\n    }\n\n    isSamePoint (eventToCheck) {\n        return this.p.x === eventToCheck.p.x && this.p.y === eventToCheck.p.y\n    }\n}\n\nfunction fillEventQueue (geojson, eventQueue) {\n    if (geojson.type === 'FeatureCollection') {\n        const features = geojson.features;\n        for (let i = 0; i < features.length; i++) {\n            processFeature(features[i], eventQueue);\n        }\n    } else {\n        processFeature(geojson, eventQueue);\n    }\n}\n\nlet featureId = 0;\nlet ringId = 0;\nlet eventId = 0;\nfunction processFeature (featureOrGeometry, eventQueue) {\n    const geom = featureOrGeometry.type === 'Feature' ? featureOrGeometry.geometry : featureOrGeometry;\n    let coords = geom.coordinates;\n    // standardise the input\n    if (geom.type === 'Polygon' || geom.type === 'MultiLineString') coords = [coords];\n    if (geom.type === 'LineString') coords = [[coords]];\n\n    for (let i = 0; i < coords.length; i++) {\n        for (let ii = 0; ii < coords[i].length; ii++) {\n            let currentP = coords[i][ii][0];\n            let nextP = null;\n            ringId = ringId + 1;\n            for (let iii = 0; iii < coords[i][ii].length - 1; iii++) {\n                nextP = coords[i][ii][iii + 1];\n\n                const e1 = new Event(currentP, featureId, ringId, eventId);\n                const e2 = new Event(nextP, featureId, ringId, eventId + 1);\n\n                e1.otherEvent = e2;\n                e2.otherEvent = e1;\n\n                if (checkWhichEventIsLeft(e1, e2) > 0) {\n                    e2.isLeftEndpoint = true;\n                    e1.isLeftEndpoint = false;\n                } else {\n                    e1.isLeftEndpoint = true;\n                    e2.isLeftEndpoint = false;\n                }\n                eventQueue.push(e1);\n                eventQueue.push(e2);\n\n                currentP = nextP;\n                eventId = eventId + 1;\n            }\n        }\n    }\n    featureId = featureId + 1;\n}\n\nclass Segment {\n\n    constructor (event) {\n        this.leftSweepEvent = event;\n        this.rightSweepEvent = event.otherEvent;\n    }\n}\n\nfunction testSegmentIntersect (seg1, seg2) {\n    if (seg1 === null || seg2 === null) return false\n\n    if (seg1.leftSweepEvent.ringId === seg2.leftSweepEvent.ringId &&\n        (seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) ||\n        seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) ||\n        seg1.rightSweepEvent.isSamePoint(seg2.rightSweepEvent) ||\n        seg1.leftSweepEvent.isSamePoint(seg2.leftSweepEvent) ||\n        seg1.leftSweepEvent.isSamePoint(seg2.rightSweepEvent))) return false\n\n    const x1 = seg1.leftSweepEvent.p.x;\n    const y1 = seg1.leftSweepEvent.p.y;\n    const x2 = seg1.rightSweepEvent.p.x;\n    const y2 = seg1.rightSweepEvent.p.y;\n    const x3 = seg2.leftSweepEvent.p.x;\n    const y3 = seg2.leftSweepEvent.p.y;\n    const x4 = seg2.rightSweepEvent.p.x;\n    const y4 = seg2.rightSweepEvent.p.y;\n\n    const denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n    const numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n    const numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) return false\n        return false\n    }\n\n    const uA = numeA / denom;\n    const uB = numeB / denom;\n\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        const x = x1 + (uA * (x2 - x1));\n        const y = y1 + (uA * (y2 - y1));\n        return [x, y]\n    }\n    return false\n}\n\n// import {debugEventAndSegments, debugRemovingSegment} from './debug'\n\nfunction runCheck (eventQueue, ignoreSelfIntersections) {\n    ignoreSelfIntersections = ignoreSelfIntersections ? ignoreSelfIntersections : false;\n\n    const intersectionPoints = [];\n    const outQueue = new TinyQueue([], checkWhichSegmentHasRightEndpointFirst);\n\n    while (eventQueue.length) {\n        const event = eventQueue.pop();\n        if (event.isLeftEndpoint) {\n            // debugEventAndSegments(event.p, outQueue.data)\n            const segment = new Segment(event);\n            for (let i = 0; i < outQueue.data.length; i++) {\n                const otherSeg = outQueue.data[i];\n                if (ignoreSelfIntersections) {\n                    if (otherSeg.leftSweepEvent.featureId === event.featureId) continue\n                }\n                const intersection = testSegmentIntersect(segment, otherSeg);\n                if (intersection !== false) intersectionPoints.push(intersection);\n            }\n            outQueue.push(segment);\n        } else if (event.isLeftEndpoint === false) {\n            outQueue.pop();\n            // const seg = outQueue.pop()\n            // debugRemovingSegment(event.p, seg)\n        }\n    }\n    return intersectionPoints\n}\n\nfunction sweeplineIntersections (geojson, ignoreSelfIntersections) {\n    const eventQueue = new TinyQueue([], checkWhichEventIsLeft);\n    fillEventQueue(geojson, eventQueue);\n    return runCheck(eventQueue, ignoreSelfIntersections)\n}\n\nexport default sweeplineIntersections;\n","// index.ts\nimport { feature, featureCollection, point } from \"@turf/helpers\";\n\n// lib/sweepline-intersections-export.ts\nimport lib from \"sweepline-intersections\";\nvar sweeplineIntersections = lib;\n\n// index.ts\nfunction lineIntersect(line1, line2, options = {}) {\n  const { removeDuplicates = true, ignoreSelfIntersections = true } = options;\n  let features = [];\n  if (line1.type === \"FeatureCollection\")\n    features = features.concat(line1.features);\n  else if (line1.type === \"Feature\") features.push(line1);\n  else if (line1.type === \"LineString\" || line1.type === \"Polygon\" || line1.type === \"MultiLineString\" || line1.type === \"MultiPolygon\") {\n    features.push(feature(line1));\n  }\n  if (line2.type === \"FeatureCollection\")\n    features = features.concat(line2.features);\n  else if (line2.type === \"Feature\") features.push(line2);\n  else if (line2.type === \"LineString\" || line2.type === \"Polygon\" || line2.type === \"MultiLineString\" || line2.type === \"MultiPolygon\") {\n    features.push(feature(line2));\n  }\n  const intersections = sweeplineIntersections(\n    featureCollection(features),\n    ignoreSelfIntersections\n  );\n  let results = [];\n  if (removeDuplicates) {\n    const unique = {};\n    intersections.forEach((intersection) => {\n      const key = intersection.join(\",\");\n      if (!unique[key]) {\n        unique[key] = true;\n        results.push(intersection);\n      }\n    });\n  } else {\n    results = intersections;\n  }\n  return featureCollection(results.map((r) => point(r)));\n}\nvar turf_line_intersect_default = lineIntersect;\nexport {\n  turf_line_intersect_default as default,\n  lineIntersect\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { isNumber } from \"@turf/helpers\";\nfunction getCoord(coord) {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n  if (!Array.isArray(coord)) {\n    if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\n      return [...coord.geometry.coordinates];\n    }\n    if (coord.type === \"Point\") {\n      return [...coord.coordinates];\n    }\n  }\n  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\n    return [...coord];\n  }\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\nfunction getCoords(coords) {\n  if (Array.isArray(coords)) {\n    return coords;\n  }\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n  throw new Error(\n    \"coords must be GeoJSON Feature, Geometry Object or an Array\"\n  );\n}\nfunction containsNumber(coordinates) {\n  if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n    return true;\n  }\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n  throw new Error(\"coordinates must only contain numbers\");\n}\nfunction geojsonType(value, type, name) {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n  if (!value || value.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type\n    );\n  }\n}\nfunction featureOf(feature, type, name) {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\n      \"Invalid input to \" + name + \", Feature with geometry required\"\n    );\n  }\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n    );\n  }\n}\nfunction collectionOf(featureCollection, type, name) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\n      \"Invalid input to \" + name + \", FeatureCollection required\"\n    );\n  }\n  for (const feature of featureCollection.features) {\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\n        \"Invalid input to \" + name + \", Feature with geometry required\"\n      );\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\n        \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n      );\n    }\n  }\n}\nfunction getGeom(geojson) {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n  return geojson;\n}\nfunction getType(geojson, _name) {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n  return geojson.type;\n}\nexport {\n  collectionOf,\n  containsNumber,\n  featureOf,\n  geojsonType,\n  getCoord,\n  getCoords,\n  getGeom,\n  getType\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport pip from \"point-in-polygon-hao\";\nimport { getCoord, getGeom } from \"@turf/invariant\";\nfunction booleanPointInPolygon(point, polygon, options = {}) {\n  if (!point) {\n    throw new Error(\"point is required\");\n  }\n  if (!polygon) {\n    throw new Error(\"polygon is required\");\n  }\n  const pt = getCoord(point);\n  const geom = getGeom(polygon);\n  const type = geom.type;\n  const bbox = polygon.bbox;\n  let polys = geom.coordinates;\n  if (bbox && inBBox(pt, bbox) === false) {\n    return false;\n  }\n  if (type === \"Polygon\") {\n    polys = [polys];\n  }\n  let result = false;\n  for (var i = 0; i < polys.length; ++i) {\n    const polyResult = pip(pt, polys[i]);\n    if (polyResult === 0) return options.ignoreBoundary ? false : true;\n    else if (polyResult) result = true;\n  }\n  return result;\n}\nfunction inBBox(pt, bbox) {\n  return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];\n}\nvar turf_boolean_point_in_polygon_default = booleanPointInPolygon;\nexport {\n  booleanPointInPolygon,\n  turf_boolean_point_in_polygon_default as default\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { feature, point, lineString, isObject } from \"@turf/helpers\";\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  if (geojson === null) return;\n  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === \"FeatureCollection\", isFeature = type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(\n            coords,\n            coordIndex,\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(\n              coords[j],\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false)\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(\n                coords[j][k],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false)\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(\n                  coords[j][k][l],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false)\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (coordIndex === 0 && initialValue === void 0)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function(currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function(currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function(coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\nfunction geomEach(geojson, callback) {\n  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === \"FeatureCollection\", isFeature = geojson.type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      if (geometry === null) {\n        if (callback(\n          null,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        ) === false)\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (callback(\n            geometry,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false)\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (callback(\n              geometry.geometries[j],\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false)\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    featureIndex++;\n  }\n}\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(\n          feature(geometry, properties, { bbox, id }),\n          featureIndex,\n          0\n        ) === false)\n          return false;\n        return;\n    }\n    var geomType;\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)\n        return false;\n    }\n  });\n}\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function(currentFeature, featureIndex, multiFeatureIndex) {\n      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n    if (!feature2.geometry) return;\n    var type = feature2.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(\n      feature2,\n      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n          previousCoords = currentCoord;\n          previousFeatureIndex = featureIndex;\n          previousMultiIndex = multiPartIndexCoord;\n          prevGeomIndex = geometryIndex;\n          segmentIndex = 0;\n          return;\n        }\n        var currentSegment = lineString(\n          [previousCoords, currentCoord],\n          feature2.properties\n        );\n        if (callback(\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        ) === false)\n          return false;\n        segmentIndex++;\n        previousCoords = currentCoord;\n      }\n    ) === false)\n      return false;\n  });\n}\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n      if (started === false && initialValue === void 0)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\nfunction lineEach(geojson, callback) {\n  if (!geojson) throw new Error(\"geojson is required\");\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    if (feature2.geometry === null) return;\n    var type = feature2.geometry.type;\n    var coords = feature2.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(\n            lineString(coords[geometryIndex], feature2.properties),\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n        }\n        break;\n    }\n  });\n}\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction findSegment(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nfunction findPoint(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nexport {\n  coordAll,\n  coordEach,\n  coordReduce,\n  featureEach,\n  featureReduce,\n  findPoint,\n  findSegment,\n  flattenEach,\n  flattenReduce,\n  geomEach,\n  geomReduce,\n  lineEach,\n  lineReduce,\n  propEach,\n  propReduce,\n  segmentEach,\n  segmentReduce\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { featureCollection, lineString, multiLineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\nfunction polygonToLine(poly, options = {}) {\n  const geom = getGeom(poly);\n  if (!options.properties && poly.type === \"Feature\") {\n    options.properties = poly.properties;\n  }\n  switch (geom.type) {\n    case \"Polygon\":\n      return singlePolygonToLine(geom, options);\n    case \"MultiPolygon\":\n      return multiPolygonToLine(geom, options);\n    default:\n      throw new Error(\"invalid poly\");\n  }\n}\nfunction singlePolygonToLine(poly, options = {}) {\n  const geom = getGeom(poly);\n  const coords = geom.coordinates;\n  const properties = options.properties ? options.properties : poly.type === \"Feature\" ? poly.properties : {};\n  return coordsToLine(coords, properties);\n}\nfunction multiPolygonToLine(multiPoly, options = {}) {\n  const geom = getGeom(multiPoly);\n  const coords = geom.coordinates;\n  const properties = options.properties ? options.properties : multiPoly.type === \"Feature\" ? multiPoly.properties : {};\n  const lines = [];\n  coords.forEach((coord) => {\n    lines.push(coordsToLine(coord, properties));\n  });\n  return featureCollection(lines);\n}\nfunction coordsToLine(coords, properties) {\n  if (coords.length > 1) {\n    return multiLineString(coords, properties);\n  }\n  return lineString(coords[0], properties);\n}\nvar turf_polygon_to_line_default = polygonToLine;\nexport {\n  coordsToLine,\n  turf_polygon_to_line_default as default,\n  multiPolygonToLine,\n  polygonToLine,\n  singlePolygonToLine\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { lineIntersect } from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { polygonToLine } from \"@turf/polygon-to-line\";\nfunction booleanDisjoint(feature1, feature2, {\n  ignoreSelfIntersections = true\n} = { ignoreSelfIntersections: true }) {\n  let bool = true;\n  flattenEach(feature1, (flatten1) => {\n    flattenEach(feature2, (flatten2) => {\n      if (bool === false) {\n        return false;\n      }\n      bool = disjoint(\n        flatten1.geometry,\n        flatten2.geometry,\n        ignoreSelfIntersections\n      );\n    });\n  });\n  return bool;\n}\nfunction disjoint(geom1, geom2, ignoreSelfIntersections) {\n  switch (geom1.type) {\n    case \"Point\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !compareCoords(geom1.coordinates, geom2.coordinates);\n        case \"LineString\":\n          return !isPointOnLine(geom2, geom1);\n        case \"Polygon\":\n          return !booleanPointInPolygon(geom1, geom2);\n      }\n      break;\n    case \"LineString\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !isPointOnLine(geom1, geom2);\n        case \"LineString\":\n          return !isLineOnLine(geom1, geom2, ignoreSelfIntersections);\n        case \"Polygon\":\n          return !isLineInPoly(geom2, geom1, ignoreSelfIntersections);\n      }\n      break;\n    case \"Polygon\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !booleanPointInPolygon(geom2, geom1);\n        case \"LineString\":\n          return !isLineInPoly(geom1, geom2, ignoreSelfIntersections);\n        case \"Polygon\":\n          return !isPolyInPoly(geom2, geom1, ignoreSelfIntersections);\n      }\n  }\n  return false;\n}\nfunction isPointOnLine(lineString, pt) {\n  for (let i = 0; i < lineString.coordinates.length - 1; i++) {\n    if (isPointOnLineSegment(\n      lineString.coordinates[i],\n      lineString.coordinates[i + 1],\n      pt.coordinates\n    )) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isLineOnLine(lineString1, lineString2, ignoreSelfIntersections) {\n  const doLinesIntersect = lineIntersect(lineString1, lineString2, {\n    ignoreSelfIntersections\n  });\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\nfunction isLineInPoly(polygon, lineString, ignoreSelfIntersections) {\n  for (const coord of lineString.coordinates) {\n    if (booleanPointInPolygon(coord, polygon)) {\n      return true;\n    }\n  }\n  const doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon), {\n    ignoreSelfIntersections\n  });\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\nfunction isPolyInPoly(feature1, feature2, ignoreSelfIntersections) {\n  for (const coord1 of feature1.coordinates[0]) {\n    if (booleanPointInPolygon(coord1, feature2)) {\n      return true;\n    }\n  }\n  for (const coord2 of feature2.coordinates[0]) {\n    if (booleanPointInPolygon(coord2, feature1)) {\n      return true;\n    }\n  }\n  const doLinesIntersect = lineIntersect(\n    polygonToLine(feature1),\n    polygonToLine(feature2),\n    { ignoreSelfIntersections }\n  );\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {\n  const dxc = pt[0] - lineSegmentStart[0];\n  const dyc = pt[1] - lineSegmentStart[1];\n  const dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n  const dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n  const cross = dxc * dyl - dyc * dxl;\n  if (cross !== 0) {\n    return false;\n  }\n  if (Math.abs(dxl) >= Math.abs(dyl)) {\n    if (dxl > 0) {\n      return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];\n    } else {\n      return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n    }\n  } else if (dyl > 0) {\n    return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];\n  } else {\n    return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n  }\n}\nfunction compareCoords(pair1, pair2) {\n  return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nvar turf_boolean_disjoint_default = booleanDisjoint;\nexport {\n  booleanDisjoint,\n  turf_boolean_disjoint_default as default\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { feature, point, lineString, isObject } from \"@turf/helpers\";\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  if (geojson === null) return;\n  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === \"FeatureCollection\", isFeature = type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(\n            coords,\n            coordIndex,\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(\n              coords[j],\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false)\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(\n                coords[j][k],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false)\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(\n                  coords[j][k][l],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false)\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (coordIndex === 0 && initialValue === void 0)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function(currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function(currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function(coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\nfunction geomEach(geojson, callback) {\n  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === \"FeatureCollection\", isFeature = geojson.type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      if (geometry === null) {\n        if (callback(\n          null,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        ) === false)\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (callback(\n            geometry,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false)\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (callback(\n              geometry.geometries[j],\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false)\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    featureIndex++;\n  }\n}\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(\n          feature(geometry, properties, { bbox, id }),\n          featureIndex,\n          0\n        ) === false)\n          return false;\n        return;\n    }\n    var geomType;\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)\n        return false;\n    }\n  });\n}\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function(currentFeature, featureIndex, multiFeatureIndex) {\n      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n    if (!feature2.geometry) return;\n    var type = feature2.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(\n      feature2,\n      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n          previousCoords = currentCoord;\n          previousFeatureIndex = featureIndex;\n          previousMultiIndex = multiPartIndexCoord;\n          prevGeomIndex = geometryIndex;\n          segmentIndex = 0;\n          return;\n        }\n        var currentSegment = lineString(\n          [previousCoords, currentCoord],\n          feature2.properties\n        );\n        if (callback(\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        ) === false)\n          return false;\n        segmentIndex++;\n        previousCoords = currentCoord;\n      }\n    ) === false)\n      return false;\n  });\n}\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n      if (started === false && initialValue === void 0)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\nfunction lineEach(geojson, callback) {\n  if (!geojson) throw new Error(\"geojson is required\");\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    if (feature2.geometry === null) return;\n    var type = feature2.geometry.type;\n    var coords = feature2.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(\n            lineString(coords[geometryIndex], feature2.properties),\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n        }\n        break;\n    }\n  });\n}\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction findSegment(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nfunction findPoint(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nexport {\n  coordAll,\n  coordEach,\n  coordReduce,\n  featureEach,\n  featureReduce,\n  findPoint,\n  findSegment,\n  flattenEach,\n  flattenReduce,\n  geomEach,\n  geomReduce,\n  lineEach,\n  lineReduce,\n  propEach,\n  propReduce,\n  segmentEach,\n  segmentReduce\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { flattenEach } from \"@turf/meta\";\nimport { getCoords, getType } from \"@turf/invariant\";\nimport {\n  isObject,\n  lineString,\n  multiLineString,\n  lengthToDegrees\n} from \"@turf/helpers\";\n\n// lib/intersection.js\nfunction ab(segment) {\n  var start = segment[0];\n  var end = segment[1];\n  return [end[0] - start[0], end[1] - start[1]];\n}\nfunction crossProduct(v1, v2) {\n  return v1[0] * v2[1] - v2[0] * v1[1];\n}\nfunction add(v1, v2) {\n  return [v1[0] + v2[0], v1[1] + v2[1]];\n}\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\nfunction scalarMult(s, v) {\n  return [s * v[0], s * v[1]];\n}\nfunction intersectSegments(a, b) {\n  var p = a[0];\n  var r = ab(a);\n  var q = b[0];\n  var s = ab(b);\n  var cross = crossProduct(r, s);\n  var qmp = sub(q, p);\n  var numerator = crossProduct(qmp, s);\n  var t = numerator / cross;\n  var intersection2 = add(p, scalarMult(t, r));\n  return intersection2;\n}\nfunction isParallel(a, b) {\n  var r = ab(a);\n  var s = ab(b);\n  return crossProduct(r, s) === 0;\n}\nfunction intersection(a, b) {\n  if (isParallel(a, b)) return false;\n  return intersectSegments(a, b);\n}\n\n// index.js\nfunction lineOffset(geojson, distance, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (distance === void 0 || distance === null || isNaN(distance))\n    throw new Error(\"distance is required\");\n  var type = getType(geojson);\n  var properties = geojson.properties;\n  switch (type) {\n    case \"LineString\":\n      return lineOffsetFeature(geojson, distance, units);\n    case \"MultiLineString\":\n      var coords = [];\n      flattenEach(geojson, function(feature) {\n        coords.push(\n          lineOffsetFeature(feature, distance, units).geometry.coordinates\n        );\n      });\n      return multiLineString(coords, properties);\n    default:\n      throw new Error(\"geometry \" + type + \" is not supported\");\n  }\n}\nfunction lineOffsetFeature(line, distance, units) {\n  var segments = [];\n  var offsetDegrees = lengthToDegrees(distance, units);\n  var coords = getCoords(line);\n  var finalCoords = [];\n  coords.forEach(function(currentCoords, index) {\n    if (index !== coords.length - 1) {\n      var segment = processSegment(\n        currentCoords,\n        coords[index + 1],\n        offsetDegrees\n      );\n      segments.push(segment);\n      if (index > 0) {\n        var seg2Coords = segments[index - 1];\n        var intersects = intersection(segment, seg2Coords);\n        if (intersects !== false) {\n          seg2Coords[1] = intersects;\n          segment[0] = intersects;\n        }\n        finalCoords.push(seg2Coords[0]);\n        if (index === coords.length - 2) {\n          finalCoords.push(segment[0]);\n          finalCoords.push(segment[1]);\n        }\n      }\n      if (coords.length === 2) {\n        finalCoords.push(segment[0]);\n        finalCoords.push(segment[1]);\n      }\n    }\n  });\n  return lineString(finalCoords, line.properties);\n}\nfunction processSegment(point1, point2, offset) {\n  var L = Math.sqrt(\n    (point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1])\n  );\n  var out1x = point1[0] + offset * (point2[1] - point1[1]) / L;\n  var out2x = point2[0] + offset * (point2[1] - point1[1]) / L;\n  var out1y = point1[1] + offset * (point1[0] - point2[0]) / L;\n  var out2y = point2[1] + offset * (point1[0] - point2[0]) / L;\n  return [\n    [out1x, out1y],\n    [out2x, out2y]\n  ];\n}\nvar turf_line_offset_default = lineOffset;\nexport {\n  turf_line_offset_default as default,\n  lineOffset\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { isNumber } from \"@turf/helpers\";\nfunction getCoord(coord) {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n  if (!Array.isArray(coord)) {\n    if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\n      return [...coord.geometry.coordinates];\n    }\n    if (coord.type === \"Point\") {\n      return [...coord.coordinates];\n    }\n  }\n  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\n    return [...coord];\n  }\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\nfunction getCoords(coords) {\n  if (Array.isArray(coords)) {\n    return coords;\n  }\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n  throw new Error(\n    \"coords must be GeoJSON Feature, Geometry Object or an Array\"\n  );\n}\nfunction containsNumber(coordinates) {\n  if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n    return true;\n  }\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n  throw new Error(\"coordinates must only contain numbers\");\n}\nfunction geojsonType(value, type, name) {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n  if (!value || value.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type\n    );\n  }\n}\nfunction featureOf(feature, type, name) {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\n      \"Invalid input to \" + name + \", Feature with geometry required\"\n    );\n  }\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n    );\n  }\n}\nfunction collectionOf(featureCollection, type, name) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\n      \"Invalid input to \" + name + \", FeatureCollection required\"\n    );\n  }\n  for (const feature of featureCollection.features) {\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\n        \"Invalid input to \" + name + \", Feature with geometry required\"\n      );\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\n        \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n      );\n    }\n  }\n}\nfunction getGeom(geojson) {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n  return geojson;\n}\nfunction getType(geojson, _name) {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n  return geojson.type;\n}\nexport {\n  collectionOf,\n  containsNumber,\n  featureOf,\n  geojsonType,\n  getCoord,\n  getCoords,\n  getGeom,\n  getType\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { feature, point, lineString, isObject } from \"@turf/helpers\";\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  if (geojson === null) return;\n  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === \"FeatureCollection\", isFeature = type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(\n            coords,\n            coordIndex,\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(\n              coords[j],\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false)\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(\n                coords[j][k],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false)\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(\n                  coords[j][k][l],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false)\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (coordIndex === 0 && initialValue === void 0)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function(currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function(currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function(coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\nfunction geomEach(geojson, callback) {\n  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === \"FeatureCollection\", isFeature = geojson.type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      if (geometry === null) {\n        if (callback(\n          null,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        ) === false)\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (callback(\n            geometry,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false)\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (callback(\n              geometry.geometries[j],\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false)\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    featureIndex++;\n  }\n}\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(\n          feature(geometry, properties, { bbox, id }),\n          featureIndex,\n          0\n        ) === false)\n          return false;\n        return;\n    }\n    var geomType;\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)\n        return false;\n    }\n  });\n}\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function(currentFeature, featureIndex, multiFeatureIndex) {\n      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n    if (!feature2.geometry) return;\n    var type = feature2.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(\n      feature2,\n      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n          previousCoords = currentCoord;\n          previousFeatureIndex = featureIndex;\n          previousMultiIndex = multiPartIndexCoord;\n          prevGeomIndex = geometryIndex;\n          segmentIndex = 0;\n          return;\n        }\n        var currentSegment = lineString(\n          [previousCoords, currentCoord],\n          feature2.properties\n        );\n        if (callback(\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        ) === false)\n          return false;\n        segmentIndex++;\n        previousCoords = currentCoord;\n      }\n    ) === false)\n      return false;\n  });\n}\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n      if (started === false && initialValue === void 0)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\nfunction lineEach(geojson, callback) {\n  if (!geojson) throw new Error(\"geojson is required\");\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    if (feature2.geometry === null) return;\n    var type = feature2.geometry.type;\n    var coords = feature2.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(\n            lineString(coords[geometryIndex], feature2.properties),\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n        }\n        break;\n    }\n  });\n}\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction findSegment(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nfunction findPoint(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nexport {\n  coordAll,\n  coordEach,\n  coordReduce,\n  featureEach,\n  featureReduce,\n  findPoint,\n  findSegment,\n  flattenEach,\n  flattenReduce,\n  geomEach,\n  geomReduce,\n  lineEach,\n  lineReduce,\n  propEach,\n  propReduce,\n  segmentEach,\n  segmentReduce\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { coordEach } from \"@turf/meta\";\nfunction bbox(geojson, options = {}) {\n  if (geojson.bbox != null && true !== options.recompute) {\n    return geojson.bbox;\n  }\n  const result = [Infinity, Infinity, -Infinity, -Infinity];\n  coordEach(geojson, (coord) => {\n    if (result[0] > coord[0]) {\n      result[0] = coord[0];\n    }\n    if (result[1] > coord[1]) {\n      result[1] = coord[1];\n    }\n    if (result[2] < coord[0]) {\n      result[2] = coord[0];\n    }\n    if (result[3] < coord[1]) {\n      result[3] = coord[1];\n    }\n  });\n  return result;\n}\nvar turf_bbox_default = bbox;\nexport {\n  bbox,\n  turf_bbox_default as default\n};\n//# sourceMappingURL=index.js.map","// index.ts\nfunction clone(geojson) {\n  if (!geojson) {\n    throw new Error(\"geojson is required\");\n  }\n  switch (geojson.type) {\n    case \"Feature\":\n      return cloneFeature(geojson);\n    case \"FeatureCollection\":\n      return cloneFeatureCollection(geojson);\n    case \"Point\":\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiPoint\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n    case \"GeometryCollection\":\n      return cloneGeometry(geojson);\n    default:\n      throw new Error(\"unknown GeoJSON type\");\n  }\n}\nfunction cloneFeature(geojson) {\n  const cloned = { type: \"Feature\" };\n  Object.keys(geojson).forEach((key) => {\n    switch (key) {\n      case \"type\":\n      case \"properties\":\n      case \"geometry\":\n        return;\n      default:\n        cloned[key] = geojson[key];\n    }\n  });\n  cloned.properties = cloneProperties(geojson.properties);\n  if (geojson.geometry == null) {\n    cloned.geometry = null;\n  } else {\n    cloned.geometry = cloneGeometry(geojson.geometry);\n  }\n  return cloned;\n}\nfunction cloneProperties(properties) {\n  const cloned = {};\n  if (!properties) {\n    return cloned;\n  }\n  Object.keys(properties).forEach((key) => {\n    const value = properties[key];\n    if (typeof value === \"object\") {\n      if (value === null) {\n        cloned[key] = null;\n      } else if (Array.isArray(value)) {\n        cloned[key] = value.map((item) => {\n          return item;\n        });\n      } else {\n        cloned[key] = cloneProperties(value);\n      }\n    } else {\n      cloned[key] = value;\n    }\n  });\n  return cloned;\n}\nfunction cloneFeatureCollection(geojson) {\n  const cloned = { type: \"FeatureCollection\" };\n  Object.keys(geojson).forEach((key) => {\n    switch (key) {\n      case \"type\":\n      case \"features\":\n        return;\n      default:\n        cloned[key] = geojson[key];\n    }\n  });\n  cloned.features = geojson.features.map((feature) => {\n    return cloneFeature(feature);\n  });\n  return cloned;\n}\nfunction cloneGeometry(geometry) {\n  const geom = { type: geometry.type };\n  if (geometry.bbox) {\n    geom.bbox = geometry.bbox;\n  }\n  if (geometry.type === \"GeometryCollection\") {\n    geom.geometries = geometry.geometries.map((g) => {\n      return cloneGeometry(g);\n    });\n    return geom;\n  }\n  geom.coordinates = deepSlice(geometry.coordinates);\n  return geom;\n}\nfunction deepSlice(coords) {\n  const cloned = coords;\n  if (typeof cloned[0] !== \"object\") {\n    return cloned.slice();\n  }\n  return cloned.map((coord) => {\n    return deepSlice(coord);\n  });\n}\nvar turf_clone_default = clone;\nexport {\n  clone,\n  cloneProperties,\n  turf_clone_default as default\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { bbox as turfBBox } from \"@turf/bbox\";\nimport { getCoords, getGeom } from \"@turf/invariant\";\nimport { polygon, multiPolygon, lineString } from \"@turf/helpers\";\nimport { clone } from \"@turf/clone\";\nfunction lineToPolygon(lines, options = {}) {\n  var _a, _b, _c;\n  var properties = options.properties;\n  var autoComplete = (_a = options.autoComplete) != null ? _a : true;\n  var orderCoords = (_b = options.orderCoords) != null ? _b : true;\n  var mutate = (_c = options.mutate) != null ? _c : false;\n  if (!mutate) {\n    lines = clone(lines);\n  }\n  switch (lines.type) {\n    case \"FeatureCollection\":\n      var coords = [];\n      lines.features.forEach(function(line) {\n        coords.push(\n          getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords))\n        );\n      });\n      return multiPolygon(coords, properties);\n    default:\n      return lineStringToPolygon(lines, properties, autoComplete, orderCoords);\n  }\n}\nfunction lineStringToPolygon(line, properties, autoComplete, orderCoords) {\n  properties = properties ? properties : line.type === \"Feature\" ? line.properties : {};\n  var geom = getGeom(line);\n  var coords = geom.coordinates;\n  var type = geom.type;\n  if (!coords.length) throw new Error(\"line must contain coordinates\");\n  switch (type) {\n    case \"LineString\":\n      if (autoComplete) coords = autoCompleteCoords(coords);\n      return polygon([coords], properties);\n    case \"MultiLineString\":\n      var multiCoords = [];\n      var largestArea = 0;\n      coords.forEach(function(coord) {\n        if (autoComplete) coord = autoCompleteCoords(coord);\n        if (orderCoords) {\n          var area = calculateArea(turfBBox(lineString(coord)));\n          if (area > largestArea) {\n            multiCoords.unshift(coord);\n            largestArea = area;\n          } else multiCoords.push(coord);\n        } else {\n          multiCoords.push(coord);\n        }\n      });\n      return polygon(multiCoords, properties);\n    default:\n      throw new Error(\"geometry type \" + type + \" is not supported\");\n  }\n}\nfunction autoCompleteCoords(coords) {\n  var first = coords[0];\n  var x1 = first[0];\n  var y1 = first[1];\n  var last = coords[coords.length - 1];\n  var x2 = last[0];\n  var y2 = last[1];\n  if (x1 !== x2 || y1 !== y2) {\n    coords.push(first);\n  }\n  return coords;\n}\nfunction calculateArea(bbox) {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  return Math.abs(west - east) * Math.abs(south - north);\n}\nvar turf_line_to_polygon_default = lineToPolygon;\nexport {\n  turf_line_to_polygon_default as default,\n  lineToPolygon\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { isNumber } from \"@turf/helpers\";\nfunction getCoord(coord) {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n  if (!Array.isArray(coord)) {\n    if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\n      return [...coord.geometry.coordinates];\n    }\n    if (coord.type === \"Point\") {\n      return [...coord.coordinates];\n    }\n  }\n  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\n    return [...coord];\n  }\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\nfunction getCoords(coords) {\n  if (Array.isArray(coords)) {\n    return coords;\n  }\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n  throw new Error(\n    \"coords must be GeoJSON Feature, Geometry Object or an Array\"\n  );\n}\nfunction containsNumber(coordinates) {\n  if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n    return true;\n  }\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n  throw new Error(\"coordinates must only contain numbers\");\n}\nfunction geojsonType(value, type, name) {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n  if (!value || value.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type\n    );\n  }\n}\nfunction featureOf(feature, type, name) {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\n      \"Invalid input to \" + name + \", Feature with geometry required\"\n    );\n  }\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n    );\n  }\n}\nfunction collectionOf(featureCollection, type, name) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\n      \"Invalid input to \" + name + \", FeatureCollection required\"\n    );\n  }\n  for (const feature of featureCollection.features) {\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\n        \"Invalid input to \" + name + \", Feature with geometry required\"\n      );\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\n        \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n      );\n    }\n  }\n}\nfunction getGeom(geojson) {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n  return geojson;\n}\nfunction getType(geojson, _name) {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n  return geojson.type;\n}\nexport {\n  collectionOf,\n  containsNumber,\n  featureOf,\n  geojsonType,\n  getCoord,\n  getCoords,\n  getGeom,\n  getType\n};\n//# sourceMappingURL=index.js.map","/*\r\n *      bignumber.js v9.3.0\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\nvar\r\n  isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n  mathceil = Math.ceil,\r\n  mathfloor = Math.floor,\r\n\r\n  bignumberError = '[BigNumber Error] ',\r\n  tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n  BASE = 1e14,\r\n  LOG_BASE = 14,\r\n  MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n  // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n  POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n  SQRT_BASE = 1e7,\r\n\r\n  // EDITABLE\r\n  // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n  // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n  MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n/*\r\n * Create and return a BigNumber constructor.\r\n */\r\nfunction clone(configObject) {\r\n  var div, convertBase, parseNumeric,\r\n    P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n    ONE = new BigNumber(1),\r\n\r\n\r\n    //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n    // The default values below must be integers within the inclusive ranges stated.\r\n    // The values can also be changed at run-time using BigNumber.set.\r\n\r\n    // The maximum number of decimal places for operations involving division.\r\n    DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n    // The rounding mode used when rounding to the above decimal places, and when using\r\n    // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n    // UP         0 Away from zero.\r\n    // DOWN       1 Towards zero.\r\n    // CEIL       2 Towards +Infinity.\r\n    // FLOOR      3 Towards -Infinity.\r\n    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n    ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n    // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n    // The exponent value at and beneath which toString returns exponential notation.\r\n    // Number type: -7\r\n    TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n    // The exponent value at and above which toString returns exponential notation.\r\n    // Number type: 21\r\n    TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n    // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n    // The minimum exponent value, beneath which underflow to zero occurs.\r\n    // Number type: -324  (5e-324)\r\n    MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n    // The maximum exponent value, above which overflow to Infinity occurs.\r\n    // Number type:  308  (1.7976931348623157e+308)\r\n    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n    MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n    // Whether to use cryptographically-secure random number generation, if available.\r\n    CRYPTO = false,                          // true or false\r\n\r\n    // The modulo mode used when calculating the modulus: a mod n.\r\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n    // The remainder (r) is calculated as: r = a - n * q.\r\n    //\r\n    // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n    // DOWN      1 The remainder has the same sign as the dividend.\r\n    //             This modulo mode is commonly known as 'truncated division' and is\r\n    //             equivalent to (a % n) in JavaScript.\r\n    // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n    //             The remainder is always positive.\r\n    //\r\n    // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n    // modes are commonly used for the modulus operation.\r\n    // Although the other rounding modes can also be used, they may not give useful results.\r\n    MODULO_MODE = 1,                         // 0 to 9\r\n\r\n    // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n    // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n    POW_PRECISION = 0,                       // 0 to MAX\r\n\r\n    // The format specification used by the BigNumber.prototype.toFormat method.\r\n    FORMAT = {\r\n      prefix: '',\r\n      groupSize: 3,\r\n      secondaryGroupSize: 0,\r\n      groupSeparator: ',',\r\n      decimalSeparator: '.',\r\n      fractionGroupSize: 0,\r\n      fractionGroupSeparator: '\\xA0',        // non-breaking space\r\n      suffix: ''\r\n    },\r\n\r\n    // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n    // '-', '.', whitespace, or repeated character.\r\n    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n    ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',\r\n    alphabetHasNormalDecimalDigits = true;\r\n\r\n\r\n  //------------------------------------------------------------------------------------------\r\n\r\n\r\n  // CONSTRUCTOR\r\n\r\n\r\n  /*\r\n   * The BigNumber constructor and exported function.\r\n   * Create and return a new instance of a BigNumber object.\r\n   *\r\n   * v {number|string|BigNumber} A numeric value.\r\n   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n   */\r\n  function BigNumber(v, b) {\r\n    var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n      x = this;\r\n\r\n    // Enable constructor call without `new`.\r\n    if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n    if (b == null) {\r\n\r\n      if (v && v._isBigNumber === true) {\r\n        x.s = v.s;\r\n\r\n        if (!v.c || v.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n        } else if (v.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = v.e;\r\n          x.c = v.c.slice();\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n        // Use `1 / n` to handle minus zero also.\r\n        x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n        // Fast path for integers, where n < 2147483648 (2**31).\r\n        if (v === ~~v) {\r\n          for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n          if (e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else {\r\n            x.e = e;\r\n            x.c = [v];\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        str = String(v);\r\n      } else {\r\n\r\n        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n      }\r\n\r\n      // Decimal point?\r\n      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n      // Exponential form?\r\n      if ((i = str.search(/e/i)) > 0) {\r\n\r\n        // Determine exponent.\r\n        if (e < 0) e = i;\r\n        e += +str.slice(i + 1);\r\n        str = str.substring(0, i);\r\n      } else if (e < 0) {\r\n\r\n        // Integer.\r\n        e = str.length;\r\n      }\r\n\r\n    } else {\r\n\r\n      // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n      intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n      // Allow exponential notation to be used with base 10 argument, while\r\n      // also rounding to DECIMAL_PLACES as with other bases.\r\n      if (b == 10 && alphabetHasNormalDecimalDigits) {\r\n        x = new BigNumber(v);\r\n        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n      }\r\n\r\n      str = String(v);\r\n\r\n      if (isNum = typeof v == 'number') {\r\n\r\n        // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n          throw Error\r\n           (tooManyDigits + v);\r\n        }\r\n      } else {\r\n        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n      }\r\n\r\n      alphabet = ALPHABET.slice(0, b);\r\n      e = i = 0;\r\n\r\n      // Check that str is a valid base b number.\r\n      // Don't use RegExp, so alphabet can contain special characters.\r\n      for (len = str.length; i < len; i++) {\r\n        if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n          if (c == '.') {\r\n\r\n            // If '.' is not the first character and it has not be found before.\r\n            if (i > e) {\r\n              e = len;\r\n              continue;\r\n            }\r\n          } else if (!caseChanged) {\r\n\r\n            // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n            if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n              caseChanged = true;\r\n              i = -1;\r\n              e = 0;\r\n              continue;\r\n            }\r\n          }\r\n\r\n          return parseNumeric(x, String(v), isNum, b);\r\n        }\r\n      }\r\n\r\n      // Prevent later check for length on converted number.\r\n      isNum = false;\r\n      str = convertBase(str, b, 10, x.s);\r\n\r\n      // Decimal point?\r\n      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n      else e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n    if (str = str.slice(i, ++len)) {\r\n      len -= i;\r\n\r\n      // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n      if (isNum && BigNumber.DEBUG &&\r\n        len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n          throw Error\r\n           (tooManyDigits + (x.s * v));\r\n      }\r\n\r\n       // Overflow?\r\n      if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        x.c = x.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      } else {\r\n        x.e = e;\r\n        x.c = [];\r\n\r\n        // Transform base\r\n\r\n        // e is the base 10 exponent.\r\n        // i is where to slice str to get the first element of the coefficient array.\r\n        i = (e + 1) % LOG_BASE;\r\n        if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n        if (i < len) {\r\n          if (i) x.c.push(+str.slice(0, i));\r\n\r\n          for (len -= LOG_BASE; i < len;) {\r\n            x.c.push(+str.slice(i, i += LOG_BASE));\r\n          }\r\n\r\n          i = LOG_BASE - (str = str.slice(i)).length;\r\n        } else {\r\n          i -= len;\r\n        }\r\n\r\n        for (; i--; str += '0');\r\n        x.c.push(+str);\r\n      }\r\n    } else {\r\n\r\n      // Zero.\r\n      x.c = [x.e = 0];\r\n    }\r\n  }\r\n\r\n\r\n  // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n  BigNumber.clone = clone;\r\n\r\n  BigNumber.ROUND_UP = 0;\r\n  BigNumber.ROUND_DOWN = 1;\r\n  BigNumber.ROUND_CEIL = 2;\r\n  BigNumber.ROUND_FLOOR = 3;\r\n  BigNumber.ROUND_HALF_UP = 4;\r\n  BigNumber.ROUND_HALF_DOWN = 5;\r\n  BigNumber.ROUND_HALF_EVEN = 6;\r\n  BigNumber.ROUND_HALF_CEIL = 7;\r\n  BigNumber.ROUND_HALF_FLOOR = 8;\r\n  BigNumber.EUCLID = 9;\r\n\r\n\r\n  /*\r\n   * Configure infrequently-changing library-wide settings.\r\n   *\r\n   * Accept an object with the following optional properties (if the value of a property is\r\n   * a number, it must be an integer within the inclusive range stated):\r\n   *\r\n   *   DECIMAL_PLACES   {number}           0 to MAX\r\n   *   ROUNDING_MODE    {number}           0 to 8\r\n   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n   *   CRYPTO           {boolean}          true or false\r\n   *   MODULO_MODE      {number}           0 to 9\r\n   *   POW_PRECISION       {number}           0 to MAX\r\n   *   ALPHABET         {string}           A string of two or more unique characters which does\r\n   *                                       not contain '.'.\r\n   *   FORMAT           {object}           An object with some of the following properties:\r\n   *     prefix                 {string}\r\n   *     groupSize              {number}\r\n   *     secondaryGroupSize     {number}\r\n   *     groupSeparator         {string}\r\n   *     decimalSeparator       {string}\r\n   *     fractionGroupSize      {number}\r\n   *     fractionGroupSeparator {string}\r\n   *     suffix                 {string}\r\n   *\r\n   * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n   *\r\n   * E.g.\r\n   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n   *\r\n   * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n   *\r\n   * Return an object with the properties current values.\r\n   */\r\n  BigNumber.config = BigNumber.set = function (obj) {\r\n    var p, v;\r\n\r\n    if (obj != null) {\r\n\r\n      if (typeof obj == 'object') {\r\n\r\n        // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n        // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, MAX, p);\r\n          DECIMAL_PLACES = v;\r\n        }\r\n\r\n        // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n        // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, 8, p);\r\n          ROUNDING_MODE = v;\r\n        }\r\n\r\n        // EXPONENTIAL_AT {number|number[]}\r\n        // Integer, -MAX to MAX inclusive or\r\n        // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n        // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n          v = obj[p];\r\n          if (v && v.pop) {\r\n            intCheck(v[0], -MAX, 0, p);\r\n            intCheck(v[1], 0, MAX, p);\r\n            TO_EXP_NEG = v[0];\r\n            TO_EXP_POS = v[1];\r\n          } else {\r\n            intCheck(v, -MAX, MAX, p);\r\n            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n          }\r\n        }\r\n\r\n        // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n        // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n        // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n        if (obj.hasOwnProperty(p = 'RANGE')) {\r\n          v = obj[p];\r\n          if (v && v.pop) {\r\n            intCheck(v[0], -MAX, -1, p);\r\n            intCheck(v[1], 1, MAX, p);\r\n            MIN_EXP = v[0];\r\n            MAX_EXP = v[1];\r\n          } else {\r\n            intCheck(v, -MAX, MAX, p);\r\n            if (v) {\r\n              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' cannot be zero: ' + v);\r\n            }\r\n          }\r\n        }\r\n\r\n        // CRYPTO {boolean} true or false.\r\n        // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n        // '[BigNumber Error] crypto unavailable'\r\n        if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n          v = obj[p];\r\n          if (v === !!v) {\r\n            if (v) {\r\n              if (typeof crypto != 'undefined' && crypto &&\r\n               (crypto.getRandomValues || crypto.randomBytes)) {\r\n                CRYPTO = v;\r\n              } else {\r\n                CRYPTO = !v;\r\n                throw Error\r\n                 (bignumberError + 'crypto unavailable');\r\n              }\r\n            } else {\r\n              CRYPTO = v;\r\n            }\r\n          } else {\r\n            throw Error\r\n             (bignumberError + p + ' not true or false: ' + v);\r\n          }\r\n        }\r\n\r\n        // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n        // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, 9, p);\r\n          MODULO_MODE = v;\r\n        }\r\n\r\n        // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n        // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, MAX, p);\r\n          POW_PRECISION = v;\r\n        }\r\n\r\n        // FORMAT {object}\r\n        // '[BigNumber Error] FORMAT not an object: {v}'\r\n        if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n          v = obj[p];\r\n          if (typeof v == 'object') FORMAT = v;\r\n          else throw Error\r\n           (bignumberError + p + ' not an object: ' + v);\r\n        }\r\n\r\n        // ALPHABET {string}\r\n        // '[BigNumber Error] ALPHABET invalid: {v}'\r\n        if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n          v = obj[p];\r\n\r\n          // Disallow if less than two characters,\r\n          // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n          if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n            alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';\r\n            ALPHABET = v;\r\n          } else {\r\n            throw Error\r\n             (bignumberError + p + ' invalid: ' + v);\r\n          }\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Object expected: {v}'\r\n        throw Error\r\n         (bignumberError + 'Object expected: ' + obj);\r\n      }\r\n    }\r\n\r\n    return {\r\n      DECIMAL_PLACES: DECIMAL_PLACES,\r\n      ROUNDING_MODE: ROUNDING_MODE,\r\n      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n      RANGE: [MIN_EXP, MAX_EXP],\r\n      CRYPTO: CRYPTO,\r\n      MODULO_MODE: MODULO_MODE,\r\n      POW_PRECISION: POW_PRECISION,\r\n      FORMAT: FORMAT,\r\n      ALPHABET: ALPHABET\r\n    };\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if v is a BigNumber instance, otherwise return false.\r\n   *\r\n   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n   *\r\n   * v {any}\r\n   *\r\n   * '[BigNumber Error] Invalid BigNumber: {v}'\r\n   */\r\n  BigNumber.isBigNumber = function (v) {\r\n    if (!v || v._isBigNumber !== true) return false;\r\n    if (!BigNumber.DEBUG) return true;\r\n\r\n    var i, n,\r\n      c = v.c,\r\n      e = v.e,\r\n      s = v.s;\r\n\r\n    out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n        // If the first element is zero, the BigNumber value must be zero.\r\n        if (c[0] === 0) {\r\n          if (e === 0 && c.length === 1) return true;\r\n          break out;\r\n        }\r\n\r\n        // Calculate number of digits that c[0] should have, based on the exponent.\r\n        i = (e + 1) % LOG_BASE;\r\n        if (i < 1) i += LOG_BASE;\r\n\r\n        // Calculate number of digits of c[0].\r\n        //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n        if (String(c[0]).length == i) {\r\n\r\n          for (i = 0; i < c.length; i++) {\r\n            n = c[i];\r\n            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n          }\r\n\r\n          // Last element cannot be zero, unless it is the only element.\r\n          if (n !== 0) return true;\r\n        }\r\n      }\r\n\r\n    // Infinity/NaN\r\n    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n      return true;\r\n    }\r\n\r\n    throw Error\r\n      (bignumberError + 'Invalid BigNumber: ' + v);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.maximum = BigNumber.max = function () {\r\n    return maxOrMin(arguments, -1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.minimum = BigNumber.min = function () {\r\n    return maxOrMin(arguments, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n   * zeros are produced).\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n   * '[BigNumber Error] crypto unavailable'\r\n   */\r\n  BigNumber.random = (function () {\r\n    var pow2_53 = 0x20000000000000;\r\n\r\n    // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n    // Check if Math.random() produces more than 32 bits of randomness.\r\n    // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n    // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n    var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n     ? function () { return mathfloor(Math.random() * pow2_53); }\r\n     : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n       (Math.random() * 0x800000 | 0); };\r\n\r\n    return function (dp) {\r\n      var a, b, e, k, v,\r\n        i = 0,\r\n        c = [],\r\n        rand = new BigNumber(ONE);\r\n\r\n      if (dp == null) dp = DECIMAL_PLACES;\r\n      else intCheck(dp, 0, MAX);\r\n\r\n      k = mathceil(dp / LOG_BASE);\r\n\r\n      if (CRYPTO) {\r\n\r\n        // Browsers supporting crypto.getRandomValues.\r\n        if (crypto.getRandomValues) {\r\n\r\n          a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n          for (; i < k;) {\r\n\r\n            // 53 bits:\r\n            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n            // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n            //                                     11111 11111111 11111111\r\n            // 0x20000 is 2^21.\r\n            v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n            // Rejection sampling:\r\n            // 0 <= v < 9007199254740992\r\n            // Probability that v >= 9e15, is\r\n            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n            if (v >= 9e15) {\r\n              b = crypto.getRandomValues(new Uint32Array(2));\r\n              a[i] = b[0];\r\n              a[i + 1] = b[1];\r\n            } else {\r\n\r\n              // 0 <= v <= 8999999999999999\r\n              // 0 <= (v % 1e14) <= 99999999999999\r\n              c.push(v % 1e14);\r\n              i += 2;\r\n            }\r\n          }\r\n          i = k / 2;\r\n\r\n        // Node.js supporting crypto.randomBytes.\r\n        } else if (crypto.randomBytes) {\r\n\r\n          // buffer\r\n          a = crypto.randomBytes(k *= 7);\r\n\r\n          for (; i < k;) {\r\n\r\n            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n            // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n            // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n            // 0 <= v < 9007199254740992\r\n            v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n               (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n               (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n            if (v >= 9e15) {\r\n              crypto.randomBytes(7).copy(a, i);\r\n            } else {\r\n\r\n              // 0 <= (v % 1e14) <= 99999999999999\r\n              c.push(v % 1e14);\r\n              i += 7;\r\n            }\r\n          }\r\n          i = k / 7;\r\n        } else {\r\n          CRYPTO = false;\r\n          throw Error\r\n           (bignumberError + 'crypto unavailable');\r\n        }\r\n      }\r\n\r\n      // Use Math.random.\r\n      if (!CRYPTO) {\r\n\r\n        for (; i < k;) {\r\n          v = random53bitInt();\r\n          if (v < 9e15) c[i++] = v % 1e14;\r\n        }\r\n      }\r\n\r\n      k = c[--i];\r\n      dp %= LOG_BASE;\r\n\r\n      // Convert trailing digits to zeros according to dp.\r\n      if (k && dp) {\r\n        v = POWS_TEN[LOG_BASE - dp];\r\n        c[i] = mathfloor(k / v) * v;\r\n      }\r\n\r\n      // Remove trailing elements which are zero.\r\n      for (; c[i] === 0; c.pop(), i--);\r\n\r\n      // Zero?\r\n      if (i < 0) {\r\n        c = [e = 0];\r\n      } else {\r\n\r\n        // Remove leading elements which are zero and adjust exponent accordingly.\r\n        for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n        // Count the digits of the first element of c to determine leading zeros, and...\r\n        for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n        // adjust the exponent accordingly.\r\n        if (i < LOG_BASE) e -= LOG_BASE - i;\r\n      }\r\n\r\n      rand.e = e;\r\n      rand.c = c;\r\n      return rand;\r\n    };\r\n  })();\r\n\r\n\r\n   /*\r\n   * Return a BigNumber whose value is the sum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.sum = function () {\r\n    var i = 1,\r\n      args = arguments,\r\n      sum = new BigNumber(args[0]);\r\n    for (; i < args.length;) sum = sum.plus(args[i++]);\r\n    return sum;\r\n  };\r\n\r\n\r\n  // PRIVATE FUNCTIONS\r\n\r\n\r\n  // Called by BigNumber and BigNumber.prototype.toString.\r\n  convertBase = (function () {\r\n    var decimal = '0123456789';\r\n\r\n    /*\r\n     * Convert string of baseIn to an array of numbers of baseOut.\r\n     * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n     */\r\n    function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n      var j,\r\n        arr = [0],\r\n        arrL,\r\n        i = 0,\r\n        len = str.length;\r\n\r\n      for (; i < len;) {\r\n        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n        arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n        for (j = 0; j < arr.length; j++) {\r\n\r\n          if (arr[j] > baseOut - 1) {\r\n            if (arr[j + 1] == null) arr[j + 1] = 0;\r\n            arr[j + 1] += arr[j] / baseOut | 0;\r\n            arr[j] %= baseOut;\r\n          }\r\n        }\r\n      }\r\n\r\n      return arr.reverse();\r\n    }\r\n\r\n    // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n    // If the caller is toString, we are converting from base 10 to baseOut.\r\n    // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n    return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n      var alphabet, d, e, k, r, x, xc, y,\r\n        i = str.indexOf('.'),\r\n        dp = DECIMAL_PLACES,\r\n        rm = ROUNDING_MODE;\r\n\r\n      // Non-integer.\r\n      if (i >= 0) {\r\n        k = POW_PRECISION;\r\n\r\n        // Unlimited precision.\r\n        POW_PRECISION = 0;\r\n        str = str.replace('.', '');\r\n        y = new BigNumber(baseIn);\r\n        x = y.pow(str.length - i);\r\n        POW_PRECISION = k;\r\n\r\n        // Convert str as if an integer, then restore the fraction part by dividing the\r\n        // result by its base raised to a power.\r\n\r\n        y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n         10, baseOut, decimal);\r\n        y.e = y.c.length;\r\n      }\r\n\r\n      // Convert the number as integer.\r\n\r\n      xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n       ? (alphabet = ALPHABET, decimal)\r\n       : (alphabet = decimal, ALPHABET));\r\n\r\n      // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n      e = k = xc.length;\r\n\r\n      // Remove trailing zeros.\r\n      for (; xc[--k] == 0; xc.pop());\r\n\r\n      // Zero?\r\n      if (!xc[0]) return alphabet.charAt(0);\r\n\r\n      // Does str represent an integer? If so, no need for the division.\r\n      if (i < 0) {\r\n        --e;\r\n      } else {\r\n        x.c = xc;\r\n        x.e = e;\r\n\r\n        // The sign is needed for correct rounding.\r\n        x.s = sign;\r\n        x = div(x, y, dp, rm, baseOut);\r\n        xc = x.c;\r\n        r = x.r;\r\n        e = x.e;\r\n      }\r\n\r\n      // xc now represents str converted to baseOut.\r\n\r\n      // The index of the rounding digit.\r\n      d = e + dp + 1;\r\n\r\n      // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n      i = xc[d];\r\n\r\n      // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n      k = baseOut / 2;\r\n      r = r || d < 0 || xc[d + 1] != null;\r\n\r\n      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n            : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n      // If the index of the rounding digit is not greater than zero, or xc represents\r\n      // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n      // such as 0.00001.\r\n      if (d < 1 || !xc[0]) {\r\n\r\n        // 1^-dp or 0\r\n        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n      } else {\r\n\r\n        // Truncate xc to the required number of decimal places.\r\n        xc.length = d;\r\n\r\n        // Round up?\r\n        if (r) {\r\n\r\n          // Rounding up may mean the previous digit has to be rounded up and so on.\r\n          for (--baseOut; ++xc[--d] > baseOut;) {\r\n            xc[d] = 0;\r\n\r\n            if (!d) {\r\n              ++e;\r\n              xc = [1].concat(xc);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Determine trailing zeros.\r\n        for (k = xc.length; !xc[--k];);\r\n\r\n        // E.g. [4, 11, 15] becomes 4bf.\r\n        for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n        // Add leading zeros, decimal point and trailing zeros as required.\r\n        str = toFixedPoint(str, e, alphabet.charAt(0));\r\n      }\r\n\r\n      // The caller will add the sign.\r\n      return str;\r\n    };\r\n  })();\r\n\r\n\r\n  // Perform division in the specified base. Called by div and convertBase.\r\n  div = (function () {\r\n\r\n    // Assume non-zero x and k.\r\n    function multiply(x, k, base) {\r\n      var m, temp, xlo, xhi,\r\n        carry = 0,\r\n        i = x.length,\r\n        klo = k % SQRT_BASE,\r\n        khi = k / SQRT_BASE | 0;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        xlo = x[i] % SQRT_BASE;\r\n        xhi = x[i] / SQRT_BASE | 0;\r\n        m = khi * xlo + xhi * klo;\r\n        temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n        x[i] = temp % base;\r\n      }\r\n\r\n      if (carry) x = [carry].concat(x);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, cmp;\r\n\r\n      if (aL != bL) {\r\n        cmp = aL > bL ? 1 : -1;\r\n      } else {\r\n\r\n        for (i = cmp = 0; i < aL; i++) {\r\n\r\n          if (a[i] != b[i]) {\r\n            cmp = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return cmp;\r\n    }\r\n\r\n    function subtract(a, b, aL, base) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * base + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n    }\r\n\r\n    // x: dividend, y: divisor.\r\n    return function (x, y, dp, rm, base) {\r\n      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n        yL, yz,\r\n        s = x.s == y.s ? 1 : -1,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n        return new BigNumber(\r\n\r\n         // Return NaN if either NaN, or both Infinity or 0.\r\n         !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\r\n          xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n       );\r\n      }\r\n\r\n      q = new BigNumber(s);\r\n      qc = q.c = [];\r\n      e = x.e - y.e;\r\n      s = dp + e + 1;\r\n\r\n      if (!base) {\r\n        base = BASE;\r\n        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n        s = s / LOG_BASE | 0;\r\n      }\r\n\r\n      // Result exponent may be one less then the current value of e.\r\n      // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n      for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n      if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n      if (s < 0) {\r\n        qc.push(1);\r\n        more = true;\r\n      } else {\r\n        xL = xc.length;\r\n        yL = yc.length;\r\n        i = 0;\r\n        s += 2;\r\n\r\n        // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n        n = mathfloor(base / (yc[0] + 1));\r\n\r\n        // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n        // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n        if (n > 1) {\r\n          yc = multiply(yc, n, base);\r\n          xc = multiply(xc, n, base);\r\n          yL = yc.length;\r\n          xL = xc.length;\r\n        }\r\n\r\n        xi = yL;\r\n        rem = xc.slice(0, yL);\r\n        remL = rem.length;\r\n\r\n        // Add zeros to make remainder as long as divisor.\r\n        for (; remL < yL; rem[remL++] = 0);\r\n        yz = yc.slice();\r\n        yz = [0].concat(yz);\r\n        yc0 = yc[0];\r\n        if (yc[1] >= base / 2) yc0++;\r\n        // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n        // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n        do {\r\n          n = 0;\r\n\r\n          // Compare divisor and remainder.\r\n          cmp = compare(yc, rem, yL, remL);\r\n\r\n          // If divisor < remainder.\r\n          if (cmp < 0) {\r\n\r\n            // Calculate trial digit, n.\r\n\r\n            rem0 = rem[0];\r\n            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n            // n is how many times the divisor goes into the current remainder.\r\n            n = mathfloor(rem0 / yc0);\r\n\r\n            //  Algorithm:\r\n            //  product = divisor multiplied by trial digit (n).\r\n            //  Compare product and remainder.\r\n            //  If product is greater than remainder:\r\n            //    Subtract divisor from product, decrement trial digit.\r\n            //  Subtract product from remainder.\r\n            //  If product was less than remainder at the last compare:\r\n            //    Compare new remainder and divisor.\r\n            //    If remainder is greater than divisor:\r\n            //      Subtract divisor from remainder, increment trial digit.\r\n\r\n            if (n > 1) {\r\n\r\n              // n may be > base only when base is 3.\r\n              if (n >= base) n = base - 1;\r\n\r\n              // product = divisor * trial digit.\r\n              prod = multiply(yc, n, base);\r\n              prodL = prod.length;\r\n              remL = rem.length;\r\n\r\n              // Compare product and remainder.\r\n              // If product > remainder then trial digit n too high.\r\n              // n is 1 too high about 5% of the time, and is not known to have\r\n              // ever been more than 1 too high.\r\n              while (compare(prod, rem, prodL, remL) == 1) {\r\n                n--;\r\n\r\n                // Subtract divisor from product.\r\n                subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                prodL = prod.length;\r\n                cmp = 1;\r\n              }\r\n            } else {\r\n\r\n              // n is 0 or 1, cmp is -1.\r\n              // If n is 0, there is no need to compare yc and rem again below,\r\n              // so change cmp to 1 to avoid it.\r\n              // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n              if (n == 0) {\r\n\r\n                // divisor < remainder, so n must be at least 1.\r\n                cmp = n = 1;\r\n              }\r\n\r\n              // product = divisor\r\n              prod = yc.slice();\r\n              prodL = prod.length;\r\n            }\r\n\r\n            if (prodL < remL) prod = [0].concat(prod);\r\n\r\n            // Subtract product from remainder.\r\n            subtract(rem, prod, remL, base);\r\n            remL = rem.length;\r\n\r\n             // If product was < remainder.\r\n            if (cmp == -1) {\r\n\r\n              // Compare divisor and new remainder.\r\n              // If divisor < new remainder, subtract divisor from remainder.\r\n              // Trial digit n too low.\r\n              // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n              while (compare(yc, rem, yL, remL) < 1) {\r\n                n++;\r\n\r\n                // Subtract divisor from remainder.\r\n                subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                remL = rem.length;\r\n              }\r\n            }\r\n          } else if (cmp === 0) {\r\n            n++;\r\n            rem = [0];\r\n          } // else cmp === 1 and n will be 0\r\n\r\n          // Add the next digit, n, to the result array.\r\n          qc[i++] = n;\r\n\r\n          // Update the remainder.\r\n          if (rem[0]) {\r\n            rem[remL++] = xc[xi] || 0;\r\n          } else {\r\n            rem = [xc[xi]];\r\n            remL = 1;\r\n          }\r\n        } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n        more = rem[0] != null;\r\n\r\n        // Leading zero?\r\n        if (!qc[0]) qc.splice(0, 1);\r\n      }\r\n\r\n      if (base == BASE) {\r\n\r\n        // To calculate q.e, first get the number of digits of qc[0].\r\n        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n      // Caller is convertBase.\r\n      } else {\r\n        q.e = e;\r\n        q.r = +more;\r\n      }\r\n\r\n      return q;\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n   * notation rounded to the specified decimal places or significant digits.\r\n   *\r\n   * n: a BigNumber.\r\n   * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n   * rm: the rounding mode.\r\n   * id: 1 (toExponential) or 2 (toPrecision).\r\n   */\r\n  function format(n, i, rm, id) {\r\n    var c0, e, ne, len, str;\r\n\r\n    if (rm == null) rm = ROUNDING_MODE;\r\n    else intCheck(rm, 0, 8);\r\n\r\n    if (!n.c) return n.toString();\r\n\r\n    c0 = n.c[0];\r\n    ne = n.e;\r\n\r\n    if (i == null) {\r\n      str = coeffToString(n.c);\r\n      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n       ? toExponential(str, ne)\r\n       : toFixedPoint(str, ne, '0');\r\n    } else {\r\n      n = round(new BigNumber(n), i, rm);\r\n\r\n      // n.e may have changed if the value was rounded up.\r\n      e = n.e;\r\n\r\n      str = coeffToString(n.c);\r\n      len = str.length;\r\n\r\n      // toPrecision returns exponential notation if the number of significant digits\r\n      // specified is less than the number of digits necessary to represent the integer\r\n      // part of the value in fixed-point notation.\r\n\r\n      // Exponential notation.\r\n      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n        // Append zeros?\r\n        for (; len < i; str += '0', len++);\r\n        str = toExponential(str, e);\r\n\r\n      // Fixed-point notation.\r\n      } else {\r\n        i -= ne;\r\n        str = toFixedPoint(str, e, '0');\r\n\r\n        // Append zeros?\r\n        if (e + 1 > len) {\r\n          if (--i > 0) for (str += '.'; i--; str += '0');\r\n        } else {\r\n          i += e - len;\r\n          if (i > 0) {\r\n            if (e + 1 == len) str += '.';\r\n            for (; i--; str += '0');\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return n.s < 0 && c0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Handle BigNumber.max and BigNumber.min.\r\n  // If any number is NaN, return NaN.\r\n  function maxOrMin(args, n) {\r\n    var k, y,\r\n      i = 1,\r\n      x = new BigNumber(args[0]);\r\n\r\n    for (; i < args.length; i++) {\r\n      y = new BigNumber(args[i]);\r\n      if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {\r\n        x = y;\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n   * Called by minus, plus and times.\r\n   */\r\n  function normalise(n, c, e) {\r\n    var i = 1,\r\n      j = c.length;\r\n\r\n     // Remove trailing zeros.\r\n    for (; !c[--j]; c.pop());\r\n\r\n    // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n    for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n    // Overflow?\r\n    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n      // Infinity.\r\n      n.c = n.e = null;\r\n\r\n    // Underflow?\r\n    } else if (e < MIN_EXP) {\r\n\r\n      // Zero.\r\n      n.c = [n.e = 0];\r\n    } else {\r\n      n.e = e;\r\n      n.c = c;\r\n    }\r\n\r\n    return n;\r\n  }\r\n\r\n\r\n  // Handle values that fail the validity test in BigNumber.\r\n  parseNumeric = (function () {\r\n    var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n      dotAfter = /^([^.]+)\\.$/,\r\n      dotBefore = /^\\.([^.]+)$/,\r\n      isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n      whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n    return function (x, str, isNum, b) {\r\n      var base,\r\n        s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n      // No exception on Infinity or NaN.\r\n      if (isInfinityOrNaN.test(s)) {\r\n        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n      } else {\r\n        if (!isNum) {\r\n\r\n          // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n          s = s.replace(basePrefix, function (m, p1, p2) {\r\n            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n            return !b || b == base ? p1 : m;\r\n          });\r\n\r\n          if (b) {\r\n            base = b;\r\n\r\n            // E.g. '1.' to '1', '.1' to '0.1'\r\n            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n          }\r\n\r\n          if (str != s) return new BigNumber(s, base);\r\n        }\r\n\r\n        // '[BigNumber Error] Not a number: {n}'\r\n        // '[BigNumber Error] Not a base {b} number: {n}'\r\n        if (BigNumber.DEBUG) {\r\n          throw Error\r\n            (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n        }\r\n\r\n        // NaN\r\n        x.s = null;\r\n      }\r\n\r\n      x.c = x.e = null;\r\n    }\r\n  })();\r\n\r\n\r\n  /*\r\n   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n   * If r is truthy, it is known that there are more digits after the rounding digit.\r\n   */\r\n  function round(x, sd, rm, r) {\r\n    var d, i, j, k, n, ni, rd,\r\n      xc = x.c,\r\n      pows10 = POWS_TEN;\r\n\r\n    // if x is not Infinity or NaN...\r\n    if (xc) {\r\n\r\n      // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n      // ni is the index of n within x.c.\r\n      // d is the number of digits of n.\r\n      // i is the index of rd within n including leading zeros.\r\n      // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n      out: {\r\n\r\n        // Get the number of digits of the first element of xc.\r\n        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n        i = sd - d;\r\n\r\n        // If the rounding digit is in the first element of xc...\r\n        if (i < 0) {\r\n          i += LOG_BASE;\r\n          j = sd;\r\n          n = xc[ni = 0];\r\n\r\n          // Get the rounding digit at index j of n.\r\n          rd = mathfloor(n / pows10[d - j - 1] % 10);\r\n        } else {\r\n          ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n          if (ni >= xc.length) {\r\n\r\n            if (r) {\r\n\r\n              // Needed by sqrt.\r\n              for (; xc.length <= ni; xc.push(0));\r\n              n = rd = 0;\r\n              d = 1;\r\n              i %= LOG_BASE;\r\n              j = i - LOG_BASE + 1;\r\n            } else {\r\n              break out;\r\n            }\r\n          } else {\r\n            n = k = xc[ni];\r\n\r\n            // Get the number of digits of n.\r\n            for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n            // Get the index of rd within n.\r\n            i %= LOG_BASE;\r\n\r\n            // Get the index of rd within n, adjusted for leading zeros.\r\n            // The number of leading zeros of n is given by LOG_BASE - d.\r\n            j = i - LOG_BASE + d;\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);\r\n          }\r\n        }\r\n\r\n        r = r || sd < 0 ||\r\n\r\n        // Are there any non-zero digits after the rounding digit?\r\n        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n         xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n        r = rm < 4\r\n         ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n         : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n           rm == (x.s < 0 ? 8 : 7));\r\n\r\n        if (sd < 1 || !xc[0]) {\r\n          xc.length = 0;\r\n\r\n          if (r) {\r\n\r\n            // Convert sd to decimal places.\r\n            sd -= x.e + 1;\r\n\r\n            // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n            x.e = -sd || 0;\r\n          } else {\r\n\r\n            // Zero.\r\n            xc[0] = x.e = 0;\r\n          }\r\n\r\n          return x;\r\n        }\r\n\r\n        // Remove excess digits.\r\n        if (i == 0) {\r\n          xc.length = ni;\r\n          k = 1;\r\n          ni--;\r\n        } else {\r\n          xc.length = ni + 1;\r\n          k = pows10[LOG_BASE - i];\r\n\r\n          // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n          // j > 0 means i > number of leading zeros of n.\r\n          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n        }\r\n\r\n        // Round up?\r\n        if (r) {\r\n\r\n          for (; ;) {\r\n\r\n            // If the digit to be rounded up is in the first element of xc...\r\n            if (ni == 0) {\r\n\r\n              // i will be the length of xc[0] before k is added.\r\n              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n              j = xc[0] += k;\r\n              for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n              // if i != k the length has increased.\r\n              if (i != k) {\r\n                x.e++;\r\n                if (xc[0] == BASE) xc[0] = 1;\r\n              }\r\n\r\n              break;\r\n            } else {\r\n              xc[ni] += k;\r\n              if (xc[ni] != BASE) break;\r\n              xc[ni--] = 0;\r\n              k = 1;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Remove trailing zeros.\r\n        for (i = xc.length; xc[--i] === 0; xc.pop());\r\n      }\r\n\r\n      // Overflow? Infinity.\r\n      if (x.e > MAX_EXP) {\r\n        x.c = x.e = null;\r\n\r\n      // Underflow? Zero.\r\n      } else if (x.e < MIN_EXP) {\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function valueOf(n) {\r\n    var str,\r\n      e = n.e;\r\n\r\n    if (e === null) return n.toString();\r\n\r\n    str = coeffToString(n.c);\r\n\r\n    str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n      ? toExponential(str, e)\r\n      : toFixedPoint(str, e, '0');\r\n\r\n    return n.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new BigNumber(this);\r\n    if (x.s < 0) x.s = 1;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   *   0 if they have the same value,\r\n   *   or null if the value of either is NaN.\r\n   */\r\n  P.comparedTo = function (y, b) {\r\n    return compare(this, new BigNumber(y, b));\r\n  };\r\n\r\n\r\n  /*\r\n   * If dp is undefined or null or true or false, return the number of decimal places of the\r\n   * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n   *\r\n   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.decimalPlaces = P.dp = function (dp, rm) {\r\n    var c, n, v,\r\n      x = this;\r\n\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      return round(new BigNumber(x), dp + x.e + 1, rm);\r\n    }\r\n\r\n    if (!(c = x.c)) return null;\r\n    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n    // Subtract the number of trailing zeros of the last number.\r\n    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n    if (n < 0) n = 0;\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */\r\n  P.dividedBy = P.div = function (y, b) {\r\n    return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n   * BigNumber by the value of BigNumber(y, b).\r\n   */\r\n  P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n    return div(this, new BigNumber(y, b), 0, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n   *\r\n   * If m is present, return the result modulo m.\r\n   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n   *\r\n   * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n   *\r\n   * n {number|string|BigNumber} The exponent. An integer.\r\n   * [m] {number|string|BigNumber} The modulus.\r\n   *\r\n   * '[BigNumber Error] Exponent not an integer: {n}'\r\n   */\r\n  P.exponentiatedBy = P.pow = function (n, m) {\r\n    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n      x = this;\r\n\r\n    n = new BigNumber(n);\r\n\r\n    // Allow NaN and Infinity, but not other non-integers.\r\n    if (n.c && !n.isInteger()) {\r\n      throw Error\r\n        (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n    }\r\n\r\n    if (m != null) m = new BigNumber(m);\r\n\r\n    // Exponent of MAX_SAFE_INTEGER is 15.\r\n    nIsBig = n.e > 14;\r\n\r\n    // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.\r\n    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n      // The sign of the result of pow when x is negative depends on the evenness of n.\r\n      // If +n overflows to Infinity, the evenness of n would be not be known.\r\n      y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));\r\n      return m ? y.mod(m) : y;\r\n    }\r\n\r\n    nIsNeg = n.s < 0;\r\n\r\n    if (m) {\r\n\r\n      // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n      if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n      isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n      if (isModExp) x = x.mod(m);\r\n\r\n    // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n    // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.\r\n    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n      // [1, 240000000]\r\n      ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n      // [80000000000000]  [99999750000000]\r\n      : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n      // If x is negative and n is odd, k = -0, else k = 0.\r\n      k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n      // If x >= 1, k = Infinity.\r\n      if (x.e > -1) k = 1 / k;\r\n\r\n      // If n is negative return 0, else return Infinity.\r\n      return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n    } else if (POW_PRECISION) {\r\n\r\n      // Truncating each coefficient array to a length of k after each multiplication\r\n      // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n      // i.e. there will be a minimum of 28 guard digits retained.\r\n      k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n    }\r\n\r\n    if (nIsBig) {\r\n      half = new BigNumber(0.5);\r\n      if (nIsNeg) n.s = 1;\r\n      nIsOdd = isOdd(n);\r\n    } else {\r\n      i = Math.abs(+valueOf(n));\r\n      nIsOdd = i % 2;\r\n    }\r\n\r\n    y = new BigNumber(ONE);\r\n\r\n    // Performs 54 loop iterations for n of 9007199254740991.\r\n    for (; ;) {\r\n\r\n      if (nIsOdd) {\r\n        y = y.times(x);\r\n        if (!y.c) break;\r\n\r\n        if (k) {\r\n          if (y.c.length > k) y.c.length = k;\r\n        } else if (isModExp) {\r\n          y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (i) {\r\n        i = mathfloor(i / 2);\r\n        if (i === 0) break;\r\n        nIsOdd = i % 2;\r\n      } else {\r\n        n = n.times(half);\r\n        round(n, n.e + 1, 1);\r\n\r\n        if (n.e > 14) {\r\n          nIsOdd = isOdd(n);\r\n        } else {\r\n          i = +valueOf(n);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        }\r\n      }\r\n\r\n      x = x.times(x);\r\n\r\n      if (k) {\r\n        if (x.c && x.c.length > k) x.c.length = k;\r\n      } else if (isModExp) {\r\n        x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n      }\r\n    }\r\n\r\n    if (isModExp) return y;\r\n    if (nIsNeg) y = ONE.div(y);\r\n\r\n    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n   */\r\n  P.integerValue = function (rm) {\r\n    var n = new BigNumber(this);\r\n    if (rm == null) rm = ROUNDING_MODE;\r\n    else intCheck(rm, 0, 8);\r\n    return round(n, n.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isEqualTo = P.eq = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n   */\r\n  P.isFinite = function () {\r\n    return !!this.c;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isGreaterThan = P.gt = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is greater than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */\r\n  P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n    return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n   */\r\n  P.isInteger = function () {\r\n    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isLessThan = P.lt = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is less than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */\r\n  P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n    return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n   */\r\n  P.isNaN = function () {\r\n    return !this.s;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is negative, otherwise return false.\r\n   */\r\n  P.isNegative = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is positive, otherwise return false.\r\n   */\r\n  P.isPositive = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n   */\r\n  P.isZero = function () {\r\n    return !!this.c && this.c[0] == 0;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n   * BigNumber(y, b).\r\n   */\r\n  P.minus = function (y, b) {\r\n    var i, j, t, xLTy,\r\n      x = this,\r\n      a = x.s;\r\n\r\n    y = new BigNumber(y, b);\r\n    b = y.s;\r\n\r\n    // Either NaN?\r\n    if (!a || !b) return new BigNumber(NaN);\r\n\r\n    // Signs differ?\r\n    if (a != b) {\r\n      y.s = -b;\r\n      return x.plus(y);\r\n    }\r\n\r\n    var xe = x.e / LOG_BASE,\r\n      ye = y.e / LOG_BASE,\r\n      xc = x.c,\r\n      yc = y.c;\r\n\r\n    if (!xe || !ye) {\r\n\r\n      // Either Infinity?\r\n      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n      // Either zero?\r\n      if (!xc[0] || !yc[0]) {\r\n\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n         // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n         ROUNDING_MODE == 3 ? -0 : 0);\r\n      }\r\n    }\r\n\r\n    xe = bitFloor(xe);\r\n    ye = bitFloor(ye);\r\n    xc = xc.slice();\r\n\r\n    // Determine which is the bigger number.\r\n    if (a = xe - ye) {\r\n\r\n      if (xLTy = a < 0) {\r\n        a = -a;\r\n        t = xc;\r\n      } else {\r\n        ye = xe;\r\n        t = yc;\r\n      }\r\n\r\n      t.reverse();\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      for (b = a; b--; t.push(0));\r\n      t.reverse();\r\n    } else {\r\n\r\n      // Exponents equal. Check digit by digit.\r\n      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n      for (a = b = 0; b < j; b++) {\r\n\r\n        if (xc[b] != yc[b]) {\r\n          xLTy = xc[b] < yc[b];\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // x < y? Point xc to the array of the bigger number.\r\n    if (xLTy) {\r\n      t = xc;\r\n      xc = yc;\r\n      yc = t;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    b = (j = yc.length) - (i = xc.length);\r\n\r\n    // Append zeros to xc if shorter.\r\n    // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n    if (b > 0) for (; b--; xc[i++] = 0);\r\n    b = BASE - 1;\r\n\r\n    // Subtract yc from xc.\r\n    for (; j > a;) {\r\n\r\n      if (xc[--j] < yc[j]) {\r\n        for (i = j; i && !xc[--i]; xc[i] = b);\r\n        --xc[i];\r\n        xc[j] += BASE;\r\n      }\r\n\r\n      xc[j] -= yc[j];\r\n    }\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n    // Zero?\r\n    if (!xc[0]) {\r\n\r\n      // Following IEEE 754 (2008) 6.3,\r\n      // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n      y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n      y.c = [y.e = 0];\r\n      return y;\r\n    }\r\n\r\n    // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n    // for finite x and y.\r\n    return normalise(y, xc, ye);\r\n  };\r\n\r\n\r\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n   * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n   */\r\n  P.modulo = P.mod = function (y, b) {\r\n    var q, s,\r\n      x = this;\r\n\r\n    y = new BigNumber(y, b);\r\n\r\n    // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n    if (!x.c || !y.s || y.c && !y.c[0]) {\r\n      return new BigNumber(NaN);\r\n\r\n    // Return x if y is Infinity or x is zero.\r\n    } else if (!y.c || x.c && !x.c[0]) {\r\n      return new BigNumber(x);\r\n    }\r\n\r\n    if (MODULO_MODE == 9) {\r\n\r\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n      // r = x - qy    where  0 <= r < abs(y)\r\n      s = y.s;\r\n      y.s = 1;\r\n      q = div(x, y, 0, 3);\r\n      y.s = s;\r\n      q.s *= s;\r\n    } else {\r\n      q = div(x, y, 0, MODULO_MODE);\r\n    }\r\n\r\n    y = x.minus(q.times(y));\r\n\r\n    // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n   * of BigNumber(y, b).\r\n   */\r\n  P.multipliedBy = P.times = function (y, b) {\r\n    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n      base, sqrtBase,\r\n      x = this,\r\n      xc = x.c,\r\n      yc = (y = new BigNumber(y, b)).c;\r\n\r\n    // Either NaN, Infinity or 0?\r\n    if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n      // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n        y.c = y.e = y.s = null;\r\n      } else {\r\n        y.s *= x.s;\r\n\r\n        // Return Infinity if either is Infinity.\r\n        if (!xc || !yc) {\r\n          y.c = y.e = null;\r\n\r\n        // Return 0 if either is 0.\r\n        } else {\r\n          y.c = [0];\r\n          y.e = 0;\r\n        }\r\n      }\r\n\r\n      return y;\r\n    }\r\n\r\n    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n    y.s *= x.s;\r\n    xcL = xc.length;\r\n    ycL = yc.length;\r\n\r\n    // Ensure xc points to longer array and xcL to its length.\r\n    if (xcL < ycL) {\r\n      zc = xc;\r\n      xc = yc;\r\n      yc = zc;\r\n      i = xcL;\r\n      xcL = ycL;\r\n      ycL = i;\r\n    }\r\n\r\n    // Initialise the result array with zeros.\r\n    for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n    base = BASE;\r\n    sqrtBase = SQRT_BASE;\r\n\r\n    for (i = ycL; --i >= 0;) {\r\n      c = 0;\r\n      ylo = yc[i] % sqrtBase;\r\n      yhi = yc[i] / sqrtBase | 0;\r\n\r\n      for (k = xcL, j = i + k; j > i;) {\r\n        xlo = xc[--k] % sqrtBase;\r\n        xhi = xc[k] / sqrtBase | 0;\r\n        m = yhi * xlo + xhi * ylo;\r\n        xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n        zc[j--] = xlo % base;\r\n      }\r\n\r\n      zc[j] = c;\r\n    }\r\n\r\n    if (c) {\r\n      ++e;\r\n    } else {\r\n      zc.splice(0, 1);\r\n    }\r\n\r\n    return normalise(y, zc, e);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n   * i.e. multiplied by -1.\r\n   */\r\n  P.negated = function () {\r\n    var x = new BigNumber(this);\r\n    x.s = -x.s || null;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n   * BigNumber(y, b).\r\n   */\r\n  P.plus = function (y, b) {\r\n    var t,\r\n      x = this,\r\n      a = x.s;\r\n\r\n    y = new BigNumber(y, b);\r\n    b = y.s;\r\n\r\n    // Either NaN?\r\n    if (!a || !b) return new BigNumber(NaN);\r\n\r\n    // Signs differ?\r\n     if (a != b) {\r\n      y.s = -b;\r\n      return x.minus(y);\r\n    }\r\n\r\n    var xe = x.e / LOG_BASE,\r\n      ye = y.e / LOG_BASE,\r\n      xc = x.c,\r\n      yc = y.c;\r\n\r\n    if (!xe || !ye) {\r\n\r\n      // Return Infinity if either Infinity.\r\n      if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n      // Either zero?\r\n      // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n    }\r\n\r\n    xe = bitFloor(xe);\r\n    ye = bitFloor(ye);\r\n    xc = xc.slice();\r\n\r\n    // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n    if (a = xe - ye) {\r\n      if (a > 0) {\r\n        ye = xe;\r\n        t = yc;\r\n      } else {\r\n        a = -a;\r\n        t = xc;\r\n      }\r\n\r\n      t.reverse();\r\n      for (; a--; t.push(0));\r\n      t.reverse();\r\n    }\r\n\r\n    a = xc.length;\r\n    b = yc.length;\r\n\r\n    // Point xc to the longer array, and b to the shorter length.\r\n    if (a - b < 0) {\r\n      t = yc;\r\n      yc = xc;\r\n      xc = t;\r\n      b = a;\r\n    }\r\n\r\n    // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n    for (a = 0; b;) {\r\n      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n    }\r\n\r\n    if (a) {\r\n      xc = [a].concat(xc);\r\n      ++ye;\r\n    }\r\n\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    // ye = MAX_EXP + 1 possible\r\n    return normalise(y, xc, ye);\r\n  };\r\n\r\n\r\n  /*\r\n   * If sd is undefined or null or true or false, return the number of significant digits of\r\n   * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n   * If sd is true include integer-part trailing zeros in the count.\r\n   *\r\n   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n   *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */\r\n  P.precision = P.sd = function (sd, rm) {\r\n    var c, n, v,\r\n      x = this;\r\n\r\n    if (sd != null && sd !== !!sd) {\r\n      intCheck(sd, 1, MAX);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      return round(new BigNumber(x), sd, rm);\r\n    }\r\n\r\n    if (!(c = x.c)) return null;\r\n    v = c.length - 1;\r\n    n = v * LOG_BASE + 1;\r\n\r\n    if (v = c[v]) {\r\n\r\n      // Subtract the number of trailing zeros of the last element.\r\n      for (; v % 10 == 0; v /= 10, n--);\r\n\r\n      // Add the number of digits of the first element.\r\n      for (v = c[0]; v >= 10; v /= 10, n++);\r\n    }\r\n\r\n    if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n   *\r\n   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n   */\r\n  P.shiftedBy = function (k) {\r\n    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n    return this.times('1e' + k);\r\n  };\r\n\r\n\r\n  /*\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N) =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I) =  I\r\n   *  sqrt(0) =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var m, n, r, rep, t,\r\n      x = this,\r\n      c = x.c,\r\n      s = x.s,\r\n      e = x.e,\r\n      dp = DECIMAL_PLACES + 4,\r\n      half = new BigNumber('0.5');\r\n\r\n    // Negative/NaN/Infinity/zero?\r\n    if (s !== 1 || !c || !c[0]) {\r\n      return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n    }\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+valueOf(x));\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = coeffToString(c);\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(+n);\r\n      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new BigNumber(n);\r\n    } else {\r\n      r = new BigNumber(s + '');\r\n    }\r\n\r\n    // Check for zero.\r\n    // r could be zero if MIN_EXP is changed after the this value was created.\r\n    // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n    // coeffToString to throw.\r\n    if (r.c[0]) {\r\n      e = r.e;\r\n      s = e + dp;\r\n      if (s < 3) s = 0;\r\n\r\n      // Newton-Raphson iteration.\r\n      for (; ;) {\r\n        t = r;\r\n        r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n          // The exponent of r may here be one less than the final result exponent,\r\n          // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n          // are indexed correctly.\r\n          if (r.e < e) --s;\r\n          n = n.slice(s - 3, s + 1);\r\n\r\n          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n          // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n          // iteration.\r\n          if (n == '9999' || !rep && n == '4999') {\r\n\r\n            // On the first iteration only, check to see if rounding up gives the\r\n            // exact result as the nines may infinitely repeat.\r\n            if (!rep) {\r\n              round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n              if (t.times(t).eq(x)) {\r\n                r = t;\r\n                break;\r\n              }\r\n            }\r\n\r\n            dp += 4;\r\n            s += 4;\r\n            rep = 1;\r\n          } else {\r\n\r\n            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n            // result. If not, then there are further digits and m will be truthy.\r\n            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n              // Truncate to the first rounding digit.\r\n              round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n              m = !r.times(r).eq(x);\r\n            }\r\n\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in exponential notation and\r\n   * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      dp++;\r\n    }\r\n    return format(this, dp, rm, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n   * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      dp = dp + this.e + 1;\r\n    }\r\n    return format(this, dp, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n   * of the format or FORMAT object (see BigNumber.set).\r\n   *\r\n   * The formatting object may contain some or all of the properties shown below.\r\n   *\r\n   * FORMAT = {\r\n   *   prefix: '',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 0,\r\n   *   groupSeparator: ',',\r\n   *   decimalSeparator: '.',\r\n   *   fractionGroupSize: 0,\r\n   *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n   *   suffix: ''\r\n   * };\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   * [format] {object} Formatting options. See FORMAT pbject above.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   * '[BigNumber Error] Argument not an object: {format}'\r\n   */\r\n  P.toFormat = function (dp, rm, format) {\r\n    var str,\r\n      x = this;\r\n\r\n    if (format == null) {\r\n      if (dp != null && rm && typeof rm == 'object') {\r\n        format = rm;\r\n        rm = null;\r\n      } else if (dp && typeof dp == 'object') {\r\n        format = dp;\r\n        dp = rm = null;\r\n      } else {\r\n        format = FORMAT;\r\n      }\r\n    } else if (typeof format != 'object') {\r\n      throw Error\r\n        (bignumberError + 'Argument not an object: ' + format);\r\n    }\r\n\r\n    str = x.toFixed(dp, rm);\r\n\r\n    if (x.c) {\r\n      var i,\r\n        arr = str.split('.'),\r\n        g1 = +format.groupSize,\r\n        g2 = +format.secondaryGroupSize,\r\n        groupSeparator = format.groupSeparator || '',\r\n        intPart = arr[0],\r\n        fractionPart = arr[1],\r\n        isNeg = x.s < 0,\r\n        intDigits = isNeg ? intPart.slice(1) : intPart,\r\n        len = intDigits.length;\r\n\r\n      if (g2) {\r\n        i = g1;\r\n        g1 = g2;\r\n        g2 = i;\r\n        len -= i;\r\n      }\r\n\r\n      if (g1 > 0 && len > 0) {\r\n        i = len % g1 || g1;\r\n        intPart = intDigits.substr(0, i);\r\n        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n        if (isNeg) intPart = '-' + intPart;\r\n      }\r\n\r\n      str = fractionPart\r\n       ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n        ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n         '$&' + (format.fractionGroupSeparator || ''))\r\n        : fractionPart)\r\n       : intPart;\r\n    }\r\n\r\n    return (format.prefix || '') + str + (format.suffix || '');\r\n  };\r\n\r\n\r\n  /*\r\n   * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n   * fraction with an integer numerator and an integer denominator.\r\n   * The denominator will be a positive non-zero value less than or equal to the specified\r\n   * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n   * the lowest value necessary to represent the number exactly.\r\n   *\r\n   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n   *\r\n   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n   */\r\n  P.toFraction = function (md) {\r\n    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n      x = this,\r\n      xc = x.c;\r\n\r\n    if (md != null) {\r\n      n = new BigNumber(md);\r\n\r\n      // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n        throw Error\r\n          (bignumberError + 'Argument ' +\r\n            (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n      }\r\n    }\r\n\r\n    if (!xc) return new BigNumber(x);\r\n\r\n    d = new BigNumber(ONE);\r\n    n1 = d0 = new BigNumber(ONE);\r\n    d1 = n0 = new BigNumber(ONE);\r\n    s = coeffToString(xc);\r\n\r\n    // Determine initial denominator.\r\n    // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n    e = d.e = s.length - x.e - 1;\r\n    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n    md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n    exp = MAX_EXP;\r\n    MAX_EXP = 1 / 0;\r\n    n = new BigNumber(s);\r\n\r\n    // n0 = d1 = 0\r\n    n0.c[0] = 0;\r\n\r\n    for (; ;)  {\r\n      q = div(n, d, 0, 1);\r\n      d2 = d0.plus(q.times(d1));\r\n      if (d2.comparedTo(md) == 1) break;\r\n      d0 = d1;\r\n      d1 = d2;\r\n      n1 = n0.plus(q.times(d2 = n1));\r\n      n0 = d2;\r\n      d = n.minus(q.times(d2 = d));\r\n      n = d2;\r\n    }\r\n\r\n    d2 = div(md.minus(d0), d1, 0, 1);\r\n    n0 = n0.plus(d2.times(n1));\r\n    d0 = d0.plus(d2.times(d1));\r\n    n0.s = n1.s = x.s;\r\n    e = e * 2;\r\n\r\n    // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n    MAX_EXP = exp;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this BigNumber converted to a number primitive.\r\n   */\r\n  P.toNumber = function () {\r\n    return +valueOf(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n   * necessary to represent the integer part of the value in fixed-point notation, then use\r\n   * exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    if (sd != null) intCheck(sd, 1, MAX);\r\n    return format(this, sd, rm, 2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n   * TO_EXP_NEG, return exponential notation.\r\n   *\r\n   * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n   *\r\n   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n   */\r\n  P.toString = function (b) {\r\n    var str,\r\n      n = this,\r\n      s = n.s,\r\n      e = n.e;\r\n\r\n    // Infinity or NaN?\r\n    if (e === null) {\r\n      if (s) {\r\n        str = 'Infinity';\r\n        if (s < 0) str = '-' + str;\r\n      } else {\r\n        str = 'NaN';\r\n      }\r\n    } else {\r\n      if (b == null) {\r\n        str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n         ? toExponential(coeffToString(n.c), e)\r\n         : toFixedPoint(coeffToString(n.c), e, '0');\r\n      } else if (b === 10 && alphabetHasNormalDecimalDigits) {\r\n        n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n        str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n      } else {\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n        str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n      }\r\n\r\n      if (s < 0 && n.c[0]) str = '-' + str;\r\n    }\r\n\r\n    return str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return as toString, but do not accept a base argument, and include the minus sign for\r\n   * negative zero.\r\n   */\r\n  P.valueOf = P.toJSON = function () {\r\n    return valueOf(this);\r\n  };\r\n\r\n\r\n  P._isBigNumber = true;\r\n\r\n  P[Symbol.toStringTag] = 'BigNumber';\r\n\r\n  // Node.js v10.12.0+\r\n  P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;\r\n\r\n  if (configObject != null) BigNumber.set(configObject);\r\n\r\n  return BigNumber;\r\n}\r\n\r\n\r\n// PRIVATE HELPER FUNCTIONS\r\n\r\n// These functions don't need access to variables,\r\n// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\nfunction bitFloor(n) {\r\n  var i = n | 0;\r\n  return n > 0 || n === i ? i : i - 1;\r\n}\r\n\r\n\r\n// Return a coefficient array as a string of base 10 digits.\r\nfunction coeffToString(a) {\r\n  var s, z,\r\n    i = 1,\r\n    j = a.length,\r\n    r = a[0] + '';\r\n\r\n  for (; i < j;) {\r\n    s = a[i++] + '';\r\n    z = LOG_BASE - s.length;\r\n    for (; z--; s = '0' + s);\r\n    r += s;\r\n  }\r\n\r\n  // Determine trailing zeros.\r\n  for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n  return r.slice(0, j + 1 || 1);\r\n}\r\n\r\n\r\n// Compare the value of BigNumbers x and y.\r\nfunction compare(x, y) {\r\n  var a, b,\r\n    xc = x.c,\r\n    yc = y.c,\r\n    i = x.s,\r\n    j = y.s,\r\n    k = x.e,\r\n    l = y.e;\r\n\r\n  // Either NaN?\r\n  if (!i || !j) return null;\r\n\r\n  a = xc && !xc[0];\r\n  b = yc && !yc[0];\r\n\r\n  // Either zero?\r\n  if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n  // Signs differ?\r\n  if (i != j) return i;\r\n\r\n  a = i < 0;\r\n  b = k == l;\r\n\r\n  // Either Infinity?\r\n  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n  // Compare exponents.\r\n  if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n  j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n  // Compare digit by digit.\r\n  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n  // Compare lengths.\r\n  return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n}\r\n\r\n\r\n/*\r\n * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n */\r\nfunction intCheck(n, min, max, name) {\r\n  if (n < min || n > max || n !== mathfloor(n)) {\r\n    throw Error\r\n     (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n       ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n       : ' not a primitive number: ') + String(n));\r\n  }\r\n}\r\n\r\n\r\n// Assumes finite n.\r\nfunction isOdd(n) {\r\n  var k = n.c.length - 1;\r\n  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n}\r\n\r\n\r\nfunction toExponential(str, e) {\r\n  return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n   (e < 0 ? 'e' : 'e+') + e;\r\n}\r\n\r\n\r\nfunction toFixedPoint(str, e, z) {\r\n  var len, zs;\r\n\r\n  // Negative exponent?\r\n  if (e < 0) {\r\n\r\n    // Prepend zeros.\r\n    for (zs = z + '.'; ++e; zs += z);\r\n    str = zs + str;\r\n\r\n  // Positive exponent\r\n  } else {\r\n    len = str.length;\r\n\r\n    // Append zeros.\r\n    if (++e > len) {\r\n      for (zs = z, e -= len; --e; zs += z);\r\n      str += zs;\r\n    } else if (e < len) {\r\n      str = str.slice(0, e) + '.' + str.slice(e);\r\n    }\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\n\r\n// EXPORT\r\n\r\n\r\nexport var BigNumber = clone();\r\n\r\nexport default BigNumber;\r\n","// src/index.ts\nvar SplayTreeNode = class {\n  key;\n  left = null;\n  right = null;\n  constructor(key) {\n    this.key = key;\n  }\n};\nvar SplayTreeSetNode = class extends SplayTreeNode {\n  constructor(key) {\n    super(key);\n  }\n};\nvar SplayTreeMapNode = class _SplayTreeMapNode extends SplayTreeNode {\n  value;\n  constructor(key, value) {\n    super(key);\n    this.value = value;\n  }\n  replaceValue(value) {\n    const node = new _SplayTreeMapNode(this.key, value);\n    node.left = this.left;\n    node.right = this.right;\n    return node;\n  }\n};\nvar SplayTree = class {\n  size = 0;\n  modificationCount = 0;\n  splayCount = 0;\n  splay(key) {\n    const root = this.root;\n    if (root == null) {\n      this.compare(key, key);\n      return -1;\n    }\n    let right = null;\n    let newTreeRight = null;\n    let left = null;\n    let newTreeLeft = null;\n    let current = root;\n    const compare = this.compare;\n    let comp;\n    while (true) {\n      comp = compare(current.key, key);\n      if (comp > 0) {\n        let currentLeft = current.left;\n        if (currentLeft == null) break;\n        comp = compare(currentLeft.key, key);\n        if (comp > 0) {\n          current.left = currentLeft.right;\n          currentLeft.right = current;\n          current = currentLeft;\n          currentLeft = current.left;\n          if (currentLeft == null) break;\n        }\n        if (right == null) {\n          newTreeRight = current;\n        } else {\n          right.left = current;\n        }\n        right = current;\n        current = currentLeft;\n      } else if (comp < 0) {\n        let currentRight = current.right;\n        if (currentRight == null) break;\n        comp = compare(currentRight.key, key);\n        if (comp < 0) {\n          current.right = currentRight.left;\n          currentRight.left = current;\n          current = currentRight;\n          currentRight = current.right;\n          if (currentRight == null) break;\n        }\n        if (left == null) {\n          newTreeLeft = current;\n        } else {\n          left.right = current;\n        }\n        left = current;\n        current = currentRight;\n      } else {\n        break;\n      }\n    }\n    if (left != null) {\n      left.right = current.left;\n      current.left = newTreeLeft;\n    }\n    if (right != null) {\n      right.left = current.right;\n      current.right = newTreeRight;\n    }\n    if (this.root !== current) {\n      this.root = current;\n      this.splayCount++;\n    }\n    return comp;\n  }\n  splayMin(node) {\n    let current = node;\n    let nextLeft = current.left;\n    while (nextLeft != null) {\n      const left = nextLeft;\n      current.left = left.right;\n      left.right = current;\n      current = left;\n      nextLeft = current.left;\n    }\n    return current;\n  }\n  splayMax(node) {\n    let current = node;\n    let nextRight = current.right;\n    while (nextRight != null) {\n      const right = nextRight;\n      current.right = right.left;\n      right.left = current;\n      current = right;\n      nextRight = current.right;\n    }\n    return current;\n  }\n  _delete(key) {\n    if (this.root == null) return null;\n    const comp = this.splay(key);\n    if (comp != 0) return null;\n    let root = this.root;\n    const result = root;\n    const left = root.left;\n    this.size--;\n    if (left == null) {\n      this.root = root.right;\n    } else {\n      const right = root.right;\n      root = this.splayMax(left);\n      root.right = right;\n      this.root = root;\n    }\n    this.modificationCount++;\n    return result;\n  }\n  addNewRoot(node, comp) {\n    this.size++;\n    this.modificationCount++;\n    const root = this.root;\n    if (root == null) {\n      this.root = node;\n      return;\n    }\n    if (comp < 0) {\n      node.left = root;\n      node.right = root.right;\n      root.right = null;\n    } else {\n      node.right = root;\n      node.left = root.left;\n      root.left = null;\n    }\n    this.root = node;\n  }\n  _first() {\n    const root = this.root;\n    if (root == null) return null;\n    this.root = this.splayMin(root);\n    return this.root;\n  }\n  _last() {\n    const root = this.root;\n    if (root == null) return null;\n    this.root = this.splayMax(root);\n    return this.root;\n  }\n  clear() {\n    this.root = null;\n    this.size = 0;\n    this.modificationCount++;\n  }\n  has(key) {\n    return this.validKey(key) && this.splay(key) == 0;\n  }\n  defaultCompare() {\n    return (a, b) => a < b ? -1 : a > b ? 1 : 0;\n  }\n  wrap() {\n    return {\n      getRoot: () => {\n        return this.root;\n      },\n      setRoot: (root) => {\n        this.root = root;\n      },\n      getSize: () => {\n        return this.size;\n      },\n      getModificationCount: () => {\n        return this.modificationCount;\n      },\n      getSplayCount: () => {\n        return this.splayCount;\n      },\n      setSplayCount: (count) => {\n        this.splayCount = count;\n      },\n      splay: (key) => {\n        return this.splay(key);\n      },\n      has: (key) => {\n        return this.has(key);\n      }\n    };\n  }\n};\nvar SplayTreeMap = class extends SplayTree {\n  root = null;\n  compare;\n  validKey;\n  constructor(compare, isValidKey) {\n    super();\n    this.compare = compare ?? this.defaultCompare();\n    this.validKey = isValidKey ?? ((a) => a != null && a != void 0);\n  }\n  delete(key) {\n    if (!this.validKey(key)) return false;\n    return this._delete(key) != null;\n  }\n  forEach(f) {\n    const nodes = new SplayTreeMapEntryIterableIterator(this.wrap());\n    let result;\n    while (result = nodes.next(), !result.done) {\n      f(result.value[1], result.value[0], this);\n    }\n  }\n  get(key) {\n    if (!this.validKey(key)) return void 0;\n    if (this.root != null) {\n      const comp = this.splay(key);\n      if (comp == 0) {\n        return this.root.value;\n      }\n    }\n    return void 0;\n  }\n  hasValue(value) {\n    const initialSplayCount = this.splayCount;\n    const visit = (node) => {\n      while (node != null) {\n        if (node.value == value) return true;\n        if (initialSplayCount != this.splayCount) {\n          throw \"Concurrent modification during iteration.\";\n        }\n        if (node.right != null && visit(node.right)) {\n          return true;\n        }\n        node = node.left;\n      }\n      return false;\n    };\n    return visit(this.root);\n  }\n  set(key, value) {\n    const comp = this.splay(key);\n    if (comp == 0) {\n      this.root = this.root.replaceValue(value);\n      this.splayCount += 1;\n      return this;\n    }\n    this.addNewRoot(new SplayTreeMapNode(key, value), comp);\n    return this;\n  }\n  setAll(other) {\n    other.forEach((value, key) => {\n      this.set(key, value);\n    });\n  }\n  setIfAbsent(key, ifAbsent) {\n    let comp = this.splay(key);\n    if (comp == 0) {\n      return this.root.value;\n    }\n    const modificationCount = this.modificationCount;\n    const splayCount = this.splayCount;\n    const value = ifAbsent();\n    if (modificationCount != this.modificationCount) {\n      throw \"Concurrent modification during iteration.\";\n    }\n    if (splayCount != this.splayCount) {\n      comp = this.splay(key);\n    }\n    this.addNewRoot(new SplayTreeMapNode(key, value), comp);\n    return value;\n  }\n  isEmpty() {\n    return this.root == null;\n  }\n  isNotEmpty() {\n    return !this.isEmpty();\n  }\n  firstKey() {\n    if (this.root == null) return null;\n    return this._first().key;\n  }\n  lastKey() {\n    if (this.root == null) return null;\n    return this._last().key;\n  }\n  lastKeyBefore(key) {\n    if (key == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(key);\n    if (comp < 0) return this.root.key;\n    let node = this.root.left;\n    if (node == null) return null;\n    let nodeRight = node.right;\n    while (nodeRight != null) {\n      node = nodeRight;\n      nodeRight = node.right;\n    }\n    return node.key;\n  }\n  firstKeyAfter(key) {\n    if (key == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(key);\n    if (comp > 0) return this.root.key;\n    let node = this.root.right;\n    if (node == null) return null;\n    let nodeLeft = node.left;\n    while (nodeLeft != null) {\n      node = nodeLeft;\n      nodeLeft = node.left;\n    }\n    return node.key;\n  }\n  update(key, update, ifAbsent) {\n    let comp = this.splay(key);\n    if (comp == 0) {\n      const modificationCount = this.modificationCount;\n      const splayCount = this.splayCount;\n      const newValue = update(this.root.value);\n      if (modificationCount != this.modificationCount) {\n        throw \"Concurrent modification during iteration.\";\n      }\n      if (splayCount != this.splayCount) {\n        this.splay(key);\n      }\n      this.root = this.root.replaceValue(newValue);\n      this.splayCount += 1;\n      return newValue;\n    }\n    if (ifAbsent != null) {\n      const modificationCount = this.modificationCount;\n      const splayCount = this.splayCount;\n      const newValue = ifAbsent();\n      if (modificationCount != this.modificationCount) {\n        throw \"Concurrent modification during iteration.\";\n      }\n      if (splayCount != this.splayCount) {\n        comp = this.splay(key);\n      }\n      this.addNewRoot(new SplayTreeMapNode(key, newValue), comp);\n      return newValue;\n    }\n    throw \"Invalid argument (key): Key not in map.\";\n  }\n  updateAll(update) {\n    const root = this.root;\n    if (root == null) return;\n    const iterator = new SplayTreeMapEntryIterableIterator(this.wrap());\n    let node;\n    while (node = iterator.next(), !node.done) {\n      const newValue = update(...node.value);\n      iterator.replaceValue(newValue);\n    }\n  }\n  keys() {\n    return new SplayTreeKeyIterableIterator(this.wrap());\n  }\n  values() {\n    return new SplayTreeValueIterableIterator(this.wrap());\n  }\n  entries() {\n    return this[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return new SplayTreeMapEntryIterableIterator(this.wrap());\n  }\n  [Symbol.toStringTag] = \"[object Map]\";\n};\nvar SplayTreeSet = class _SplayTreeSet extends SplayTree {\n  root = null;\n  compare;\n  validKey;\n  constructor(compare, isValidKey) {\n    super();\n    this.compare = compare ?? this.defaultCompare();\n    this.validKey = isValidKey ?? ((v) => v != null && v != void 0);\n  }\n  delete(element) {\n    if (!this.validKey(element)) return false;\n    return this._delete(element) != null;\n  }\n  deleteAll(elements) {\n    for (const element of elements) {\n      this.delete(element);\n    }\n  }\n  forEach(f) {\n    const nodes = this[Symbol.iterator]();\n    let result;\n    while (result = nodes.next(), !result.done) {\n      f(result.value, result.value, this);\n    }\n  }\n  add(element) {\n    const compare = this.splay(element);\n    if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);\n    return this;\n  }\n  addAndReturn(element) {\n    const compare = this.splay(element);\n    if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);\n    return this.root.key;\n  }\n  addAll(elements) {\n    for (const element of elements) {\n      this.add(element);\n    }\n  }\n  isEmpty() {\n    return this.root == null;\n  }\n  isNotEmpty() {\n    return this.root != null;\n  }\n  single() {\n    if (this.size == 0) throw \"Bad state: No element\";\n    if (this.size > 1) throw \"Bad state: Too many element\";\n    return this.root.key;\n  }\n  first() {\n    if (this.size == 0) throw \"Bad state: No element\";\n    return this._first().key;\n  }\n  last() {\n    if (this.size == 0) throw \"Bad state: No element\";\n    return this._last().key;\n  }\n  lastBefore(element) {\n    if (element == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(element);\n    if (comp < 0) return this.root.key;\n    let node = this.root.left;\n    if (node == null) return null;\n    let nodeRight = node.right;\n    while (nodeRight != null) {\n      node = nodeRight;\n      nodeRight = node.right;\n    }\n    return node.key;\n  }\n  firstAfter(element) {\n    if (element == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(element);\n    if (comp > 0) return this.root.key;\n    let node = this.root.right;\n    if (node == null) return null;\n    let nodeLeft = node.left;\n    while (nodeLeft != null) {\n      node = nodeLeft;\n      nodeLeft = node.left;\n    }\n    return node.key;\n  }\n  retainAll(elements) {\n    const retainSet = new _SplayTreeSet(this.compare, this.validKey);\n    const modificationCount = this.modificationCount;\n    for (const object of elements) {\n      if (modificationCount != this.modificationCount) {\n        throw \"Concurrent modification during iteration.\";\n      }\n      if (this.validKey(object) && this.splay(object) == 0) {\n        retainSet.add(this.root.key);\n      }\n    }\n    if (retainSet.size != this.size) {\n      this.root = retainSet.root;\n      this.size = retainSet.size;\n      this.modificationCount++;\n    }\n  }\n  lookup(object) {\n    if (!this.validKey(object)) return null;\n    const comp = this.splay(object);\n    if (comp != 0) return null;\n    return this.root.key;\n  }\n  intersection(other) {\n    const result = new _SplayTreeSet(this.compare, this.validKey);\n    for (const element of this) {\n      if (other.has(element)) result.add(element);\n    }\n    return result;\n  }\n  difference(other) {\n    const result = new _SplayTreeSet(this.compare, this.validKey);\n    for (const element of this) {\n      if (!other.has(element)) result.add(element);\n    }\n    return result;\n  }\n  union(other) {\n    const u = this.clone();\n    u.addAll(other);\n    return u;\n  }\n  clone() {\n    const set = new _SplayTreeSet(this.compare, this.validKey);\n    set.size = this.size;\n    set.root = this.copyNode(this.root);\n    return set;\n  }\n  copyNode(node) {\n    if (node == null) return null;\n    function copyChildren(node2, dest) {\n      let left;\n      let right;\n      do {\n        left = node2.left;\n        right = node2.right;\n        if (left != null) {\n          const newLeft = new SplayTreeSetNode(left.key);\n          dest.left = newLeft;\n          copyChildren(left, newLeft);\n        }\n        if (right != null) {\n          const newRight = new SplayTreeSetNode(right.key);\n          dest.right = newRight;\n          node2 = right;\n          dest = newRight;\n        }\n      } while (right != null);\n    }\n    const result = new SplayTreeSetNode(node.key);\n    copyChildren(node, result);\n    return result;\n  }\n  toSet() {\n    return this.clone();\n  }\n  entries() {\n    return new SplayTreeSetEntryIterableIterator(this.wrap());\n  }\n  keys() {\n    return this[Symbol.iterator]();\n  }\n  values() {\n    return this[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return new SplayTreeKeyIterableIterator(this.wrap());\n  }\n  [Symbol.toStringTag] = \"[object Set]\";\n};\nvar SplayTreeIterableIterator = class {\n  tree;\n  path = new Array();\n  modificationCount = null;\n  splayCount;\n  constructor(tree) {\n    this.tree = tree;\n    this.splayCount = tree.getSplayCount();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    if (this.moveNext()) return { done: false, value: this.current() };\n    return { done: true, value: null };\n  }\n  current() {\n    if (!this.path.length) return null;\n    const node = this.path[this.path.length - 1];\n    return this.getValue(node);\n  }\n  rebuildPath(key) {\n    this.path.splice(0, this.path.length);\n    this.tree.splay(key);\n    this.path.push(this.tree.getRoot());\n    this.splayCount = this.tree.getSplayCount();\n  }\n  findLeftMostDescendent(node) {\n    while (node != null) {\n      this.path.push(node);\n      node = node.left;\n    }\n  }\n  moveNext() {\n    if (this.modificationCount != this.tree.getModificationCount()) {\n      if (this.modificationCount == null) {\n        this.modificationCount = this.tree.getModificationCount();\n        let node2 = this.tree.getRoot();\n        while (node2 != null) {\n          this.path.push(node2);\n          node2 = node2.left;\n        }\n        return this.path.length > 0;\n      }\n      throw \"Concurrent modification during iteration.\";\n    }\n    if (!this.path.length) return false;\n    if (this.splayCount != this.tree.getSplayCount()) {\n      this.rebuildPath(this.path[this.path.length - 1].key);\n    }\n    let node = this.path[this.path.length - 1];\n    let next = node.right;\n    if (next != null) {\n      while (next != null) {\n        this.path.push(next);\n        next = next.left;\n      }\n      return true;\n    }\n    this.path.pop();\n    while (this.path.length && this.path[this.path.length - 1].right === node) {\n      node = this.path.pop();\n    }\n    return this.path.length > 0;\n  }\n};\nvar SplayTreeKeyIterableIterator = class extends SplayTreeIterableIterator {\n  getValue(node) {\n    return node.key;\n  }\n};\nvar SplayTreeSetEntryIterableIterator = class extends SplayTreeIterableIterator {\n  getValue(node) {\n    return [node.key, node.key];\n  }\n};\nvar SplayTreeValueIterableIterator = class extends SplayTreeIterableIterator {\n  constructor(map) {\n    super(map);\n  }\n  getValue(node) {\n    return node.value;\n  }\n};\nvar SplayTreeMapEntryIterableIterator = class extends SplayTreeIterableIterator {\n  constructor(map) {\n    super(map);\n  }\n  getValue(node) {\n    return [node.key, node.value];\n  }\n  replaceValue(value) {\n    if (this.modificationCount != this.tree.getModificationCount()) {\n      throw \"Concurrent modification during iteration.\";\n    }\n    if (this.splayCount != this.tree.getSplayCount()) {\n      this.rebuildPath(this.path[this.path.length - 1].key);\n    }\n    const last = this.path.pop();\n    const newLast = last.replaceValue(value);\n    if (!this.path.length) {\n      this.tree.setRoot(newLast);\n    } else {\n      const parent = this.path[this.path.length - 1];\n      if (last === parent.left) {\n        parent.left = newLast;\n      } else {\n        parent.right = newLast;\n      }\n    }\n    this.path.push(newLast);\n    const count = this.tree.getSplayCount() + 1;\n    this.tree.setSplayCount(count);\n    this.splayCount = count;\n  }\n};\nexport {\n  SplayTreeMap,\n  SplayTreeSet\n};\n//# sourceMappingURL=index.js.map","// src/geom-in.ts\nimport BigNumber2 from \"bignumber.js\";\n\n// src/constant.ts\nvar constant_default = (x) => {\n  return () => {\n    return x;\n  };\n};\n\n// src/compare.ts\nvar compare_default = (eps) => {\n  const almostEqual = eps ? (a, b) => b.minus(a).abs().isLessThanOrEqualTo(eps) : constant_default(false);\n  return (a, b) => {\n    if (almostEqual(a, b)) return 0;\n    return a.comparedTo(b);\n  };\n};\n\n// src/orient.ts\nfunction orient_default(eps) {\n  const almostCollinear = eps ? (area2, ax, ay, cx, cy) => area2.exponentiatedBy(2).isLessThanOrEqualTo(\n    cx.minus(ax).exponentiatedBy(2).plus(cy.minus(ay).exponentiatedBy(2)).times(eps)\n  ) : constant_default(false);\n  return (a, b, c) => {\n    const ax = a.x, ay = a.y, cx = c.x, cy = c.y;\n    const area2 = ay.minus(cy).times(b.x.minus(cx)).minus(ax.minus(cx).times(b.y.minus(cy)));\n    if (almostCollinear(area2, ax, ay, cx, cy)) return 0;\n    return area2.comparedTo(0);\n  };\n}\n\n// src/snap.ts\nimport BigNumber from \"bignumber.js\";\nimport { SplayTreeSet } from \"splaytree-ts\";\n\n// src/identity.ts\nvar identity_default = (x) => {\n  return x;\n};\n\n// src/snap.ts\nvar snap_default = (eps) => {\n  if (eps) {\n    const xTree = new SplayTreeSet(compare_default(eps));\n    const yTree = new SplayTreeSet(compare_default(eps));\n    const snapCoord = (coord, tree) => {\n      return tree.addAndReturn(coord);\n    };\n    const snap = (v) => {\n      return {\n        x: snapCoord(v.x, xTree),\n        y: snapCoord(v.y, yTree)\n      };\n    };\n    snap({ x: new BigNumber(0), y: new BigNumber(0) });\n    return snap;\n  }\n  return identity_default;\n};\n\n// src/precision.ts\nvar set = (eps) => {\n  return {\n    set: (eps2) => {\n      precision = set(eps2);\n    },\n    reset: () => set(eps),\n    compare: compare_default(eps),\n    snap: snap_default(eps),\n    orient: orient_default(eps)\n  };\n};\nvar precision = set();\n\n// src/bbox.ts\nvar isInBbox = (bbox, point) => {\n  return bbox.ll.x.isLessThanOrEqualTo(point.x) && point.x.isLessThanOrEqualTo(bbox.ur.x) && bbox.ll.y.isLessThanOrEqualTo(point.y) && point.y.isLessThanOrEqualTo(bbox.ur.y);\n};\nvar getBboxOverlap = (b1, b2) => {\n  if (b2.ur.x.isLessThan(b1.ll.x) || b1.ur.x.isLessThan(b2.ll.x) || b2.ur.y.isLessThan(b1.ll.y) || b1.ur.y.isLessThan(b2.ll.y))\n    return null;\n  const lowerX = b1.ll.x.isLessThan(b2.ll.x) ? b2.ll.x : b1.ll.x;\n  const upperX = b1.ur.x.isLessThan(b2.ur.x) ? b1.ur.x : b2.ur.x;\n  const lowerY = b1.ll.y.isLessThan(b2.ll.y) ? b2.ll.y : b1.ll.y;\n  const upperY = b1.ur.y.isLessThan(b2.ur.y) ? b1.ur.y : b2.ur.y;\n  return { ll: { x: lowerX, y: lowerY }, ur: { x: upperX, y: upperY } };\n};\n\n// src/operation.ts\nimport { SplayTreeSet as SplayTreeSet3 } from \"splaytree-ts\";\n\n// src/vector.ts\nvar crossProduct = (a, b) => a.x.times(b.y).minus(a.y.times(b.x));\nvar dotProduct = (a, b) => a.x.times(b.x).plus(a.y.times(b.y));\nvar length = (v) => dotProduct(v, v).sqrt();\nvar sineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = { x: pBase.x.minus(pShared.x), y: pBase.y.minus(pShared.y) };\n  const vAngle = { x: pAngle.x.minus(pShared.x), y: pAngle.y.minus(pShared.y) };\n  return crossProduct(vAngle, vBase).div(length(vAngle)).div(length(vBase));\n};\nvar cosineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = { x: pBase.x.minus(pShared.x), y: pBase.y.minus(pShared.y) };\n  const vAngle = { x: pAngle.x.minus(pShared.x), y: pAngle.y.minus(pShared.y) };\n  return dotProduct(vAngle, vBase).div(length(vAngle)).div(length(vBase));\n};\nvar horizontalIntersection = (pt, v, y) => {\n  if (v.y.isZero()) return null;\n  return { x: pt.x.plus(v.x.div(v.y).times(y.minus(pt.y))), y };\n};\nvar verticalIntersection = (pt, v, x) => {\n  if (v.x.isZero()) return null;\n  return { x, y: pt.y.plus(v.y.div(v.x).times(x.minus(pt.x))) };\n};\nvar intersection = (pt1, v1, pt2, v2) => {\n  if (v1.x.isZero()) return verticalIntersection(pt2, v2, pt1.x);\n  if (v2.x.isZero()) return verticalIntersection(pt1, v1, pt2.x);\n  if (v1.y.isZero()) return horizontalIntersection(pt2, v2, pt1.y);\n  if (v2.y.isZero()) return horizontalIntersection(pt1, v1, pt2.y);\n  const kross = crossProduct(v1, v2);\n  if (kross.isZero()) return null;\n  const ve = { x: pt2.x.minus(pt1.x), y: pt2.y.minus(pt1.y) };\n  const d1 = crossProduct(ve, v1).div(kross);\n  const d2 = crossProduct(ve, v2).div(kross);\n  const x1 = pt1.x.plus(d2.times(v1.x)), x2 = pt2.x.plus(d1.times(v2.x));\n  const y1 = pt1.y.plus(d2.times(v1.y)), y2 = pt2.y.plus(d1.times(v2.y));\n  const x = x1.plus(x2).div(2);\n  const y = y1.plus(y2).div(2);\n  return { x, y };\n};\n\n// src/sweep-event.ts\nvar SweepEvent = class _SweepEvent {\n  point;\n  isLeft;\n  segment;\n  otherSE;\n  consumedBy;\n  // for ordering sweep events in the sweep event queue\n  static compare(a, b) {\n    const ptCmp = _SweepEvent.comparePoints(a.point, b.point);\n    if (ptCmp !== 0) return ptCmp;\n    if (a.point !== b.point) a.link(b);\n    if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;\n    return Segment.compare(a.segment, b.segment);\n  }\n  // for ordering points in sweep line order\n  static comparePoints(aPt, bPt) {\n    if (aPt.x.isLessThan(bPt.x)) return -1;\n    if (aPt.x.isGreaterThan(bPt.x)) return 1;\n    if (aPt.y.isLessThan(bPt.y)) return -1;\n    if (aPt.y.isGreaterThan(bPt.y)) return 1;\n    return 0;\n  }\n  // Warning: 'point' input will be modified and re-used (for performance)\n  constructor(point, isLeft) {\n    if (point.events === void 0) point.events = [this];\n    else point.events.push(this);\n    this.point = point;\n    this.isLeft = isLeft;\n  }\n  link(other) {\n    if (other.point === this.point) {\n      throw new Error(\"Tried to link already linked events\");\n    }\n    const otherEvents = other.point.events;\n    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {\n      const evt = otherEvents[i];\n      this.point.events.push(evt);\n      evt.point = this.point;\n    }\n    this.checkForConsuming();\n  }\n  /* Do a pass over our linked events and check to see if any pair\n   * of segments match, and should be consumed. */\n  checkForConsuming() {\n    const numEvents = this.point.events.length;\n    for (let i = 0; i < numEvents; i++) {\n      const evt1 = this.point.events[i];\n      if (evt1.segment.consumedBy !== void 0) continue;\n      for (let j = i + 1; j < numEvents; j++) {\n        const evt2 = this.point.events[j];\n        if (evt2.consumedBy !== void 0) continue;\n        if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n        evt1.segment.consume(evt2.segment);\n      }\n    }\n  }\n  getAvailableLinkedEvents() {\n    const events = [];\n    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {\n      const evt = this.point.events[i];\n      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n        events.push(evt);\n      }\n    }\n    return events;\n  }\n  /**\n   * Returns a comparator function for sorting linked events that will\n   * favor the event that will give us the smallest left-side angle.\n   * All ring construction starts as low as possible heading to the right,\n   * so by always turning left as sharp as possible we'll get polygons\n   * without uncessary loops & holes.\n   *\n   * The comparator function has a compute cache such that it avoids\n   * re-computing already-computed values.\n   */\n  getLeftmostComparator(baseEvent) {\n    const cache = /* @__PURE__ */ new Map();\n    const fillCache = (linkedEvent) => {\n      const nextEvent = linkedEvent.otherSE;\n      cache.set(linkedEvent, {\n        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),\n        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)\n      });\n    };\n    return (a, b) => {\n      if (!cache.has(a)) fillCache(a);\n      if (!cache.has(b)) fillCache(b);\n      const { sine: asine, cosine: acosine } = cache.get(a);\n      const { sine: bsine, cosine: bcosine } = cache.get(b);\n      if (asine.isGreaterThanOrEqualTo(0) && bsine.isGreaterThanOrEqualTo(0)) {\n        if (acosine.isLessThan(bcosine)) return 1;\n        if (acosine.isGreaterThan(bcosine)) return -1;\n        return 0;\n      }\n      if (asine.isLessThan(0) && bsine.isLessThan(0)) {\n        if (acosine.isLessThan(bcosine)) return -1;\n        if (acosine.isGreaterThan(bcosine)) return 1;\n        return 0;\n      }\n      if (bsine.isLessThan(asine)) return -1;\n      if (bsine.isGreaterThan(asine)) return 1;\n      return 0;\n    };\n  }\n};\n\n// src/geom-out.ts\nvar RingOut = class _RingOut {\n  events;\n  poly;\n  _isExteriorRing;\n  _enclosingRing;\n  /* Given the segments from the sweep line pass, compute & return a series\n   * of closed rings from all the segments marked to be part of the result */\n  static factory(allSegments) {\n    const ringsOut = [];\n    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {\n      const segment = allSegments[i];\n      if (!segment.isInResult() || segment.ringOut) continue;\n      let prevEvent = null;\n      let event = segment.leftSE;\n      let nextEvent = segment.rightSE;\n      const events = [event];\n      const startingPoint = event.point;\n      const intersectionLEs = [];\n      while (true) {\n        prevEvent = event;\n        event = nextEvent;\n        events.push(event);\n        if (event.point === startingPoint) break;\n        while (true) {\n          const availableLEs = event.getAvailableLinkedEvents();\n          if (availableLEs.length === 0) {\n            const firstPt = events[0].point;\n            const lastPt = events[events.length - 1].point;\n            throw new Error(\n              `Unable to complete output ring starting at [${firstPt.x}, ${firstPt.y}]. Last matching segment found ends at [${lastPt.x}, ${lastPt.y}].`\n            );\n          }\n          if (availableLEs.length === 1) {\n            nextEvent = availableLEs[0].otherSE;\n            break;\n          }\n          let indexLE = null;\n          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n            if (intersectionLEs[j].point === event.point) {\n              indexLE = j;\n              break;\n            }\n          }\n          if (indexLE !== null) {\n            const intersectionLE = intersectionLEs.splice(indexLE)[0];\n            const ringEvents = events.splice(intersectionLE.index);\n            ringEvents.unshift(ringEvents[0].otherSE);\n            ringsOut.push(new _RingOut(ringEvents.reverse()));\n            continue;\n          }\n          intersectionLEs.push({\n            index: events.length,\n            point: event.point\n          });\n          const comparator = event.getLeftmostComparator(prevEvent);\n          nextEvent = availableLEs.sort(comparator)[0].otherSE;\n          break;\n        }\n      }\n      ringsOut.push(new _RingOut(events));\n    }\n    return ringsOut;\n  }\n  constructor(events) {\n    this.events = events;\n    for (let i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this;\n    }\n    this.poly = null;\n  }\n  getGeom() {\n    let prevPt = this.events[0].point;\n    const points = [prevPt];\n    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n      const pt2 = this.events[i].point;\n      const nextPt2 = this.events[i + 1].point;\n      if (precision.orient(pt2, prevPt, nextPt2) === 0) continue;\n      points.push(pt2);\n      prevPt = pt2;\n    }\n    if (points.length === 1) return null;\n    const pt = points[0];\n    const nextPt = points[1];\n    if (precision.orient(pt, prevPt, nextPt) === 0) points.shift();\n    points.push(points[0]);\n    const step = this.isExteriorRing() ? 1 : -1;\n    const iStart = this.isExteriorRing() ? 0 : points.length - 1;\n    const iEnd = this.isExteriorRing() ? points.length : -1;\n    const orderedPoints = [];\n    for (let i = iStart; i != iEnd; i += step)\n      orderedPoints.push([points[i].x.toNumber(), points[i].y.toNumber()]);\n    return orderedPoints;\n  }\n  isExteriorRing() {\n    if (this._isExteriorRing === void 0) {\n      const enclosing = this.enclosingRing();\n      this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n    }\n    return this._isExteriorRing;\n  }\n  enclosingRing() {\n    if (this._enclosingRing === void 0) {\n      this._enclosingRing = this._calcEnclosingRing();\n    }\n    return this._enclosingRing;\n  }\n  /* Returns the ring that encloses this one, if any */\n  _calcEnclosingRing() {\n    let leftMostEvt = this.events[0];\n    for (let i = 1, iMax = this.events.length; i < iMax; i++) {\n      const evt = this.events[i];\n      if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n    }\n    let prevSeg = leftMostEvt.segment.prevInResult();\n    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n    while (true) {\n      if (!prevSeg) return null;\n      if (!prevPrevSeg) return prevSeg.ringOut;\n      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n        if (prevPrevSeg.ringOut?.enclosingRing() !== prevSeg.ringOut) {\n          return prevSeg.ringOut;\n        } else return prevSeg.ringOut?.enclosingRing();\n      }\n      prevSeg = prevPrevSeg.prevInResult();\n      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n    }\n  }\n};\nvar PolyOut = class {\n  exteriorRing;\n  interiorRings;\n  constructor(exteriorRing) {\n    this.exteriorRing = exteriorRing;\n    exteriorRing.poly = this;\n    this.interiorRings = [];\n  }\n  addInterior(ring) {\n    this.interiorRings.push(ring);\n    ring.poly = this;\n  }\n  getGeom() {\n    const geom0 = this.exteriorRing.getGeom();\n    if (geom0 === null) return null;\n    const geom = [geom0];\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringGeom = this.interiorRings[i].getGeom();\n      if (ringGeom === null) continue;\n      geom.push(ringGeom);\n    }\n    return geom;\n  }\n};\nvar MultiPolyOut = class {\n  rings;\n  polys;\n  constructor(rings) {\n    this.rings = rings;\n    this.polys = this._composePolys(rings);\n  }\n  getGeom() {\n    const geom = [];\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polyGeom = this.polys[i].getGeom();\n      if (polyGeom === null) continue;\n      geom.push(polyGeom);\n    }\n    return geom;\n  }\n  _composePolys(rings) {\n    const polys = [];\n    for (let i = 0, iMax = rings.length; i < iMax; i++) {\n      const ring = rings[i];\n      if (ring.poly) continue;\n      if (ring.isExteriorRing()) polys.push(new PolyOut(ring));\n      else {\n        const enclosingRing = ring.enclosingRing();\n        if (!enclosingRing?.poly) polys.push(new PolyOut(enclosingRing));\n        enclosingRing?.poly?.addInterior(ring);\n      }\n    }\n    return polys;\n  }\n};\n\n// src/sweep-line.ts\nimport { SplayTreeSet as SplayTreeSet2 } from \"splaytree-ts\";\nvar SweepLine = class {\n  queue;\n  tree;\n  segments;\n  constructor(queue, comparator = Segment.compare) {\n    this.queue = queue;\n    this.tree = new SplayTreeSet2(comparator);\n    this.segments = [];\n  }\n  process(event) {\n    const segment = event.segment;\n    const newEvents = [];\n    if (event.consumedBy) {\n      if (event.isLeft) this.queue.delete(event.otherSE);\n      else this.tree.delete(segment);\n      return newEvents;\n    }\n    if (event.isLeft) this.tree.add(segment);\n    let prevSeg = segment;\n    let nextSeg = segment;\n    do {\n      prevSeg = this.tree.lastBefore(prevSeg);\n    } while (prevSeg != null && prevSeg.consumedBy != void 0);\n    do {\n      nextSeg = this.tree.firstAfter(nextSeg);\n    } while (nextSeg != null && nextSeg.consumedBy != void 0);\n    if (event.isLeft) {\n      let prevMySplitter = null;\n      if (prevSeg) {\n        const prevInter = prevSeg.getIntersection(segment);\n        if (prevInter !== null) {\n          if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n          if (!prevSeg.isAnEndpoint(prevInter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n      let nextMySplitter = null;\n      if (nextSeg) {\n        const nextInter = nextSeg.getIntersection(segment);\n        if (nextInter !== null) {\n          if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n          if (!nextSeg.isAnEndpoint(nextInter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n      if (prevMySplitter !== null || nextMySplitter !== null) {\n        let mySplitter = null;\n        if (prevMySplitter === null) mySplitter = nextMySplitter;\n        else if (nextMySplitter === null) mySplitter = prevMySplitter;\n        else {\n          const cmpSplitters = SweepEvent.comparePoints(\n            prevMySplitter,\n            nextMySplitter\n          );\n          mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n        }\n        this.queue.delete(segment.rightSE);\n        newEvents.push(segment.rightSE);\n        const newEventsFromSplit = segment.split(mySplitter);\n        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n          newEvents.push(newEventsFromSplit[i]);\n        }\n      }\n      if (newEvents.length > 0) {\n        this.tree.delete(segment);\n        newEvents.push(event);\n      } else {\n        this.segments.push(segment);\n        segment.prev = prevSeg;\n      }\n    } else {\n      if (prevSeg && nextSeg) {\n        const inter = prevSeg.getIntersection(nextSeg);\n        if (inter !== null) {\n          if (!prevSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, inter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n          if (!nextSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, inter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n      this.tree.delete(segment);\n    }\n    return newEvents;\n  }\n  /* Safely split a segment that is currently in the datastructures\n   * IE - a segment other than the one that is currently being processed. */\n  _splitSafely(seg, pt) {\n    this.tree.delete(seg);\n    const rightSE = seg.rightSE;\n    this.queue.delete(rightSE);\n    const newEvents = seg.split(pt);\n    newEvents.push(rightSE);\n    if (seg.consumedBy === void 0) this.tree.add(seg);\n    return newEvents;\n  }\n};\n\n// src/operation.ts\nvar Operation = class {\n  type;\n  numMultiPolys;\n  run(type, geom, moreGeoms) {\n    operation.type = type;\n    const multipolys = [new MultiPolyIn(geom, true)];\n    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n      multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n    }\n    operation.numMultiPolys = multipolys.length;\n    if (operation.type === \"difference\") {\n      const subject = multipolys[0];\n      let i = 1;\n      while (i < multipolys.length) {\n        if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;\n        else multipolys.splice(i, 1);\n      }\n    }\n    if (operation.type === \"intersection\") {\n      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n        const mpA = multipolys[i];\n        for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {\n          if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n        }\n      }\n    }\n    const queue = new SplayTreeSet3(SweepEvent.compare);\n    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n      const sweepEvents = multipolys[i].getSweepEvents();\n      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {\n        queue.add(sweepEvents[j]);\n      }\n    }\n    const sweepLine = new SweepLine(queue);\n    let evt = null;\n    if (queue.size != 0) {\n      evt = queue.first();\n      queue.delete(evt);\n    }\n    while (evt) {\n      const newEvents = sweepLine.process(evt);\n      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {\n        const evt2 = newEvents[i];\n        if (evt2.consumedBy === void 0) queue.add(evt2);\n      }\n      if (queue.size != 0) {\n        evt = queue.first();\n        queue.delete(evt);\n      } else {\n        evt = null;\n      }\n    }\n    precision.reset();\n    const ringsOut = RingOut.factory(sweepLine.segments);\n    const result = new MultiPolyOut(ringsOut);\n    return result.getGeom();\n  }\n};\nvar operation = new Operation();\nvar operation_default = operation;\n\n// src/segment.ts\nvar segmentId = 0;\nvar Segment = class _Segment {\n  id;\n  leftSE;\n  rightSE;\n  rings;\n  windings;\n  ringOut;\n  consumedBy;\n  prev;\n  _prevInResult;\n  _beforeState;\n  _afterState;\n  _isInResult;\n  /* This compare() function is for ordering segments in the sweep\n   * line tree, and does so according to the following criteria:\n   *\n   * Consider the vertical line that lies an infinestimal step to the\n   * right of the right-more of the two left endpoints of the input\n   * segments. Imagine slowly moving a point up from negative infinity\n   * in the increasing y direction. Which of the two segments will that\n   * point intersect first? That segment comes 'before' the other one.\n   *\n   * If neither segment would be intersected by such a line, (if one\n   * or more of the segments are vertical) then the line to be considered\n   * is directly on the right-more of the two left inputs.\n   */\n  static compare(a, b) {\n    const alx = a.leftSE.point.x;\n    const blx = b.leftSE.point.x;\n    const arx = a.rightSE.point.x;\n    const brx = b.rightSE.point.x;\n    if (brx.isLessThan(alx)) return 1;\n    if (arx.isLessThan(blx)) return -1;\n    const aly = a.leftSE.point.y;\n    const bly = b.leftSE.point.y;\n    const ary = a.rightSE.point.y;\n    const bry = b.rightSE.point.y;\n    if (alx.isLessThan(blx)) {\n      if (bly.isLessThan(aly) && bly.isLessThan(ary)) return 1;\n      if (bly.isGreaterThan(aly) && bly.isGreaterThan(ary)) return -1;\n      const aCmpBLeft = a.comparePoint(b.leftSE.point);\n      if (aCmpBLeft < 0) return 1;\n      if (aCmpBLeft > 0) return -1;\n      const bCmpARight = b.comparePoint(a.rightSE.point);\n      if (bCmpARight !== 0) return bCmpARight;\n      return -1;\n    }\n    if (alx.isGreaterThan(blx)) {\n      if (aly.isLessThan(bly) && aly.isLessThan(bry)) return -1;\n      if (aly.isGreaterThan(bly) && aly.isGreaterThan(bry)) return 1;\n      const bCmpALeft = b.comparePoint(a.leftSE.point);\n      if (bCmpALeft !== 0) return bCmpALeft;\n      const aCmpBRight = a.comparePoint(b.rightSE.point);\n      if (aCmpBRight < 0) return 1;\n      if (aCmpBRight > 0) return -1;\n      return 1;\n    }\n    if (aly.isLessThan(bly)) return -1;\n    if (aly.isGreaterThan(bly)) return 1;\n    if (arx.isLessThan(brx)) {\n      const bCmpARight = b.comparePoint(a.rightSE.point);\n      if (bCmpARight !== 0) return bCmpARight;\n    }\n    if (arx.isGreaterThan(brx)) {\n      const aCmpBRight = a.comparePoint(b.rightSE.point);\n      if (aCmpBRight < 0) return 1;\n      if (aCmpBRight > 0) return -1;\n    }\n    if (!arx.eq(brx)) {\n      const ay = ary.minus(aly);\n      const ax = arx.minus(alx);\n      const by = bry.minus(bly);\n      const bx = brx.minus(blx);\n      if (ay.isGreaterThan(ax) && by.isLessThan(bx)) return 1;\n      if (ay.isLessThan(ax) && by.isGreaterThan(bx)) return -1;\n    }\n    if (arx.isGreaterThan(brx)) return 1;\n    if (arx.isLessThan(brx)) return -1;\n    if (ary.isLessThan(bry)) return -1;\n    if (ary.isGreaterThan(bry)) return 1;\n    if (a.id < b.id) return -1;\n    if (a.id > b.id) return 1;\n    return 0;\n  }\n  /* Warning: a reference to ringWindings input will be stored,\n   *  and possibly will be later modified */\n  constructor(leftSE, rightSE, rings, windings) {\n    this.id = ++segmentId;\n    this.leftSE = leftSE;\n    leftSE.segment = this;\n    leftSE.otherSE = rightSE;\n    this.rightSE = rightSE;\n    rightSE.segment = this;\n    rightSE.otherSE = leftSE;\n    this.rings = rings;\n    this.windings = windings;\n  }\n  static fromRing(pt1, pt2, ring) {\n    let leftPt, rightPt, winding;\n    const cmpPts = SweepEvent.comparePoints(pt1, pt2);\n    if (cmpPts < 0) {\n      leftPt = pt1;\n      rightPt = pt2;\n      winding = 1;\n    } else if (cmpPts > 0) {\n      leftPt = pt2;\n      rightPt = pt1;\n      winding = -1;\n    } else\n      throw new Error(\n        `Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`\n      );\n    const leftSE = new SweepEvent(leftPt, true);\n    const rightSE = new SweepEvent(rightPt, false);\n    return new _Segment(leftSE, rightSE, [ring], [winding]);\n  }\n  /* When a segment is split, the rightSE is replaced with a new sweep event */\n  replaceRightSE(newRightSE) {\n    this.rightSE = newRightSE;\n    this.rightSE.segment = this;\n    this.rightSE.otherSE = this.leftSE;\n    this.leftSE.otherSE = this.rightSE;\n  }\n  bbox() {\n    const y1 = this.leftSE.point.y;\n    const y2 = this.rightSE.point.y;\n    return {\n      ll: { x: this.leftSE.point.x, y: y1.isLessThan(y2) ? y1 : y2 },\n      ur: { x: this.rightSE.point.x, y: y1.isGreaterThan(y2) ? y1 : y2 }\n    };\n  }\n  /* A vector from the left point to the right */\n  vector() {\n    return {\n      x: this.rightSE.point.x.minus(this.leftSE.point.x),\n      y: this.rightSE.point.y.minus(this.leftSE.point.y)\n    };\n  }\n  isAnEndpoint(pt) {\n    return pt.x.eq(this.leftSE.point.x) && pt.y.eq(this.leftSE.point.y) || pt.x.eq(this.rightSE.point.x) && pt.y.eq(this.rightSE.point.y);\n  }\n  /* Compare this segment with a point.\n   *\n   * A point P is considered to be colinear to a segment if there\n   * exists a distance D such that if we travel along the segment\n   * from one * endpoint towards the other a distance D, we find\n   * ourselves at point P.\n   *\n   * Return value indicates:\n   *\n   *   1: point lies above the segment (to the left of vertical)\n   *   0: point is colinear to segment\n   *  -1: point lies below the segment (to the right of vertical)\n   */\n  comparePoint(point) {\n    return precision.orient(this.leftSE.point, point, this.rightSE.point);\n  }\n  /**\n   * Given another segment, returns the first non-trivial intersection\n   * between the two segments (in terms of sweep line ordering), if it exists.\n   *\n   * A 'non-trivial' intersection is one that will cause one or both of the\n   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n   *\n   *   * endpoint of segA with endpoint of segB --> trivial\n   *   * endpoint of segA with point along segB --> non-trivial\n   *   * endpoint of segB with point along segA --> non-trivial\n   *   * point along segA with point along segB --> non-trivial\n   *\n   * If no non-trivial intersection exists, return null\n   * Else, return null.\n   */\n  getIntersection(other) {\n    const tBbox = this.bbox();\n    const oBbox = other.bbox();\n    const bboxOverlap = getBboxOverlap(tBbox, oBbox);\n    if (bboxOverlap === null) return null;\n    const tlp = this.leftSE.point;\n    const trp = this.rightSE.point;\n    const olp = other.leftSE.point;\n    const orp = other.rightSE.point;\n    const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n    const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n    const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n    const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;\n    if (touchesThisLSE && touchesOtherLSE) {\n      if (touchesThisRSE && !touchesOtherRSE) return trp;\n      if (!touchesThisRSE && touchesOtherRSE) return orp;\n      return null;\n    }\n    if (touchesThisLSE) {\n      if (touchesOtherRSE) {\n        if (tlp.x.eq(orp.x) && tlp.y.eq(orp.y)) return null;\n      }\n      return tlp;\n    }\n    if (touchesOtherLSE) {\n      if (touchesThisRSE) {\n        if (trp.x.eq(olp.x) && trp.y.eq(olp.y)) return null;\n      }\n      return olp;\n    }\n    if (touchesThisRSE && touchesOtherRSE) return null;\n    if (touchesThisRSE) return trp;\n    if (touchesOtherRSE) return orp;\n    const pt = intersection(tlp, this.vector(), olp, other.vector());\n    if (pt === null) return null;\n    if (!isInBbox(bboxOverlap, pt)) return null;\n    return precision.snap(pt);\n  }\n  /**\n   * Split the given segment into multiple segments on the given points.\n   *  * Each existing segment will retain its leftSE and a new rightSE will be\n   *    generated for it.\n   *  * A new segment will be generated which will adopt the original segment's\n   *    rightSE, and a new leftSE will be generated for it.\n   *  * If there are more than two points given to split on, new segments\n   *    in the middle will be generated with new leftSE and rightSE's.\n   *  * An array of the newly generated SweepEvents will be returned.\n   *\n   * Warning: input array of points is modified\n   */\n  split(point) {\n    const newEvents = [];\n    const alreadyLinked = point.events !== void 0;\n    const newLeftSE = new SweepEvent(point, true);\n    const newRightSE = new SweepEvent(point, false);\n    const oldRightSE = this.rightSE;\n    this.replaceRightSE(newRightSE);\n    newEvents.push(newRightSE);\n    newEvents.push(newLeftSE);\n    const newSeg = new _Segment(\n      newLeftSE,\n      oldRightSE,\n      this.rings.slice(),\n      this.windings.slice()\n    );\n    if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n      newSeg.swapEvents();\n    }\n    if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n      this.swapEvents();\n    }\n    if (alreadyLinked) {\n      newLeftSE.checkForConsuming();\n      newRightSE.checkForConsuming();\n    }\n    return newEvents;\n  }\n  /* Swap which event is left and right */\n  swapEvents() {\n    const tmpEvt = this.rightSE;\n    this.rightSE = this.leftSE;\n    this.leftSE = tmpEvt;\n    this.leftSE.isLeft = true;\n    this.rightSE.isLeft = false;\n    for (let i = 0, iMax = this.windings.length; i < iMax; i++) {\n      this.windings[i] *= -1;\n    }\n  }\n  /* Consume another segment. We take their rings under our wing\n   * and mark them as consumed. Use for perfectly overlapping segments */\n  consume(other) {\n    let consumer = this;\n    let consumee = other;\n    while (consumer.consumedBy) consumer = consumer.consumedBy;\n    while (consumee.consumedBy) consumee = consumee.consumedBy;\n    const cmp = _Segment.compare(consumer, consumee);\n    if (cmp === 0) return;\n    if (cmp > 0) {\n      const tmp = consumer;\n      consumer = consumee;\n      consumee = tmp;\n    }\n    if (consumer.prev === consumee) {\n      const tmp = consumer;\n      consumer = consumee;\n      consumee = tmp;\n    }\n    for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n      const ring = consumee.rings[i];\n      const winding = consumee.windings[i];\n      const index = consumer.rings.indexOf(ring);\n      if (index === -1) {\n        consumer.rings.push(ring);\n        consumer.windings.push(winding);\n      } else consumer.windings[index] += winding;\n    }\n    consumee.rings = null;\n    consumee.windings = null;\n    consumee.consumedBy = consumer;\n    consumee.leftSE.consumedBy = consumer.leftSE;\n    consumee.rightSE.consumedBy = consumer.rightSE;\n  }\n  /* The first segment previous segment chain that is in the result */\n  prevInResult() {\n    if (this._prevInResult !== void 0) return this._prevInResult;\n    if (!this.prev) this._prevInResult = null;\n    else if (this.prev.isInResult()) this._prevInResult = this.prev;\n    else this._prevInResult = this.prev.prevInResult();\n    return this._prevInResult;\n  }\n  beforeState() {\n    if (this._beforeState !== void 0) return this._beforeState;\n    if (!this.prev)\n      this._beforeState = {\n        rings: [],\n        windings: [],\n        multiPolys: []\n      };\n    else {\n      const seg = this.prev.consumedBy || this.prev;\n      this._beforeState = seg.afterState();\n    }\n    return this._beforeState;\n  }\n  afterState() {\n    if (this._afterState !== void 0) return this._afterState;\n    const beforeState = this.beforeState();\n    this._afterState = {\n      rings: beforeState.rings.slice(0),\n      windings: beforeState.windings.slice(0),\n      multiPolys: []\n    };\n    const ringsAfter = this._afterState.rings;\n    const windingsAfter = this._afterState.windings;\n    const mpsAfter = this._afterState.multiPolys;\n    for (let i = 0, iMax = this.rings.length; i < iMax; i++) {\n      const ring = this.rings[i];\n      const winding = this.windings[i];\n      const index = ringsAfter.indexOf(ring);\n      if (index === -1) {\n        ringsAfter.push(ring);\n        windingsAfter.push(winding);\n      } else windingsAfter[index] += winding;\n    }\n    const polysAfter = [];\n    const polysExclude = [];\n    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {\n      if (windingsAfter[i] === 0) continue;\n      const ring = ringsAfter[i];\n      const poly = ring.poly;\n      if (polysExclude.indexOf(poly) !== -1) continue;\n      if (ring.isExterior) polysAfter.push(poly);\n      else {\n        if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n        const index = polysAfter.indexOf(ring.poly);\n        if (index !== -1) polysAfter.splice(index, 1);\n      }\n    }\n    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {\n      const mp = polysAfter[i].multiPoly;\n      if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n    }\n    return this._afterState;\n  }\n  /* Is this segment part of the final result? */\n  isInResult() {\n    if (this.consumedBy) return false;\n    if (this._isInResult !== void 0) return this._isInResult;\n    const mpsBefore = this.beforeState().multiPolys;\n    const mpsAfter = this.afterState().multiPolys;\n    switch (operation_default.type) {\n      case \"union\": {\n        const noBefores = mpsBefore.length === 0;\n        const noAfters = mpsAfter.length === 0;\n        this._isInResult = noBefores !== noAfters;\n        break;\n      }\n      case \"intersection\": {\n        let least;\n        let most;\n        if (mpsBefore.length < mpsAfter.length) {\n          least = mpsBefore.length;\n          most = mpsAfter.length;\n        } else {\n          least = mpsAfter.length;\n          most = mpsBefore.length;\n        }\n        this._isInResult = most === operation_default.numMultiPolys && least < most;\n        break;\n      }\n      case \"xor\": {\n        const diff = Math.abs(mpsBefore.length - mpsAfter.length);\n        this._isInResult = diff % 2 === 1;\n        break;\n      }\n      case \"difference\": {\n        const isJustSubject = (mps) => mps.length === 1 && mps[0].isSubject;\n        this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n        break;\n      }\n    }\n    return this._isInResult;\n  }\n};\n\n// src/geom-in.ts\nvar RingIn = class {\n  poly;\n  isExterior;\n  segments;\n  bbox;\n  constructor(geomRing, poly, isExterior) {\n    if (!Array.isArray(geomRing) || geomRing.length === 0) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    this.poly = poly;\n    this.isExterior = isExterior;\n    this.segments = [];\n    if (typeof geomRing[0][0] !== \"number\" || typeof geomRing[0][1] !== \"number\") {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    const firstPoint = precision.snap({ x: new BigNumber2(geomRing[0][0]), y: new BigNumber2(geomRing[0][1]) });\n    this.bbox = {\n      ll: { x: firstPoint.x, y: firstPoint.y },\n      ur: { x: firstPoint.x, y: firstPoint.y }\n    };\n    let prevPoint = firstPoint;\n    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {\n      if (typeof geomRing[i][0] !== \"number\" || typeof geomRing[i][1] !== \"number\") {\n        throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n      }\n      const point = precision.snap({ x: new BigNumber2(geomRing[i][0]), y: new BigNumber2(geomRing[i][1]) });\n      if (point.x.eq(prevPoint.x) && point.y.eq(prevPoint.y)) continue;\n      this.segments.push(Segment.fromRing(prevPoint, point, this));\n      if (point.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = point.x;\n      if (point.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = point.y;\n      if (point.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = point.x;\n      if (point.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = point.y;\n      prevPoint = point;\n    }\n    if (!firstPoint.x.eq(prevPoint.x) || !firstPoint.y.eq(prevPoint.y)) {\n      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n    }\n  }\n  getSweepEvents() {\n    const sweepEvents = [];\n    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {\n      const segment = this.segments[i];\n      sweepEvents.push(segment.leftSE);\n      sweepEvents.push(segment.rightSE);\n    }\n    return sweepEvents;\n  }\n};\nvar PolyIn = class {\n  multiPoly;\n  exteriorRing;\n  interiorRings;\n  bbox;\n  constructor(geomPoly, multiPoly) {\n    if (!Array.isArray(geomPoly)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    this.exteriorRing = new RingIn(geomPoly[0], this, true);\n    this.bbox = {\n      ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },\n      ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y }\n    };\n    this.interiorRings = [];\n    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      const ring = new RingIn(geomPoly[i], this, false);\n      if (ring.bbox.ll.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = ring.bbox.ll.x;\n      if (ring.bbox.ll.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = ring.bbox.ll.y;\n      if (ring.bbox.ur.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = ring.bbox.ur.x;\n      if (ring.bbox.ur.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = ring.bbox.ur.y;\n      this.interiorRings.push(ring);\n    }\n    this.multiPoly = multiPoly;\n  }\n  getSweepEvents() {\n    const sweepEvents = this.exteriorRing.getSweepEvents();\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringSweepEvents = this.interiorRings[i].getSweepEvents();\n      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(ringSweepEvents[j]);\n      }\n    }\n    return sweepEvents;\n  }\n};\nvar MultiPolyIn = class {\n  isSubject;\n  polys;\n  bbox;\n  constructor(geom, isSubject) {\n    if (!Array.isArray(geom)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    try {\n      if (typeof geom[0][0][0] === \"number\") geom = [geom];\n    } catch (ex) {\n    }\n    this.polys = [];\n    this.bbox = {\n      ll: { x: new BigNumber2(Number.POSITIVE_INFINITY), y: new BigNumber2(Number.POSITIVE_INFINITY) },\n      ur: { x: new BigNumber2(Number.NEGATIVE_INFINITY), y: new BigNumber2(Number.NEGATIVE_INFINITY) }\n    };\n    for (let i = 0, iMax = geom.length; i < iMax; i++) {\n      const poly = new PolyIn(geom[i], this);\n      if (poly.bbox.ll.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = poly.bbox.ll.x;\n      if (poly.bbox.ll.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = poly.bbox.ll.y;\n      if (poly.bbox.ur.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = poly.bbox.ur.x;\n      if (poly.bbox.ur.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = poly.bbox.ur.y;\n      this.polys.push(poly);\n    }\n    this.isSubject = isSubject;\n  }\n  getSweepEvents() {\n    const sweepEvents = [];\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polySweepEvents = this.polys[i].getSweepEvents();\n      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(polySweepEvents[j]);\n      }\n    }\n    return sweepEvents;\n  }\n};\n\n// src/index.ts\nvar union = (geom, ...moreGeoms) => operation_default.run(\"union\", geom, moreGeoms);\nvar intersection2 = (geom, ...moreGeoms) => operation_default.run(\"intersection\", geom, moreGeoms);\nvar xor = (geom, ...moreGeoms) => operation_default.run(\"xor\", geom, moreGeoms);\nvar difference = (geom, ...moreGeoms) => operation_default.run(\"difference\", geom, moreGeoms);\nvar setPrecision = precision.set;\nexport {\n  difference,\n  intersection2 as intersection,\n  setPrecision,\n  union,\n  xor\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport * as polyclip from \"polyclip-ts\";\nimport { polygon, multiPolygon } from \"@turf/helpers\";\nimport { geomEach } from \"@turf/meta\";\nfunction difference2(features) {\n  const geoms = [];\n  geomEach(features, (geom) => {\n    geoms.push(geom.coordinates);\n  });\n  if (geoms.length < 2) {\n    throw new Error(\"Must have at least two features\");\n  }\n  const properties = features.features[0].properties || {};\n  const differenced = polyclip.difference(geoms[0], ...geoms.slice(1));\n  if (differenced.length === 0) return null;\n  if (differenced.length === 1) return polygon(differenced[0], properties);\n  return multiPolygon(differenced, properties);\n}\nvar turf_difference_default = difference2;\nexport {\n  turf_difference_default as default,\n  difference2 as difference\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { feature, point, lineString, isObject } from \"@turf/helpers\";\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  if (geojson === null) return;\n  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === \"FeatureCollection\", isFeature = type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(\n            coords,\n            coordIndex,\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(\n              coords[j],\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false)\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(\n                coords[j][k],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false)\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(\n                  coords[j][k][l],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false)\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (coordIndex === 0 && initialValue === void 0)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function(currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function(currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function(coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\nfunction geomEach(geojson, callback) {\n  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === \"FeatureCollection\", isFeature = geojson.type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      if (geometry === null) {\n        if (callback(\n          null,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        ) === false)\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (callback(\n            geometry,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false)\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (callback(\n              geometry.geometries[j],\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false)\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    featureIndex++;\n  }\n}\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(\n          feature(geometry, properties, { bbox, id }),\n          featureIndex,\n          0\n        ) === false)\n          return false;\n        return;\n    }\n    var geomType;\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)\n        return false;\n    }\n  });\n}\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function(currentFeature, featureIndex, multiFeatureIndex) {\n      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n    if (!feature2.geometry) return;\n    var type = feature2.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(\n      feature2,\n      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n          previousCoords = currentCoord;\n          previousFeatureIndex = featureIndex;\n          previousMultiIndex = multiPartIndexCoord;\n          prevGeomIndex = geometryIndex;\n          segmentIndex = 0;\n          return;\n        }\n        var currentSegment = lineString(\n          [previousCoords, currentCoord],\n          feature2.properties\n        );\n        if (callback(\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        ) === false)\n          return false;\n        segmentIndex++;\n        previousCoords = currentCoord;\n      }\n    ) === false)\n      return false;\n  });\n}\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n      if (started === false && initialValue === void 0)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\nfunction lineEach(geojson, callback) {\n  if (!geojson) throw new Error(\"geojson is required\");\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    if (feature2.geometry === null) return;\n    var type = feature2.geometry.type;\n    var coords = feature2.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(\n            lineString(coords[geometryIndex], feature2.properties),\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n        }\n        break;\n    }\n  });\n}\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction findSegment(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nfunction findPoint(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nexport {\n  coordAll,\n  coordEach,\n  coordReduce,\n  featureEach,\n  featureReduce,\n  findPoint,\n  findSegment,\n  flattenEach,\n  flattenReduce,\n  geomEach,\n  geomReduce,\n  lineEach,\n  lineReduce,\n  propEach,\n  propReduce,\n  segmentEach,\n  segmentReduce\n};\n//# sourceMappingURL=index.js.map","export const modeName = \"split_polygon\";\n\n/// This mode uses the `mapbox-gl-draw-passing-mode` mode to draw the spilitting lineString.\n/// here is the name used to add that mode:\nexport const passingModeName = `${modeName}_passing_draw_line_string`;\n\n/// when a (multi-)polygon feature is selected to be splitted, it gets highlighted.\n/// here is the name of the property indicating the highlight.\nexport const highlightPropertyName = `${modeName}_highlight`;\n\nexport const defaultOptions = {\n  highlightColor: \"#222\",\n  lineWidth: 0,\n  lineWidthUnit: \"kilometers\",\n  onSelectFeatureRequest() {\n    throw new Error(\"no Feature is selected to split.\");\n  },\n};\n\nexport const splitPolygonModeEvents = {\n  SPLIT_POLYGON_MODE_STOP: 'draw:split_polygon_mode:stop',\n  SPLIT_POLYGON_MORE_THAN_TWO_POLYGONS: 'draw:split_polygon_mode:more_than_two_polygons',\n}","import { flattenEach } from '@turf/turf';\n\n/**\n * Extract all polygons from a Feature or geometry object.\n * @param {GeoJSON.Feature<GeoJSON.Polygon|GeoJSON.MultiPolygon>} feature\n * @returns {GeoJSON.Feature<GeoJSON.Polygon>[]} Array of polygon features\n */\nfunction extractPolygons(feature) {\n    const polygons = [];\n  \n    flattenEach(feature, (polyFeature) => {\n      if (polyFeature.geometry.type === 'Polygon') {\n        polygons.push(polyFeature);\n      }\n    });\n  \n    return polygons;\n  }\n\nexport { extractPolygons };","import polygonSplitter from \"polygon-splitter\";\n\nimport { geojsonTypes, events } from \"@mapbox/mapbox-gl-draw/src/constants\";\n\nimport lineIntersect from \"@turf/line-intersect\";\nimport booleanDisjoint from \"@turf/boolean-disjoint\";\nimport lineOffset from \"@turf/line-offset\";\nimport lineToPolygon from \"@turf/line-to-polygon\";\nimport difference from \"@turf/difference\";\nimport { lineString } from \"@turf/helpers\";\n\nimport {\n  modeName,\n  passingModeName,\n  highlightPropertyName,\n  defaultOptions,\n  splitPolygonModeEvents,\n} from \"./constants\";\nimport { extractPolygons } from \"./utils\";\n\nconst SplitPolygonMode = {};\n\nSplitPolygonMode.onSetup = function (opt) {\n  const {\n    featureIds = [],\n    highlightColor = defaultOptions.highlightColor,\n    lineWidth = defaultOptions.lineWidth,\n    lineWidthUnit = defaultOptions.lineWidthUnit,\n    onSelectFeatureRequest = defaultOptions.onSelectFeatureRequest,\n  } = opt || {};\n\n  const api = this._ctx.api;\n\n  const featuresToSplit = [];\n  const selectedFeatures = this.getSelected();\n\n  if (featureIds.length !== 0) {\n    featuresToSplit.push.apply(\n      featuresToSplit,\n      featureIds.map((id) => api.get(id))\n    );\n  } else if (selectedFeatures.length !== 0) {\n    featuresToSplit.push.apply(\n      featuresToSplit,\n      selectedFeatures\n        .filter(\n          (f) =>\n            f.type === geojsonTypes.POLYGON ||\n            f.type === geojsonTypes.MULTI_POLYGON\n        )\n        .map((f) => f.toGeoJSON())\n    );\n  } else {\n    return onSelectFeatureRequest();\n  }\n\n  const state = {\n    options: {\n      highlightColor,\n      lineWidth,\n      lineWidthUnit,\n    },\n    featuresToSplit,\n    api,\n  };\n\n  /// `onSetup` job should complete for this mode to work.\n  /// so `setTimeout` is used to bupass mode change after `onSetup` is done executing.\n  setTimeout(this.drawAndSplit.bind(this, state), 0);\n  this.highlighFeatures(state);\n\n  return state;\n};\n\nSplitPolygonMode.drawAndSplit = function (state) {\n  const { api, options } = state;\n  const { lineWidth, lineWidthUnit } = options;\n\n  try {\n    this.changeMode(passingModeName, {\n      onDraw: (cuttingLineString) => {\n        const newPolygons = [];\n        let isInvalidLine = false;\n\n        if (!cuttingLineString) {\n          isInvalidLine = true;\n        }\n        \n        \n        state.featuresToSplit.forEach((el) => {\n          try {\n            if (booleanDisjoint(el, cuttingLineString)) {\n              isInvalidLine = true;\n              return;\n            }\n            const intersects = lineIntersect(el, cuttingLineString);\n            if (intersects.features.length === 0) {\n              isInvalidLine = true;\n              return;\n            }\n            if (lineWidth === 0) {\n              const polycut = polygonCut(el.geometry, cuttingLineString.geometry);\n              polycut.id = el.id;\n              api.add(polycut);\n              newPolygons.push(polycut);\n            } else {\n              const polycut = polygonCutWithSpacing(\n                el.geometry,\n                cuttingLineString.geometry,\n                {\n                  line_width: lineWidth,\n                  line_width_unit: lineWidthUnit,\n                }\n              );\n              polycut.id = el.id;\n              api.add(polycut);\n              newPolygons.push(polycut);\n            }\n          } catch (error) {\n            console.error(\"Error processing polygon split:\", error);\n          }\n        });\n        \n        this.fireUpdate(newPolygons);\n        this.highlighFeatures(state, false);\n        \n        if (isInvalidLine || newPolygons.length !== 1 || (newPolygons[0].geometry?.type === 'MultiPolygon' && newPolygons[0].geometry?.coordinates?.length !== 2)) {\n          this.map.fire(splitPolygonModeEvents.SPLIT_POLYGON_MORE_THAN_TWO_POLYGONS, {\n            newPolygons,\n          });\n        }\n\n        let numberOfPolygons = 0;\n        if (!isInvalidLine && newPolygons.length !== 0) {\n            numberOfPolygons = extractPolygons(newPolygons[0]).length;\n        }\n\n        console.log(numberOfPolygons, 'numberOfPolygons');\n\n      },\n      onCancel: () => {\n        this.highlighFeatures(state, false);\n        this.map.fire(splitPolygonModeEvents.SPLIT_POLYGON_MODE_STOP);\n      },\n    });\n  } catch (err) {\n    console.error(\" ~ file: mode.js ~ line 118 ~ err\", err);\n  }\n};\n\nSplitPolygonMode.highlighFeatures = function (state, shouldHighlight = true) {\n  const color = shouldHighlight ? state.options.highlightColor : undefined;\n\n  state.featuresToSplit.forEach((f) => {\n    state.api.setFeatureProperty(f.id, highlightPropertyName, color);\n  });\n};\n\nSplitPolygonMode.toDisplayFeatures = function (state, geojson, display) {\n  display(geojson);\n};\n\nSplitPolygonMode.fireUpdate = function (newF) {\n  this.map.fire(events.UPDATE, {\n    action: modeName,\n    features: newF,\n  });\n};\n\nexport default SplitPolygonMode;\n\n/// Note: currently has some issues, but generally is a better approach\nfunction polygonCut(poly, line) {\n  return polygonSplitter(poly, line);\n}\n\n/// Adopted from https://gis.stackexchange.com/a/344277/145409\nfunction polygonCutWithSpacing(poly, line, options) {\n  const { line_width, line_width_unit } = options || {};\n\n  const offsetLine = [];\n  const retVal = null;\n  let i, j, intersectPoints, forCut, forSelect;\n  let thickLineString, thickLinePolygon, clipped;\n\n  if (\n    typeof line_width === \"undefined\" ||\n    typeof line_width_unit === \"undefined\" ||\n    (poly.type != geojsonTypes.POLYGON &&\n      poly.type != geojsonTypes.MULTI_POLYGON) ||\n    line.type != geojsonTypes.LINE_STRING\n  ) {\n    return retVal;\n  }\n\n  /// if line and polygon don't intersect return.\n  if (booleanDisjoint(line, poly)) {\n    return retVal;\n  }\n\n  intersectPoints = lineIntersect(poly, line);\n  if (intersectPoints.features.length === 0) {\n    return retVal;\n  }\n\n  /// Creating two new lines at sides of the splitting lineString\n  offsetLine[0] = lineOffset(line, line_width, {\n    units: line_width_unit,\n  });\n  offsetLine[1] = lineOffset(line, -line_width, {\n    units: line_width_unit,\n  });\n\n  for (i = 0; i <= 1; i++) {\n    forCut = i;\n    forSelect = (i + 1) % 2;\n    const polyCoords = [];\n    for (j = 0; j < line.coordinates.length; j++) {\n      polyCoords.push(line.coordinates[j]);\n    }\n    for (j = offsetLine[forCut].geometry.coordinates.length - 1; j >= 0; j--) {\n      polyCoords.push(offsetLine[forCut].geometry.coordinates[j]);\n    }\n    polyCoords.push(line.coordinates[0]);\n\n    thickLineString = lineString(polyCoords);\n    thickLinePolygon = lineToPolygon(thickLineString);\n    clipped = difference(poly, thickLinePolygon);\n  }\n\n  return clipped;\n}\n","import {\n  modeName,\n  highlightPropertyName as _highlightPropertyName,\n} from \"./constants\";\n\nconst highlightPropertyName = `user_${_highlightPropertyName}`;\n\nconst customDrawStyles = (defaultStyle) =>\n  defaultStyle\n    .map((style) => {\n      if (style.id.endsWith(\"inactive\")) {\n        return {\n          ...style,\n          /// here \"!has\" is used cause the gl-draw supported that instead of ['!', ['has', ...]]\n          filter: [...style.filter, [\"!has\", highlightPropertyName]],\n        };\n      }\n\n      return style;\n    })\n    .concat([\n      {\n        id: `${modeName}-fill-active`,\n        type: \"fill\",\n        filter: [\n          \"all\",\n          [\"==\", \"active\", \"false\"],\n          [\"==\", \"$type\", \"Polygon\"],\n          [\"has\", highlightPropertyName],\n        ],\n        paint: {\n          \"fill-color\": [\"get\", highlightPropertyName],\n          \"fill-outline-color\": [\"get\", highlightPropertyName],\n          \"fill-opacity\": 0.1,\n        },\n      },\n      {\n        id: `${modeName}-stroke-active`,\n        type: \"line\",\n        filter: [\n          \"all\",\n          [\"==\", \"active\", \"false\"],\n          [\"==\", \"$type\", \"Polygon\"],\n          [\"has\", highlightPropertyName],\n        ],\n        layout: {\n          \"line-cap\": \"round\",\n          \"line-join\": \"round\",\n        },\n        paint: {\n          \"line-color\": [\"get\", highlightPropertyName],\n          \"line-dasharray\": [0.2, 2],\n          \"line-width\": 2,\n        },\n      },\n    ]);\n\nexport default customDrawStyles;\n","import * as Constants from '../constants';\n\nexport function isOfMetaType(type) {\n  return function(e) {\n    const featureTarget = e.featureTarget;\n    if (!featureTarget) return false;\n    if (!featureTarget.properties) return false;\n    return featureTarget.properties.meta === type;\n  };\n}\n\nexport function isShiftMousedown(e) {\n  if (!e.originalEvent) return false;\n  if (!e.originalEvent.shiftKey) return false;\n  return e.originalEvent.button === 0;\n}\n\nexport function isActiveFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.active === Constants.activeStates.ACTIVE &&\n    e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function isInactiveFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.active === Constants.activeStates.INACTIVE &&\n    e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function noTarget(e) {\n  return e.featureTarget === undefined;\n}\n\nexport function isFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function isVertex(e) {\n  const featureTarget = e.featureTarget;\n  if (!featureTarget) return false;\n  if (!featureTarget.properties) return false;\n  return featureTarget.properties.meta === Constants.meta.VERTEX;\n}\n\nexport function isShiftDown(e) {\n  if (!e.originalEvent) return false;\n  return e.originalEvent.shiftKey === true;\n}\n\nexport function isEscapeKey(e) {\n  return e.keyCode === 27;\n}\n\nexport function isEnterKey(e) {\n  return e.keyCode === 13;\n}\n\nexport function isTrue() {\n  return true;\n}\n","import * as CommonSelectors from '../lib/common_selectors';\nimport * as Constants from '../constants';\n\nconst DrawPoint = {};\n\nDrawPoint.onSetup = function() {\n  const point = this.newFeature({\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: Constants.geojsonTypes.POINT,\n      coordinates: []\n    }\n  });\n\n  this.addFeature(point);\n\n  this.clearSelectedFeatures();\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.activateUIButton(Constants.types.POINT);\n\n  this.setActionableState({\n    trash: true\n  });\n\n  return { point };\n};\n\nDrawPoint.stopDrawingAndRemove = function(state) {\n  this.deleteFeature([state.point.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nDrawPoint.onTap = DrawPoint.onClick = function(state, e) {\n  this.updateUIClasses({ mouse: Constants.cursors.MOVE });\n  state.point.updateCoordinate('', e.lngLat.lng, e.lngLat.lat);\n  this.map.fire(Constants.events.CREATE, {\n    features: [state.point.toGeoJSON()]\n  });\n  this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.point.id] });\n};\n\nDrawPoint.onStop = function(state) {\n  this.activateUIButton();\n  if (!state.point.getCoordinate().length) {\n    this.deleteFeature([state.point.id], { silent: true });\n  }\n};\n\nDrawPoint.toDisplayFeatures = function(state, geojson, display) {\n  // Never render the point we're drawing\n  const isActivePoint = geojson.properties.id === state.point.id;\n  geojson.properties.active = (isActivePoint) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  if (!isActivePoint) return display(geojson);\n};\n\nDrawPoint.onTrash = DrawPoint.stopDrawingAndRemove;\n\nDrawPoint.onKeyUp = function(state, e) {\n  if (CommonSelectors.isEscapeKey(e) || CommonSelectors.isEnterKey(e)) {\n    return this.stopDrawingAndRemove(state, e);\n  }\n};\n\nexport default DrawPoint;\n","import draw_point from \"@mapbox/mapbox-gl-draw/src/modes/draw_point\";\nimport * as Constants from \"@mapbox/mapbox-gl-draw/src/constants\";\n\nconst {\n  onSetup: originOnSetup,\n  onClick: originOnClick,\n  ...restOriginMethods\n} = draw_point;\n\nconst passing_draw_point = {\n  originOnSetup,\n  originOnClick,\n  ...restOriginMethods,\n};\n\npassing_draw_point.onSetup = function (opt) {\n  const state = this.originOnSetup();\n  const { onDraw, onCancel } = opt;\n  state.onDraw = onDraw;\n  state.onCancel = onCancel;\n  return state;\n};\n\npassing_draw_point.onTap = passing_draw_point.onClick = function (state, e) {\n  this.updateUIClasses({ mouse: Constants.cursors.MOVE });\n  state.point.updateCoordinate(\"\", e.lngLat.lng, e.lngLat.lat);\n\n  if (typeof state.onDraw === \"function\") state.onDraw(state.point.toGeoJSON());\n  else\n    this.map.fire(\"draw.passing-create\", {\n      features: [state.point.toGeoJSON()],\n    });\n\n  this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n};\n\npassing_draw_point.onMouseMove = function (state, e) {\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  state.point.updateCoordinate(e.lngLat.lng, e.lngLat.lat);\n};\n\npassing_draw_point.onStop = function (state) {\n  const f = state.point;\n\n  /// check to see if we've deleted this feature\n  const drawnFeature = this.getFeature(f.id);\n  if (drawnFeature === undefined) {\n    /// Call `onCancel` if exists.\n    if (typeof state.onCancel === \"function\") state.onCancel();\n    return;\n  }\n\n  this.activateUIButton();\n  this.deleteFeature([state.point.id], { silent: true });\n};\n\nexport default passing_draw_point;\n","function isEventAtCoordinates(event, coordinates) {\n  if (!event.lngLat) return false;\n  return event.lngLat.lng === coordinates[0] && event.lngLat.lat === coordinates[1];\n}\n\nexport default isEventAtCoordinates;\n","export default {\n  enable(ctx) {\n    setTimeout(() => {\n      // First check we've got a map and some context.\n      if (!ctx.map || !ctx.map.doubleClickZoom || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue) return;\n      // Now check initial state wasn't false (we leave it disabled if so)\n      if (!ctx._ctx.store.getInitialConfigValue('doubleClickZoom')) return;\n      ctx.map.doubleClickZoom.enable();\n    }, 0);\n  },\n  disable(ctx) {\n    setTimeout(() => {\n      if (!ctx.map || !ctx.map.doubleClickZoom) return;\n      // Always disable here, as it's necessary in some cases.\n      ctx.map.doubleClickZoom.disable();\n    }, 0);\n  }\n};\n","import * as Constants from '../constants';\n\n/**\n * Returns GeoJSON for a Point representing the\n * vertex of another feature.\n *\n * @param {string} parentId\n * @param {Array<number>} coordinates\n * @param {string} path - Dot-separated numbers indicating exactly\n *   where the point exists within its parent feature's coordinates.\n * @param {boolean} selected\n * @return {GeoJSON} Point\n */\nexport default function(parentId, coordinates, path, selected) {\n  return {\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {\n      meta: Constants.meta.VERTEX,\n      parent: parentId,\n      coord_path: path,\n      active: (selected) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE\n    },\n    geometry: {\n      type: Constants.geojsonTypes.POINT,\n      coordinates\n    }\n  };\n}\n","import * as CommonSelectors from '../lib/common_selectors';\nimport isEventAtCoordinates from '../lib/is_event_at_coordinates';\nimport doubleClickZoom from '../lib/double_click_zoom';\nimport * as Constants from '../constants';\nimport createVertex from '../lib/create_vertex';\n\nconst DrawLineString = {};\n\nDrawLineString.onSetup = function(opts) {\n  opts = opts || {};\n  const featureId = opts.featureId;\n\n  let line, currentVertexPosition;\n  let direction = 'forward';\n  if (featureId) {\n    line = this.getFeature(featureId);\n    if (!line) {\n      throw new Error('Could not find a feature with the provided featureId');\n    }\n    let from = opts.from;\n    if (from && from.type === 'Feature' && from.geometry && from.geometry.type === 'Point') {\n      from = from.geometry;\n    }\n    if (from && from.type === 'Point' && from.coordinates && from.coordinates.length === 2) {\n      from = from.coordinates;\n    }\n    if (!from || !Array.isArray(from)) {\n      throw new Error('Please use the `from` property to indicate which point to continue the line from');\n    }\n    const lastCoord = line.coordinates.length - 1;\n    if (line.coordinates[lastCoord][0] === from[0] && line.coordinates[lastCoord][1] === from[1]) {\n      currentVertexPosition = lastCoord + 1;\n      // add one new coordinate to continue from\n      line.addCoordinate(currentVertexPosition, ...line.coordinates[lastCoord]);\n    } else if (line.coordinates[0][0] === from[0] && line.coordinates[0][1] === from[1]) {\n      direction = 'backwards';\n      currentVertexPosition = 0;\n      // add one new coordinate to continue from\n      line.addCoordinate(currentVertexPosition, ...line.coordinates[0]);\n    } else {\n      throw new Error('`from` should match the point at either the start or the end of the provided LineString');\n    }\n  } else {\n    line = this.newFeature({\n      type: Constants.geojsonTypes.FEATURE,\n      properties: {},\n      geometry: {\n        type: Constants.geojsonTypes.LINE_STRING,\n        coordinates: []\n      }\n    });\n    currentVertexPosition = 0;\n    this.addFeature(line);\n  }\n\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.activateUIButton(Constants.types.LINE);\n  this.setActionableState({\n    trash: true\n  });\n\n  return {\n    line,\n    currentVertexPosition,\n    direction\n  };\n};\n\nDrawLineString.clickAnywhere = function(state, e) {\n  if (state.currentVertexPosition > 0 && isEventAtCoordinates(e, state.line.coordinates[state.currentVertexPosition - 1]) ||\n      state.direction === 'backwards' && isEventAtCoordinates(e, state.line.coordinates[state.currentVertexPosition + 1])) {\n    return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });\n  }\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);\n  if (state.direction === 'forward') {\n    state.currentVertexPosition++;\n    state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);\n  } else {\n    state.line.addCoordinate(0, e.lngLat.lng, e.lngLat.lat);\n  }\n};\n\nDrawLineString.clickOnVertex = function(state) {\n  return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });\n};\n\nDrawLineString.onMouseMove = function(state, e) {\n  state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);\n  if (CommonSelectors.isVertex(e)) {\n    this.updateUIClasses({ mouse: Constants.cursors.POINTER });\n  }\n};\n\nDrawLineString.onTap = DrawLineString.onClick = function(state, e) {\n  if (CommonSelectors.isVertex(e)) return this.clickOnVertex(state, e);\n  this.clickAnywhere(state, e);\n};\n\nDrawLineString.onKeyUp = function(state, e) {\n  if (CommonSelectors.isEnterKey(e)) {\n    this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });\n  } else if (CommonSelectors.isEscapeKey(e)) {\n    this.deleteFeature([state.line.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT);\n  }\n};\n\nDrawLineString.onStop = function(state) {\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  // check to see if we've deleted this feature\n  if (this.getFeature(state.line.id) === undefined) return;\n\n  //remove last added coordinate\n  state.line.removeCoordinate(`${state.currentVertexPosition}`);\n  if (state.line.isValid()) {\n    this.map.fire(Constants.events.CREATE, {\n      features: [state.line.toGeoJSON()]\n    });\n  } else {\n    this.deleteFeature([state.line.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n  }\n};\n\nDrawLineString.onTrash = function(state) {\n  this.deleteFeature([state.line.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nDrawLineString.toDisplayFeatures = function(state, geojson, display) {\n  const isActiveLine = geojson.properties.id === state.line.id;\n  geojson.properties.active = (isActiveLine) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  if (!isActiveLine) return display(geojson);\n  // Only render the line if it has at least one real coordinate\n  if (geojson.geometry.coordinates.length < 2) return;\n  geojson.properties.meta = Constants.meta.FEATURE;\n  display(createVertex(\n    state.line.id,\n    geojson.geometry.coordinates[state.direction === 'forward' ? geojson.geometry.coordinates.length - 2 : 1],\n    `${state.direction === 'forward' ? geojson.geometry.coordinates.length - 2 : 1}`,\n    false\n  ));\n\n  display(geojson);\n};\n\nexport default DrawLineString;\n","import draw_line_string from \"@mapbox/mapbox-gl-draw/src/modes/draw_line_string\";\nimport doubleClickZoom from \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\";\nimport * as Constants from \"@mapbox/mapbox-gl-draw/src/constants\";\n\nconst {\n  onSetup: originOnSetup,\n  onMouseMove: originOnMouseMove,\n  ...restOriginMethods\n} = draw_line_string;\n\nconst passing_draw_line_string = {\n  originOnSetup,\n  originOnMouseMove,\n  ...restOriginMethods,\n};\n\npassing_draw_line_string.onSetup = function (opt) {\n  const state = this.originOnSetup();\n  const { onDraw, onCancel } = opt;\n  state.onDraw = onDraw;\n  state.onCancel = onCancel;\n  return state;\n};\n\npassing_draw_line_string.onMouseMove = function (state, e) {\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.originOnMouseMove(state, e);\n};\n\npassing_draw_line_string.onStop = function (state) {\n  const f = state.line;\n\n  this.updateUIClasses({ mouse: Constants.cursors.NONE });\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  /// check to see if we've deleted this feature\n  const drawnFeature = this.getFeature(f.id);\n  if (drawnFeature === undefined) {\n    /// Call `onCancel` if exists.\n    if (typeof state.onCancel === \"function\") state.onCancel();\n    return;\n  }\n  /// remove last added coordinate\n  else f.removeCoordinate(`${state.currentVertexPosition}`);\n\n  if (f.isValid()) {\n    if (typeof state.onDraw === \"function\") state.onDraw(f.toGeoJSON());\n    else\n      this.map.fire(\"draw.passing-create\", {\n        features: [f.toGeoJSON()],\n      });\n  }\n  this.deleteFeature([f.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n};\n\nexport default passing_draw_line_string;\n","import * as CommonSelectors from '../lib/common_selectors';\nimport doubleClickZoom from '../lib/double_click_zoom';\nimport * as Constants from '../constants';\nimport isEventAtCoordinates from '../lib/is_event_at_coordinates';\nimport createVertex from '../lib/create_vertex';\n\nconst DrawPolygon = {};\n\nDrawPolygon.onSetup = function() {\n  const polygon = this.newFeature({\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: Constants.geojsonTypes.POLYGON,\n      coordinates: [[]]\n    }\n  });\n\n  this.addFeature(polygon);\n\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.activateUIButton(Constants.types.POLYGON);\n  this.setActionableState({\n    trash: true\n  });\n\n  return {\n    polygon,\n    currentVertexPosition: 0\n  };\n};\n\nDrawPolygon.clickAnywhere = function(state, e) {\n  if (state.currentVertexPosition > 0 && isEventAtCoordinates(e, state.polygon.coordinates[0][state.currentVertexPosition - 1])) {\n    return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });\n  }\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);\n  state.currentVertexPosition++;\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);\n};\n\nDrawPolygon.clickOnVertex = function(state) {\n  return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });\n};\n\nDrawPolygon.onMouseMove = function(state, e) {\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);\n  if (CommonSelectors.isVertex(e)) {\n    this.updateUIClasses({ mouse: Constants.cursors.POINTER });\n  }\n};\n\nDrawPolygon.onTap = DrawPolygon.onClick = function(state, e) {\n  if (CommonSelectors.isVertex(e)) return this.clickOnVertex(state, e);\n  return this.clickAnywhere(state, e);\n};\n\nDrawPolygon.onKeyUp = function(state, e) {\n  if (CommonSelectors.isEscapeKey(e)) {\n    this.deleteFeature([state.polygon.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT);\n  } else if (CommonSelectors.isEnterKey(e)) {\n    this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });\n  }\n};\n\nDrawPolygon.onStop = function(state) {\n  this.updateUIClasses({ mouse: Constants.cursors.NONE });\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  // check to see if we've deleted this feature\n  if (this.getFeature(state.polygon.id) === undefined) return;\n\n  //remove last added coordinate\n  state.polygon.removeCoordinate(`0.${state.currentVertexPosition}`);\n  if (state.polygon.isValid()) {\n    this.map.fire(Constants.events.CREATE, {\n      features: [state.polygon.toGeoJSON()]\n    });\n  } else {\n    this.deleteFeature([state.polygon.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n  }\n};\n\nDrawPolygon.toDisplayFeatures = function(state, geojson, display) {\n  const isActivePolygon = geojson.properties.id === state.polygon.id;\n  geojson.properties.active = (isActivePolygon) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  if (!isActivePolygon) return display(geojson);\n\n  // Don't render a polygon until it has two positions\n  // (and a 3rd which is just the first repeated)\n  if (geojson.geometry.coordinates.length === 0) return;\n\n  const coordinateCount = geojson.geometry.coordinates[0].length;\n  // 2 coordinates after selecting a draw type\n  // 3 after creating the first point\n  if (coordinateCount < 3) {\n    return;\n  }\n  geojson.properties.meta = Constants.meta.FEATURE;\n  display(createVertex(state.polygon.id, geojson.geometry.coordinates[0][0], '0.0', false));\n  if (coordinateCount > 3) {\n    // Add a start position marker to the map, clicking on this will finish the feature\n    // This should only be shown when we're in a valid spot\n    const endPos = geojson.geometry.coordinates[0].length - 3;\n    display(createVertex(state.polygon.id, geojson.geometry.coordinates[0][endPos], `0.${endPos}`, false));\n  }\n  if (coordinateCount <= 4) {\n    // If we've only drawn two positions (plus the closer),\n    // make a LineString instead of a Polygon\n    const lineCoordinates = [\n      [geojson.geometry.coordinates[0][0][0], geojson.geometry.coordinates[0][0][1]], [geojson.geometry.coordinates[0][1][0], geojson.geometry.coordinates[0][1][1]]\n    ];\n    // create an initial vertex so that we can track the first point on mobile devices\n    display({\n      type: Constants.geojsonTypes.FEATURE,\n      properties: geojson.properties,\n      geometry: {\n        coordinates: lineCoordinates,\n        type: Constants.geojsonTypes.LINE_STRING\n      }\n    });\n    if (coordinateCount === 3) {\n      return;\n    }\n  }\n  // render the Polygon\n  return display(geojson);\n};\n\nDrawPolygon.onTrash = function(state) {\n  this.deleteFeature([state.polygon.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nexport default DrawPolygon;\n","import draw_polygon from \"@mapbox/mapbox-gl-draw/src/modes/draw_polygon\";\nimport doubleClickZoom from \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\";\nimport * as Constants from \"@mapbox/mapbox-gl-draw/src/constants\";\n\nconst {\n  onSetup: originOnSetup,\n  onMouseMove: originOnMouseMove,\n  ...restOriginMethods\n} = draw_polygon;\n\nconst passing_draw_polygon = {\n  originOnSetup,\n  originOnMouseMove,\n  ...restOriginMethods,\n};\n\npassing_draw_polygon.onSetup = function (opt) {\n  const state = this.originOnSetup();\n  const { onDraw, onCancel } = opt;\n  state.onDraw = onDraw;\n  state.onCancel = onCancel;\n  return state;\n};\n\npassing_draw_polygon.onMouseMove = function (state, e) {\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.originOnMouseMove(state, e);\n};\n\npassing_draw_polygon.onStop = function (state) {\n  const f = state.polygon;\n\n  this.updateUIClasses({ mouse: Constants.cursors.NONE });\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  /// check to see if we've deleted this feature\n  const drawnFeature = this.getFeature(f.id);\n  if (drawnFeature === undefined) {\n    /// Call `onCancel` if exists.\n    if (typeof state.onCancel === \"function\") state.onCancel();\n    return;\n  }\n  /// remove last added coordinate\n  else f.removeCoordinate(`${state.currentVertexPosition}`);\n\n  if (f.isValid()) {\n    if (typeof state.onDraw === \"function\") state.onDraw(f.toGeoJSON());\n    else\n      this.map.fire(\"draw.passing-create\", {\n        features: [f.toGeoJSON()],\n      });\n  }\n  this.deleteFeature([f.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n};\n\nexport default passing_draw_polygon;\n","export const modeName = \"select_feature\";\n\n/// when a (multi-)polygon feature is hovered to be selected, it gets highlighted.\n/// here is the name of the property indicating the highlight.\nexport const highlightPropertyName = `${modeName}_highlight`;\n\nexport const defaultOptions = {\n  highlightColor: \"#222\",\n};\n","import doubleClickZoom from \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\";\nimport * as Constants from \"@mapbox/mapbox-gl-draw/src/constants\";\nimport { isEscapeKey } from \"@mapbox/mapbox-gl-draw/src/lib/common_selectors\";\n\nimport { defaultOptions, highlightPropertyName } from \"./constants\";\n\nconst select_mode = {};\n\nselect_mode.onSetup = function (opt) {\n  const { selectHighlightColor, onSelect, onCancel } = opt;\n  const state = {};\n  state.hoveredFeatureID = null;\n  state.selectedFeatureID = null;\n  state.onSelect = onSelect;\n  state.onCancel = onCancel;\n  state.api = this._ctx.api;\n  const {\n    selectHighlightColor:\n      defaultSelectHighlightColor = defaultOptions.highlightColor,\n  } = this._ctx.options;\n  state.options = {\n    selectHighlightColor: selectHighlightColor || defaultSelectHighlightColor,\n  };\n\n  return state;\n};\n\nselect_mode.onMouseMove = function (state, e) {\n  const { api } = state;\n  const { featureTarget } = e;\n  // this.originOnMouseMove(state, e);\n\n  if (featureTarget) {\n    this.updateUIClasses({ mouse: Constants.cursors.POINTER });\n    const hoveringFeatureID = featureTarget.properties.id;\n    if (\n      state.hoveredFeatureID !== null &&\n      state.hoveredFeatureID !== hoveringFeatureID\n    ) {\n      api.setFeatureProperty(\n        state.hoveredFeatureID,\n        highlightPropertyName,\n        undefined\n      );\n    }\n    state.hoveredFeatureID = hoveringFeatureID;\n    api.setFeatureProperty(\n      state.hoveredFeatureID,\n      highlightPropertyName,\n      state.options.selectHighlightColor\n    );\n  } else {\n    if (state.hoveredFeatureID)\n      api.setFeatureProperty(\n        state.hoveredFeatureID,\n        highlightPropertyName,\n        undefined\n      );\n    state.hoveredFeatureID = null;\n  }\n};\n\nselect_mode.onClick = function (state, e) {\n  state.selectedFeatureID = state.hoveredFeatureID;\n  this.onStop(state, e);\n};\n\nselect_mode.toDisplayFeatures = function (state, geojson, display) {\n  display(geojson);\n};\n\nselect_mode.onKeyUp = function (state, e) {\n  if (isEscapeKey(e)) {\n    this.changeMode(Constants.modes.SIMPLE_SELECT);\n  }\n};\n\nselect_mode.onStop = function (state) {\n  this.updateUIClasses({ mouse: Constants.cursors.NONE });\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  if (state.selectedFeatureID) {\n    if (typeof state.onSelect === \"function\")\n      state.onSelect(state.selectedFeatureID);\n    else\n      this.map.fire(\"draw.select_mode.select\", {\n        featureID: state.selectedFeatureID,\n      });\n\n    state.selectedFeatureID = null;\n    this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n  } else {\n    /// Call `onCancel` if exists.\n    if (typeof state.onCancel === \"function\") state.onCancel();\n  }\n\n  if (state.hoveredFeatureID) {\n    this._ctx.api.setFeatureProperty(\n      state.hoveredFeatureID,\n      highlightPropertyName,\n      undefined\n    );\n    state.hoveredFeatureID = null;\n  }\n};\n\nexport default select_mode;\n","import { default as selectFeatureMode } from \"./mode.js\";\nimport { default as drawStyles } from \"./customDrawStyles.js\";\n\nimport { modeName } from \"./constants\";\n\nexport { selectFeatureMode };\nexport { drawStyles };\n\nexport default function SelectFeatureMode(modes) {\n  return {\n    ...modes,\n    [modeName]: selectFeatureMode,\n  };\n}\n","import { default as splitPolygonMode } from \"./mode.js\";\nimport { default as drawStyles } from \"./customDrawStyles.js\";\nimport * as Constants from \"./constants\";\n\nimport { passing_draw_line_string } from \"mapbox-gl-draw-passing-mode\";\nimport SelectFeatureMode from \"mapbox-gl-draw-select-mode\";\nimport { modeName, passingModeName } from \"./constants\";\n\nexport { splitPolygonMode };\nexport { drawStyles };\nexport { Constants };\n\nexport default function SplitPolygonMode(modes) {\n  return {\n    ...SelectFeatureMode(modes),\n    [passingModeName]: passing_draw_line_string,\n    [modeName]: splitPolygonMode,\n  };\n}\n"],"names":["clone","geojson","Error","type","cloneFeature","cloned","Object","keys","forEach","key","features","map","feature","cloneFeatureCollection","cloneGeometry","properties","cloneProperties","geometry","value","Array","isArray","item","geom","bbox","geometries","g","coordinates","deepSlice","coords","slice","coord","getCoords","booleanClockwise","line","prev","cur","ring","sum","i","length","options","feat","id","featureEach","callback","geomEach","j","stopG","geometryMaybeCollection","isGeometryCollection","featureProperties","featureBBox","featureId","featureIndex","isFeatureCollection","isFeature","stop","undefined","rewind","input","constructor","reverse","mutate","results","rewindFeature","result","push","fc","featureCollection","rewindLineString","rewindPolygon","lineCoords","pointInPolygon","p","polygon","ii","k","f","u1","v1","u2","v2","currentP","nextP","x","y","numContours","contourLen","contour","splitter","elen","e","flen","h","Q","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","vec","n","Float64Array","B","C1","C2","D","u","orient2d","ax","ay","bx","by","cx","cy","detleft","detright","det","detsum","Math","abs","acxtail","acytail","bcxtail","bcytail","c","ahi","alo","bhi","blo","_i","_j","_0","s1","s0","t1","t0","u3","acx","bcx","acy","bcy","estimate","errbound","C1len","C2len","Dlen","orient2dadapt","Edge","p1","p2","edgeType","index","contourId","this","originalIndex","polygonContourId","interiorRing","minX","min","minY","maxX","max","maxY","intersectionPoints","nextEdge","Point","Contour","rawCoords","edgeIntersectsBbox","edge","IntersectionPoint","edge1","edge2","isHeadingIn","polylineEdge","polygonEdge","distanceFromPolylineEdgeStart","distance","distanceFromPolygonEdgeStart","visitCount","xs","ys","sqrt","prototype","incrementVisitCount","crossProduct","a","b","dotProduct","toPoint","s","d","getEdgeIntersection","lineEdge","potentialEdge","noEndpointTouch","va","vb","kross","sqrKross","sqrLenA","t","sqrLenE","sa","sb","smin","smax","intersections","polygonEdges","polylineEdges","contours","polyEdges","lineEdges","polylineBbox","numberOfRingsInPolygon","linegeom","linecoords","edgeCount","lineLength","prevEdge","nextPoint","prevPoint","polygeom","polycoords","polyLength","i$1","polyLenth2","ii$1","polygonSet","polyLenth3","firstPoint","p1$1","p2$1","e$1","prevEdge$1","firstEdge","iii","intersectPolylineBbox","fillQueue","Infinity","intersectingPoints","count","polyCount","intersection","ip","sort","findIntersectionPoints","numberIntersectionsByRing","infiniteLoopGuard","outPolys","firstPolyStart","pe","polyStart","nextPolyStart","unvisitedPolyFound","index$1","outPoly","nextIntersection","walkPolygonForwards","override","index$2","walkPolylineForwards","walkPolylineBackwards","unvisitedPolyFound$1","index$3","intersection$2","outCoordinates","poly","index$4","createAsHoleOrAddAsNewOuterRing","findRingFromEdge","findFirstPolygonEdge","parseInt","find","unusedRing","existingRing","inside","intersectionPoint","currentIndex","findIndexOfIntersectionPoint","nextIp","condition","lastPointOnEdge","nextIntersection$1","lastIntersection","cursors","types","geojsonTypes","modes","events","meta","activeStates","earthRadius","factors","centimeters","centimetres","degrees","PI","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","lineString","multiLineString","multiPolygon","lengthToDegrees","units","factor","lengthToRadians","isNumber","num","isNaN","TinyQueue","data","compare","defaultCompare","_down","_up","pop","top","bottom","peek","pos","parent","current","halfLength","left","best","right","checkWhichEventIsLeft","e1","e2","checkWhichSegmentHasRightEndpointFirst","seg1","seg2","rightSweepEvent","Event","ringId","eventId","otherEvent","isLeftEndpoint","isSamePoint","eventToCheck","processFeature","featureOrGeometry","eventQueue","Segment$1","event","leftSweepEvent","testSegmentIntersect","x1","y1","x2","y2","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","sweeplineIntersections","ignoreSelfIntersections","fillEventQueue","outQueue","segment","Segment","otherSeg","runCheck","lineIntersect","line1","line2","removeDuplicates","concat","unique","join","r","point","turf_line_intersect_default","getGeom","booleanPointInPolygon","pt","getCoord","polys","inBBox","polyResult","pip","ignoreBoundary","flattenEach","geomType","multiFeatureIndex","coordinate","polygonToLine","coordsToLine","singlePolygonToLine","multiPoly","lines","multiPolygonToLine","isPointOnLine","isPointOnLineSegment","isLineInPoly","lineSegmentStart","lineSegmentEnd","dxc","dyc","dxl","dyl","turf_boolean_disjoint_default","feature1","feature2","bool","flatten1","flatten2","geom1","geom2","pair1","pair2","lineString1","lineString2","isLineOnLine","coord1","coord2","isPolyInPoly","disjoint","ab","start","end","isParallel","q","cross","intersection2","add","v","scalarMult","intersectSegments","lineOffsetFeature","segments","offsetDegrees","finalCoords","currentCoords","point1","point2","offset","L","out1x","out2x","out1y","out2y","seg2Coords","intersects","turf_line_offset_default","_name","getType","coordEach","excludeWrapCoord","l","wrapShrink","coordIndex","geomIndex","geometryIndex","recompute","lineStringToPolygon","autoComplete","orderCoords","autoCompleteCoords","multiCoords","largestArea","area","west","south","east","north","calculateArea","turfBBox","unshift","first","last","turf_line_to_polygon_default","_a","_b","_c","isNumeric","mathceil","ceil","mathfloor","floor","bignumberError","tooManyDigits","BASE","LOG_BASE","MAX_SAFE_INTEGER","POWS_TEN","SQRT_BASE","MAX","bitFloor","coeffToString","z","charCodeAt","xc","yc","intCheck","name","String","isOdd","toExponential","str","charAt","toFixedPoint","len","zs","BigNumber","configObject","div","convertBase","parseNumeric","pow2_53","random53bitInt","basePrefix","dotAfter","dotBefore","isInfinityOrNaN","whitespaceOrPlus","P","toString","valueOf","ONE","DECIMAL_PLACES","ROUNDING_MODE","TO_EXP_NEG","TO_EXP_POS","MIN_EXP","MAX_EXP","CRYPTO","MODULO_MODE","POW_PRECISION","FORMAT","prefix","groupSize","secondaryGroupSize","groupSeparator","decimalSeparator","fractionGroupSize","fractionGroupSeparator","suffix","ALPHABET","alphabetHasNormalDecimalDigits","alphabet","caseChanged","isNum","_isBigNumber","test","indexOf","replace","search","substring","round","DEBUG","toUpperCase","toLowerCase","format","rm","c0","ne","maxOrMin","args","normalise","sd","ni","rd","pows10","out","ROUND_UP","ROUND_DOWN","ROUND_CEIL","ROUND_FLOOR","ROUND_HALF_UP","ROUND_HALF_DOWN","ROUND_HALF_EVEN","ROUND_HALF_CEIL","ROUND_HALF_FLOOR","EUCLID","config","set","obj","hasOwnProperty","crypto","getRandomValues","randomBytes","EXPONENTIAL_AT","RANGE","isBigNumber","call","maximum","arguments","minimum","random","dp","rand","Uint32Array","copy","splice","plus","decimal","toBaseOut","baseIn","baseOut","arrL","arr","sign","callerIsToString","pow","multiply","base","m","temp","xlo","xhi","carry","klo","khi","aL","bL","cmp","subtract","more","prod","prodL","qc","rem","remL","rem0","xi","xL","yc0","yL","yz","NaN","absoluteValue","comparedTo","decimalPlaces","dividedBy","dividedToIntegerBy","idiv","exponentiatedBy","half","isModExp","nIsBig","nIsNeg","nIsOdd","isInteger","mod","times","integerValue","isEqualTo","eq","isFinite","isGreaterThan","gt","isGreaterThanOrEqualTo","gte","isLessThan","lt","isLessThanOrEqualTo","lte","isNegative","isPositive","isZero","minus","xLTy","xe","ye","modulo","multipliedBy","xcL","ycL","ylo","yhi","zc","sqrtBase","negated","precision","shiftedBy","squareRoot","rep","toFixed","toFormat","split","g1","g2","intPart","fractionPart","isNeg","intDigits","substr","RegExp","toFraction","md","d0","d1","d2","exp","n0","n1","toNumber","toPrecision","toJSON","Symbol","toStringTag","for","SplayTreeNode","SplayTreeSetNode","super","SplayTree","size","modificationCount","splayCount","splay","root","newTreeRight","newTreeLeft","comp","currentLeft","currentRight","splayMin","node","nextLeft","splayMax","nextRight","_delete","addNewRoot","_first","_last","clear","has","validKey","wrap","getRoot","setRoot","getSize","getModificationCount","getSplayCount","setSplayCount","SplayTreeSet","_SplayTreeSet","isValidKey","delete","element","deleteAll","elements","nodes","iterator","next","done","addAndReturn","addAll","isEmpty","isNotEmpty","single","lastBefore","nodeRight","firstAfter","nodeLeft","retainAll","retainSet","object","lookup","other","difference","union","copyNode","copyChildren","node2","dest","newLeft","newRight","toSet","entries","SplayTreeSetEntryIterableIterator","values","SplayTreeKeyIterableIterator","SplayTreeIterableIterator","tree","path","moveNext","getValue","rebuildPath","findLeftMostDescendent","constant_default","compare_default","eps","almostEqual","orient_default","almostCollinear","area2","identity_default","snap_default","xTree","yTree","snapCoord","snap","eps2","reset","orient","isInBbox","ll","ur","getBboxOverlap","b1","b2","lowerX","upperX","sineOfAngle","pShared","pBase","pAngle","vBase","vAngle","cosineOfAngle","horizontalIntersection","verticalIntersection","SweepEvent","_SweepEvent","isLeft","otherSE","consumedBy","static","ptCmp","comparePoints","link","aPt","bPt","otherEvents","iMax","evt","checkForConsuming","numEvents","evt1","evt2","consume","getAvailableLinkedEvents","ringOut","isInResult","getLeftmostComparator","baseEvent","cache","Map","fillCache","linkedEvent","nextEvent","sine","cosine","asine","acosine","get","bsine","bcosine","RingOut","_RingOut","_isExteriorRing","_enclosingRing","allSegments","ringsOut","prevEvent","leftSE","rightSE","startingPoint","intersectionLEs","availableLEs","firstPt","lastPt","indexLE","jMax","intersectionLE","ringEvents","comparator","prevPt","points","pt2","nextPt2","nextPt","shift","step","isExteriorRing","iStart","iEnd","orderedPoints","enclosing","enclosingRing","_calcEnclosingRing","leftMostEvt","prevSeg","prevInResult","prevPrevSeg","PolyOut","exteriorRing","interiorRings","addInterior","geom0","ringGeom","operation","numMultiPolys","run","moreGeoms","multipolys","MultiPolyIn","subject","mpA","queue","SplayTreeSet3","sweepEvents","getSweepEvents","sweepLine","SplayTreeSet2","process","newEvents","nextSeg","prevMySplitter","prevInter","getIntersection","isAnEndpoint","newEventsFromSplit","_splitSafely","nextMySplitter","nextInter","mySplitter","inter","seg","factory","rings","_composePolys","polyGeom","operation_default","segmentId","_Segment","windings","_prevInResult","_beforeState","_afterState","_isInResult","alx","blx","arx","brx","aly","bly","ary","bry","aCmpBLeft","comparePoint","bCmpARight","bCmpALeft","aCmpBRight","pt1","leftPt","rightPt","winding","cmpPts","replaceRightSE","newRightSE","vector","tBbox","oBbox","bboxOverlap","tlp","trp","olp","orp","touchesOtherLSE","touchesThisLSE","touchesOtherRSE","touchesThisRSE","ve","alreadyLinked","newLeftSE","oldRightSE","newSeg","swapEvents","tmpEvt","consumer","consumee","tmp","beforeState","afterState","multiPolys","ringsAfter","windingsAfter","mpsAfter","polysAfter","polysExclude","isExterior","mp","mpsBefore","noBefores","noAfters","least","most","diff","isJustSubject","mps","isSubject","RingIn","geomRing","BigNumber2","fromRing","PolyIn","geomPoly","ringSweepEvents","ex","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","polySweepEvents","turf_difference_default","geoms","differenced","polyclip.difference","modeName","passingModeName","highlightPropertyName","defaultOptions","highlightColor","lineWidth","lineWidthUnit","onSelectFeatureRequest","splitPolygonModeEvents","SPLIT_POLYGON_MODE_STOP","SPLIT_POLYGON_MORE_THAN_TWO_POLYGONS","extractPolygons","polygons","polyFeature","SplitPolygonMode","onSetup","opt","featureIds","api","_ctx","featuresToSplit","selectedFeatures","getSelected","apply","filter","toGeoJSON","state","setTimeout","drawAndSplit","bind","highlighFeatures","changeMode","onDraw","cuttingLineString","newPolygons","isInvalidLine","el","booleanDisjoint","polycut","polygonSplitter","line_width","line_width_unit","offsetLine","retVal","intersectPoints","forCut","thickLineString","clipped","lineOffset","polyCoords","lineToPolygon","polygonCutWithSpacing","error","console","fireUpdate","fire","numberOfPolygons","log","onCancel","err","SplitPolygonMode$1","shouldHighlight","color","setFeatureProperty","toDisplayFeatures","display","newF","action","isVertex","featureTarget","Constants.meta","isEscapeKey","keyCode","isEnterKey","DrawPoint","newFeature","Constants.geojsonTypes","addFeature","clearSelectedFeatures","updateUIClasses","mouse","Constants.cursors","activateUIButton","Constants.types","setActionableState","trash","deleteFeature","silent","Constants.modes","onTap","onClick","updateCoordinate","lngLat","lng","lat","Constants.events","onStop","getCoordinate","isActivePoint","active","Constants.activeStates","onTrash","stopDrawingAndRemove","onKeyUp","CommonSelectors.isEscapeKey","CommonSelectors.isEnterKey","originOnSetup","originOnClick","restOriginMethods","draw_point","isEventAtCoordinates","doubleClickZoom","enable","ctx","store","getInitialConfigValue","disable","createVertex","parentId","selected","coord_path","DrawLineString","opts","currentVertexPosition","direction","getFeature","from","lastCoord","addCoordinate","CommonSelectors.isVertex","clickOnVertex","clickAnywhere","removeCoordinate","isValid","isActiveLine","onMouseMove","originOnMouseMove","draw_line_string","passing_draw_line_string","DrawPolygon","isActivePolygon","coordinateCount","endPos","lineCoordinates","draw_polygon","select_mode","SelectFeatureMode","selectFeatureMode","selectHighlightColor","onSelect","defaultSelectHighlightColor","hoveringFeatureID","hoveredFeatureID","selectedFeatureID","featureID","modeName$1","splitPolygonMode","defaultStyle","style","endsWith","paint","layout"],"mappings":"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"}