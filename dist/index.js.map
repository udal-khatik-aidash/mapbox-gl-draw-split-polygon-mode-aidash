{"version":3,"file":"index.js","sources":["../node_modules/@turf/clone/dist/es/index.js","../node_modules/@turf/helpers/dist/es/index.js","../node_modules/@turf/invariant/dist/es/index.js","../node_modules/@turf/boolean-clockwise/dist/es/index.js","../node_modules/@turf/meta/dist/es/index.js","../node_modules/@turf/rewind/dist/es/index.js","../node_modules/point-in-polygon-hao/dist/pointInPolygon.mjs","../node_modules/robust-predicates/esm/util.js","../node_modules/robust-predicates/esm/orient2d.js","../node_modules/polygon-splitter/dist/polygonsplitter.mjs","../node_modules/@mapbox/mapbox-gl-draw/src/constants.js","../node_modules/@turf/line-segment/dist/es/index.js","../node_modules/geojson-rbush/node_modules/quickselect/index.js","../node_modules/geojson-rbush/node_modules/rbush/index.js","../node_modules/@turf/helpers/dist/js/index.js","../node_modules/@turf/meta/dist/js/index.js","../node_modules/@turf/bbox/dist/js/index.js","../node_modules/geojson-rbush/index.js","../node_modules/@turf/line-intersect/dist/es/index.js","../node_modules/@turf/boolean-point-in-polygon/dist/es/index.js","../node_modules/@turf/polygon-to-line/dist/es/index.js","../node_modules/@turf/boolean-disjoint/dist/es/index.js","../node_modules/@turf/line-offset/dist/es/index.js","../node_modules/@turf/bbox/dist/es/index.js","../node_modules/@turf/line-to-polygon/dist/es/index.js","../node_modules/splaytree/dist/splay.esm.js","../node_modules/polygon-clipping/dist/polygon-clipping.esm.js","../node_modules/@turf/difference/dist/es/index.js","../src/constants.js","../src/mode.js","../src/customDrawStyles.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js","../node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_point.js","../node_modules/mapbox-gl-draw-passing-mode/src/passing_draw_point.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/is_event_at_coordinates.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js","../node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_line_string.js","../node_modules/mapbox-gl-draw-passing-mode/src/passing_draw_line_string.js","../node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_polygon.js","../node_modules/mapbox-gl-draw-passing-mode/src/passing_draw_polygon.js","../node_modules/mapbox-gl-draw-select-mode/src/constants.js","../node_modules/mapbox-gl-draw-select-mode/src/mode.js","../node_modules/mapbox-gl-draw-select-mode/src/index.js","../src/index.js"],"sourcesContent":["/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @name clone\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    switch (geojson.type) {\n        case \"Feature\":\n            return cloneFeature(geojson);\n        case \"FeatureCollection\":\n            return cloneFeatureCollection(geojson);\n        case \"Point\":\n        case \"LineString\":\n        case \"Polygon\":\n        case \"MultiPoint\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n        case \"GeometryCollection\":\n            return cloneGeometry(geojson);\n        default:\n            throw new Error(\"unknown GeoJSON type\");\n    }\n}\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson) {\n    var cloned = { type: \"Feature\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"properties\":\n            case \"geometry\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add properties & geometry last\n    cloned.properties = cloneProperties(geojson.properties);\n    cloned.geometry = cloneGeometry(geojson.geometry);\n    return cloned;\n}\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties) {\n    var cloned = {};\n    if (!properties) {\n        return cloned;\n    }\n    Object.keys(properties).forEach(function (key) {\n        var value = properties[key];\n        if (typeof value === \"object\") {\n            if (value === null) {\n                // handle null\n                cloned[key] = null;\n            }\n            else if (Array.isArray(value)) {\n                // handle Array\n                cloned[key] = value.map(function (item) {\n                    return item;\n                });\n            }\n            else {\n                // handle generic Object\n                cloned[key] = cloneProperties(value);\n            }\n        }\n        else {\n            cloned[key] = value;\n        }\n    });\n    return cloned;\n}\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson) {\n    var cloned = { type: \"FeatureCollection\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"features\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add features\n    cloned.features = geojson.features.map(function (feature) {\n        return cloneFeature(feature);\n    });\n    return cloned;\n}\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry) {\n    var geom = { type: geometry.type };\n    if (geometry.bbox) {\n        geom.bbox = geometry.bbox;\n    }\n    if (geometry.type === \"GeometryCollection\") {\n        geom.geometries = geometry.geometries.map(function (g) {\n            return cloneGeometry(g);\n        });\n        return geom;\n    }\n    geom.coordinates = deepSlice(geometry.coordinates);\n    return geom;\n}\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice(coords) {\n    var cloned = coords;\n    if (typeof cloned[0] !== \"object\") {\n        return cloned.slice();\n    }\n    return cloned.map(function (coord) {\n        return deepSlice(coord);\n    });\n}\nexport default clone;\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoords } from \"@turf/invariant\";\n/**\n * Takes a ring and return true or false whether or not the ring is clockwise or counter-clockwise.\n *\n * @name booleanClockwise\n * @param {Feature<LineString>|LineString|Array<Array<number>>} line to be evaluated\n * @returns {boolean} true/false\n * @example\n * var clockwiseRing = turf.lineString([[0,0],[1,1],[1,0],[0,0]]);\n * var counterClockwiseRing = turf.lineString([[0,0],[1,0],[1,1],[0,0]]);\n *\n * turf.booleanClockwise(clockwiseRing)\n * //=true\n * turf.booleanClockwise(counterClockwiseRing)\n * //=false\n */\nexport default function booleanClockwise(line) {\n    var ring = getCoords(line);\n    var sum = 0;\n    var i = 1;\n    var prev;\n    var cur;\n    while (i < ring.length) {\n        prev = cur || ring[0];\n        cur = ring[i];\n        sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);\n        i++;\n    }\n    return sum > 0;\n}\n","import { feature, lineString, isObject, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\n","import clone from '@turf/clone';\nimport booleanClockwise from '@turf/boolean-clockwise';\nimport { featureEach, geomEach } from '@turf/meta';\nimport { getCoords } from '@turf/invariant';\nimport { isObject, featureCollection } from '@turf/helpers';\n\n/**\n * Rewind {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon} outer ring counterclockwise and inner rings clockwise (Uses {@link http://en.wikipedia.org/wiki/Shoelace_formula|Shoelace Formula}).\n *\n * @name rewind\n * @param {GeoJSON} geojson input GeoJSON Polygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.reverse=false] enable reverse winding\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} rewind Polygon\n * @example\n * var polygon = turf.polygon([[[121, -29], [138, -29], [138, -18], [121, -18], [121, -29]]]);\n *\n * var rewind = turf.rewind(polygon);\n *\n * //addToMap\n * var addToMap = [rewind];\n */\nfunction rewind(geojson, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var reverse = options.reverse || false;\n  var mutate = options.mutate || false;\n\n  // validation\n  if (!geojson) throw new Error(\"<geojson> is required\");\n  if (typeof reverse !== \"boolean\")\n    throw new Error(\"<reverse> must be a boolean\");\n  if (typeof mutate !== \"boolean\")\n    throw new Error(\"<mutate> must be a boolean\");\n\n  // prevent input mutation\n  if (mutate === false) geojson = clone(geojson);\n\n  // Support Feature Collection or Geometry Collection\n  var results = [];\n  switch (geojson.type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        rewindFeature(geometry, reverse);\n      });\n      return geojson;\n    case \"FeatureCollection\":\n      featureEach(geojson, function (feature) {\n        featureEach(rewindFeature(feature, reverse), function (result) {\n          results.push(result);\n        });\n      });\n      return featureCollection(results);\n  }\n  // Support Feature or Geometry Objects\n  return rewindFeature(geojson, reverse);\n}\n\n/**\n * Rewind\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Geometry or Feature\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {Geometry|Feature<any>} rewind Geometry or Feature\n */\nfunction rewindFeature(geojson, reverse) {\n  var type = geojson.type === \"Feature\" ? geojson.geometry.type : geojson.type;\n\n  // Support all GeoJSON Geometry Objects\n  switch (type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        rewindFeature(geometry, reverse);\n      });\n      return geojson;\n    case \"LineString\":\n      rewindLineString(getCoords(geojson), reverse);\n      return geojson;\n    case \"Polygon\":\n      rewindPolygon(getCoords(geojson), reverse);\n      return geojson;\n    case \"MultiLineString\":\n      getCoords(geojson).forEach(function (lineCoords) {\n        rewindLineString(lineCoords, reverse);\n      });\n      return geojson;\n    case \"MultiPolygon\":\n      getCoords(geojson).forEach(function (lineCoords) {\n        rewindPolygon(lineCoords, reverse);\n      });\n      return geojson;\n    case \"Point\":\n    case \"MultiPoint\":\n      return geojson;\n  }\n}\n\n/**\n * Rewind LineString - outer ring clockwise\n *\n * @private\n * @param {Array<Array<number>>} coords GeoJSON LineString geometry coordinates\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {void} mutates coordinates\n */\nfunction rewindLineString(coords, reverse) {\n  if (booleanClockwise(coords) === reverse) coords.reverse();\n}\n\n/**\n * Rewind Polygon - outer ring counterclockwise and inner rings clockwise.\n *\n * @private\n * @param {Array<Array<Array<number>>>} coords GeoJSON Polygon geometry coordinates\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {void} mutates coordinates\n */\nfunction rewindPolygon(coords, reverse) {\n  // outer ring\n  if (booleanClockwise(coords[0]) !== reverse) {\n    coords[0].reverse();\n  }\n  // inner rings\n  for (var i = 1; i < coords.length; i++) {\n    if (booleanClockwise(coords[i]) === reverse) {\n      coords[i].reverse();\n    }\n  }\n}\n\nexport default rewind;\n","function pointInPolygon(p, polygon) {\n    var i = 0;\n    var ii = 0;\n    var k = 0;\n    var f = 0;\n    var u1 = 0;\n    var v1 = 0;\n    var u2 = 0;\n    var v2 = 0;\n    var currentP = null;\n    var nextP = null;\n\n    var x = p[0];\n    var y = p[1];\n\n    var numContours = polygon.length;\n    for (i; i < numContours; i++) {\n        ii = 0;\n        var contourLen = polygon[i].length - 1;\n        var contour = polygon[i];\n\n        currentP = contour[0];\n        if (currentP[0] !== contour[contourLen][0] &&\n            currentP[1] !== contour[contourLen][1]) {\n            throw new Error('First and last coordinates in a ring must be the same')\n        }\n\n        u1 = currentP[0] - x;\n        v1 = currentP[1] - y;\n\n        for (ii; ii < contourLen; ii++) {\n            nextP = contour[ii + 1];\n\n            v2 = nextP[1] - y;\n\n            if ((v1 < 0 && v2 < 0) || (v1 > 0 && v2 > 0)) {\n                currentP = nextP;\n                v1 = v2;\n                u1 = currentP[0] - x;\n                continue\n            }\n\n            u2 = nextP[0] - p[0];\n\n            if (v2 > 0 && v1 <= 0) {\n                f = (u1 * v2) - (u2 * v1);\n                if (f > 0) { k = k + 1; }\n                else if (f === 0) { return 0 }\n            } else if (v1 > 0 && v2 <= 0) {\n                f = (u1 * v2) - (u2 * v1);\n                if (f < 0) { k = k + 1; }\n                else if (f === 0) { return 0 }\n            } else if (v2 === 0 && v1 < 0) {\n                f = (u1 * v2) - (u2 * v1);\n                if (f === 0) { return 0 }\n            } else if (v1 === 0 && v2 < 0) {\n                f = u1 * v2 - u2 * v1;\n                if (f === 0) { return 0 }\n            } else if (v1 === 0 && v2 === 0) {\n                if (u2 <= 0 && u1 >= 0) {\n                    return 0\n                } else if (u1 <= 0 && u2 >= 0) {\n                    return 0\n                }\n            }\n            currentP = nextP;\n            v1 = v2;\n            u1 = u2;\n        }\n    }\n\n    if (k % 2 === 0) { return false }\n    return true\n}\n\nexport default pointInPolygon;\n","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    if (detleft === 0 || detright === 0 || (detleft > 0) !== (detright > 0)) return det;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","import rewind from '@turf/rewind';\nimport inside from 'point-in-polygon-hao';\nimport { orient2d } from 'robust-predicates';\n\nvar Edge = function Edge(p1, p2, edgeType, index, contourId) {\r\n  this.p1 = p1;\r\n  this.p2 = p2;\r\n  this.edgeType = edgeType;\r\n  this.originalIndex = index;\r\n\r\n  this.polygonContourId = contourId;\r\n  this.interiorRing = false;\r\n\r\n  this.minX = Math.min(p1.p[0], p2.p[0]);\r\n  this.minY = Math.min(p1.p[1], p2.p[1]);\r\n\r\n  this.maxX = Math.max(p1.p[0], p2.p[0]);\r\n  this.maxY = Math.max(p1.p[1], p2.p[1]);\r\n\r\n  this.intersectionPoints = [];\r\n  this.nextEdge = null;\r\n};\n\nvar Point = function Point(p) {\r\n  this.p = p;\r\n};\n\nvar Contour = function Contour(contourId, coords) {\n  this.id = contourId;\n  this.rawCoords = coords;\n};\n\nfunction fillQueue(polygon, line, polyEdges, lineEdges, polylineBbox) {\r\n  var numberOfRingsInPolygon = 0;\r\n  var contours = [];\r\n\r\n  var linegeom = line.type === 'Feature' ? line.geometry : line;\r\n  var linecoords = linegeom.type === 'LineString' ? [linegeom.coordinates] : linegeom.coordinates;\r\n\r\n  var edgeCount = 0;\r\n\r\n  for (var i = 0; i < linecoords.length; i++) {\r\n\r\n    var lineLength = linecoords[i].length - 1;\r\n    var p1 = new Point(linecoords[i][0]);\r\n    var p2 = null;\r\n    var prevEdge = {nextEdge: null};\r\n\r\n    for (var ii = 0; ii < lineLength; ii++) {\r\n      p2 = new Point(linecoords[i][ii + 1]);\r\n      p1.nextPoint = p2;\r\n      p2.prevPoint = p1;\r\n      var e = new Edge(p1, p2, 'polyline', edgeCount, null);\r\n      lineEdges.push(e);\r\n      prevEdge.nextEdge = e;\r\n      e.prevEdge = prevEdge;\r\n      polylineBbox[0] = Math.min(polylineBbox[0], p1.p[0]);\r\n      polylineBbox[1] = Math.min(polylineBbox[1], p1.p[1]);\r\n      polylineBbox[2] = Math.max(polylineBbox[2], p1.p[0]);\r\n      polylineBbox[3] = Math.max(polylineBbox[3], p1.p[1]);\r\n\r\n      p1 = p2;\r\n      edgeCount = edgeCount + 1;\r\n      prevEdge = e;\r\n    }\r\n    polylineBbox[0] = Math.min(polylineBbox[0], linecoords[i][lineLength][0]);\r\n    polylineBbox[1] = Math.min(polylineBbox[1], linecoords[i][lineLength][1]);\r\n    polylineBbox[2] = Math.max(polylineBbox[2], linecoords[i][lineLength][0]);\r\n    polylineBbox[3] = Math.max(polylineBbox[3], linecoords[i][lineLength][1]);\r\n  }\r\n\r\n  var polygeom = polygon.type === 'Feature' ? polygon.geometry : polygon;\r\n  var polycoords = polygeom.type === 'Polygon' ? [polygeom.coordinates] : polygeom.coordinates;\r\n\r\n  var polyLength = polycoords.length;\r\n\r\n  for (var i$1 = 0; i$1 < polyLength; i$1++) {\r\n\r\n    var polyLenth2 = polycoords[i$1].length;\r\n\r\n    for (var ii$1 = 0; ii$1 < polyLenth2; ii$1++) {\r\n      numberOfRingsInPolygon = numberOfRingsInPolygon + 1;\r\n\r\n      var polygonSet = polycoords[i$1][ii$1];\r\n      var polyLenth3 = polygonSet.length;\r\n      \r\n      contours.push(new Contour(numberOfRingsInPolygon, polygonSet));\r\n\r\n      var firstPoint = new Point(polygonSet[0]);\r\n      var p1$1 = firstPoint;\r\n      var p2$1 = (void 0), e$1 = null;\r\n      var prevEdge$1 = {nextEdge: null, prevEdge: null};\r\n      var firstEdge = null;\r\n\r\n      for (var iii = 1; iii < polyLenth3; iii++) {\r\n        p2$1 = new Point(polygonSet[iii]);\r\n        p1$1.nextPoint = p2$1;\r\n        p2$1.prevPoint = p1$1;\r\n\r\n        e$1 = new Edge(p1$1, p2$1, 'polygon', edgeCount, numberOfRingsInPolygon);\r\n        prevEdge$1.nextEdge = e$1;\r\n        e$1.prevEdge = prevEdge$1;\r\n        if (iii === 1) { firstEdge = e$1; }\r\n\r\n        if (ii$1 > 0) { e$1.interiorRing = true; }\r\n        e$1.intersectPolylineBbox = edgeIntersectsBbox(e$1, polylineBbox);\r\n        polyEdges.push(e$1);\r\n\r\n        p1$1 = p2$1;\r\n        edgeCount = edgeCount + 1;\r\n        prevEdge$1 = e$1;\r\n      }\r\n\r\n      e$1.nextEdge = firstEdge;\r\n      firstEdge.prevEdge = e$1;\r\n      p2$1.nextPoint = firstPoint.nextPoint;\r\n      firstPoint.prevPoint = p2$1.prevPoint;\r\n    }\r\n  }\r\n  return contours\r\n}\r\n\r\nfunction edgeIntersectsBbox(edge, bbox) {\r\n  if (edge.maxX < bbox[0]) { return false }\r\n  if (edge.minX > bbox[2]) { return false }\r\n  if (edge.maxY < bbox[1]) { return false }\r\n  if (edge.minY > bbox[3]) { return false }\r\n  return true\r\n}\n\nvar IntersectionPoint = function IntersectionPoint(p, edge1, edge2, isHeadingIn) {\r\n  this.p = p;\r\n  this.polylineEdge = edge1;\r\n  this.polygonEdge = edge2;\r\n  this.isHeadingIn = isHeadingIn;\r\n\r\n  this.distanceFromPolylineEdgeStart = distance(this.polylineEdge.p1.p, this.p);\r\n  this.distanceFromPolygonEdgeStart = distance(this.polygonEdge.p1.p, this.p);\r\n\r\n  this.polygonEdge.intersectionPoints.push(this);\r\n  this.polylineEdge.intersectionPoints.push(this);\r\n\r\n  this.visitCount = 0;\r\n};\r\n\r\nIntersectionPoint.prototype.incrementVisitCount = function incrementVisitCount () {\r\n  this.visitCount = this.visitCount + 1;\r\n};\r\n\r\nfunction distance(p1, p2) {\r\n  var xs = p2[0] - p1[0];\r\n  var ys = p2[1] - p1[1];\r\n  xs *= xs;\r\n  ys *= ys;\r\n\r\n  return Math.sqrt(xs + ys)\r\n}\n\nfunction findIntersectionPoints(polygonEdges, lineEdges, intersectingPoints) {\r\n  var i, ii, iii;\r\n  var count = lineEdges.length;\r\n  var polyCount = polygonEdges.length;\r\n  for (i = 0; i < count; i++) {\r\n    var lineEdge = lineEdges[i];\r\n\r\n    for (ii = 0; ii < polyCount; ii++) {\r\n      var polygonEdge = polygonEdges[ii];\r\n      if (!polygonEdge.intersectPolylineBbox) { continue }\r\n\r\n      if (polygonEdge.maxX < lineEdge.minX || polygonEdge.minX > lineEdge.maxX) { continue }\r\n      if (polygonEdge.maxY < lineEdge.minY || polygonEdge.minY > lineEdge.maxY) { continue }\r\n      var intersection = getEdgeIntersection(lineEdge, polygonEdge);\r\n      if (intersection !== null) {\r\n        for (iii = 0; iii < intersection.length; iii++) {\r\n          var isHeadingIn = orient2d(polygonEdge.p1.p[0], polygonEdge.p1.p[1], polygonEdge.p2.p[0], polygonEdge.p2.p[1], lineEdge.p1.p[0], lineEdge.p1.p[1]);\r\n          var ip = new IntersectionPoint(intersection[iii], lineEdge, polygonEdge, isHeadingIn > 0);\r\n          intersectingPoints.push(ip);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  lineEdges.forEach(function (edge) {\r\n    edge.intersectionPoints.sort(function (a, b) {\r\n      return a.distanceFromPolylineEdgeStart - b.distanceFromPolylineEdgeStart\r\n    });\r\n  });\r\n\r\n  polygonEdges.forEach(function (edge) {\r\n    edge.intersectionPoints.sort(function (a, b) {\r\n      return a.distanceFromPolygonEdgeStart - b.distanceFromPolygonEdgeStart\r\n    });\r\n  });\r\n}\r\n\r\nvar EPSILON = 1e-9;\r\n\r\nfunction crossProduct(a, b) {\r\n  return (a[0] * b[1]) - (a[1] * b[0])\r\n}\r\n\r\nfunction dotProduct(a, b) {\r\n  return (a[0] * b[0]) + (a[1] * b[1])\r\n}\r\n\r\nfunction toPoint(p, s, d) {\r\n  return [\r\n    p[0] + s * d[0],\r\n    p[1] + s * d[1]\r\n  ]\r\n}\r\n\r\nfunction getEdgeIntersection(lineEdge, potentialEdge, noEndpointTouch) {\r\n  var va = [lineEdge.p2.p[0] - lineEdge.p1.p[0], lineEdge.p2.p[1] - lineEdge.p1.p[1]];\r\n  var vb = [potentialEdge.p2.p[0] - potentialEdge.p1.p[0], potentialEdge.p2.p[1] - potentialEdge.p1.p[1]];\r\n\r\n  var e = [potentialEdge.p1.p[0] - lineEdge.p1.p[0], potentialEdge.p1.p[1] - lineEdge.p1.p[1]];\r\n  var kross = crossProduct(va, vb);\r\n  var sqrKross = kross * kross;\r\n  var sqrLenA  = dotProduct(va, va);\r\n\r\n  if (sqrKross > 0) {\r\n\r\n    var s = crossProduct(e, vb) / kross;\r\n    if (s < 0 || s > 1) { return null }\r\n    var t = crossProduct(e, va) / kross;\r\n    if (t < 0 || t > 1) { return null }\r\n    if (s === 0 || s === 1) {\r\n      // on an endpoint of line segment a\r\n      return noEndpointTouch ? null : [toPoint(lineEdge.p1.p, s, va)]\r\n    }\r\n    if (t === 0 || t === 1) {\r\n      // on an endpoint of line segment b\r\n      return noEndpointTouch ? null : [toPoint(potentialEdge.p1.p, t, vb)]\r\n    }\r\n    return [toPoint(lineEdge.p1.p, s, va)]\r\n  }\r\n\r\n  var sqrLenE = dotProduct(e, e);\r\n  kross = crossProduct(e, va);\r\n  sqrKross = kross * kross;\r\n\r\n  if (sqrKross > EPSILON * sqrLenA * sqrLenE) { return null }\r\n\r\n  var sa = dotProduct(va, e) / sqrLenA;\r\n  var sb = sa + dotProduct(va, vb) / sqrLenA;\r\n  var smin = Math.min(sa, sb);\r\n  var smax = Math.max(sa, sb);\r\n\r\n  if (smin <= 1 && smax >= 0) {\r\n\r\n    if (smin === 1) { return noEndpointTouch ? null : [toPoint(lineEdge.p1.p, smin > 0 ? smin : 0, va)] }\r\n\r\n    if (smax === 0) { return noEndpointTouch ? null : [toPoint(lineEdge.p1.p, smax < 1 ? smax : 1, va)] }\r\n\r\n    if (noEndpointTouch && smin === 0 && smax === 1) { return null }\r\n\r\n    return [\r\n      toPoint(lineEdge.p1.p, smin > 0 ? smin : 0, va),\r\n      toPoint(lineEdge.p1.p, smax < 1 ? smax : 1, va)\r\n    ]\r\n  }\r\n\r\n  return null\r\n}\n\n// import { _debugCandidatePoly, _debugIntersectionPoint, _debugLinePoints, _debugIntersectionPoints, _debugPolyStart } from './debug'\r\n\r\nfunction index (polygon, line) {\r\n  var poly = rewind(polygon);\r\n\r\n  var intersections = [];\r\n  var polygonEdges = [];\r\n  var polylineEdges = [];\r\n  var polylineBbox = [Infinity, Infinity, Infinity, Infinity];\r\n\r\n  var contours = fillQueue(poly, line, polygonEdges, polylineEdges, polylineBbox);\r\n\r\n  findIntersectionPoints(polygonEdges, polylineEdges, intersections);\r\n\r\n  if (intersections.length === 0) {\r\n    return polygon\r\n  }\r\n\r\n  // Track the number of intersections per contour\r\n  // This is useful for holes or outerrings that aren't intersected\r\n  // so that we can manually add them back in at the end\r\n  var numberIntersectionsByRing = {};\r\n  contours.forEach(function (c) { return numberIntersectionsByRing[c.id] = 0; }); //eslint-disable-line\r\n  intersections.forEach(function (i) {\r\n    var id = i.polygonEdge.polygonContourId;\r\n    numberIntersectionsByRing[id] = numberIntersectionsByRing[id] + 1;\r\n  });\r\n\r\n\r\n  var infiniteLoopGuard = 0;\r\n  var outPolys = [];\r\n  // _debugIntersectionPoints(intersections)\r\n  // Start the rewiring of the outputs from the first intersection point along the polyline line\r\n  // This step makes a difference (eg see the another.geojson harness file)\r\n  var firstPolyStart = null;\r\n  for (var index = 0; index < polylineEdges.length; index++) {\r\n    var pe = polylineEdges[index];\r\n    if (pe.intersectionPoints.length > 0) {\r\n      firstPolyStart = pe.intersectionPoints[0];\r\n      break\r\n    }\r\n  }\r\n\r\n  var polyStart = firstPolyStart;\r\n  var nextPolyStart = {visitCount: 1};\r\n  // Basically we're going to walk our way around the outside of the polygon\r\n  // to find new output polygons until we get back to the beginning\r\n  while (firstPolyStart !== nextPolyStart) {\r\n    if (infiniteLoopGuard > intersections.length * 2) {\r\n      break\r\n    }\r\n    infiniteLoopGuard = infiniteLoopGuard++;\r\n\r\n    // If we've already visited this intersection point a couple of times we've\r\n    // already used it in it's two output polygons\r\n\r\n    if (nextPolyStart.visitCount >= 2) {\r\n      var unvisitedPolyFound = false;\r\n      for (var index$1 = 0; index$1 < intersections.length; index$1++) {\r\n        var intersection = intersections[index$1];\r\n        if (intersection.visitCount < 2) {\r\n          polyStart = intersection;\r\n          unvisitedPolyFound = true;\r\n          break\r\n        }\r\n      }\r\n      if (!unvisitedPolyFound) { break }\r\n    }\r\n\r\n    polyStart.visitCount = polyStart.visitCount + 1;\r\n    var outPoly = [];\r\n    outPolys.push(outPoly);\r\n    outPoly.push(polyStart.p);\r\n\r\n    polyStart.visitCount = polyStart.visitCount + 1;\r\n    var nextIntersection = walkPolygonForwards(polyStart, outPoly);\r\n    // _debugCandidatePoly(outPolys)\r\n    // After we've walked the first stretch of the polygon we now have the\r\n    // starting point for our next output polygon\r\n    nextPolyStart = nextIntersection;\r\n\r\n\r\n    // Although sometimes we walk all the way around the outside\r\n    // because our split line goes from outer to inner ring\r\n    var override = false;\r\n    if (nextIntersection === nextPolyStart && intersections.length === 2) {\r\n      for (var index$2 = 0; index$2 < intersections.length; index$2++) {\r\n        var intersection$1 = intersections[index$2];\r\n        if (intersection$1.visitCount < 2) {\r\n          override = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // An ouput polygon has to contain at least 1 stretch from the original polygon\r\n    // and one stretch from the polyline\r\n    // However it can contain many stretches of each\r\n    // So we walk continually from polyline to polygon collecting the output\r\n    while (nextIntersection !== polyStart || override) {\r\n      var methodForPolyline = nextIntersection.isHeadingIn ? walkPolylineForwards : walkPolylineBackwards;\r\n      nextIntersection = methodForPolyline(nextIntersection, outPoly);\r\n      // _debugCandidatePoly(outPolys)\r\n\r\n      if (nextIntersection !== polyStart) {\r\n        nextIntersection = walkPolygonForwards(nextIntersection, outPoly);\r\n        // _debugCandidatePoly(outPolys)\r\n      }\r\n      override = false;\r\n    }\r\n\r\n    if (nextPolyStart.visitCount >= 2) {\r\n      var unvisitedPolyFound$1 = false;\r\n      for (var index$3 = 0; index$3 < intersections.length; index$3++) {\r\n        var intersection$2 = intersections[index$3];\r\n        if (intersection$2.visitCount < 2) {\r\n          polyStart = intersection$2;\r\n          unvisitedPolyFound$1 = true;\r\n          break\r\n        }\r\n      }\r\n      if (unvisitedPolyFound$1) {\r\n        nextPolyStart = polyStart;\r\n      }\r\n    }\r\n\r\n    // Finally we set the next start point based on what we found earlier\r\n    polyStart = nextPolyStart;\r\n  }\r\n\r\n  var outCoordinates = outPolys.map(function (poly) { return [poly]; });\r\n\r\n  var keys = Object.keys(numberIntersectionsByRing);\r\n  for (var index$4 = 0; index$4 < keys.length; index$4++) {\r\n    var key = keys[index$4];\r\n    var value = numberIntersectionsByRing[key];\r\n    if (value === 0) {\r\n      var edge = findFirstPolygonEdge(polygonEdges, parseInt(key));\r\n      var ring = findRingFromEdge(edge, contours);\r\n      createAsHoleOrAddAsNewOuterRing(ring, outCoordinates);\r\n    }\r\n  }\r\n\r\n  return {\r\n    type: 'Feature',\r\n    properties: {},\r\n    geometry: {\r\n      type: 'MultiPolygon',\r\n      coordinates: outCoordinates\r\n    }\r\n  }\r\n}\r\n\r\nfunction findFirstPolygonEdge(polygonEdges, contourId) {\r\n  for (var index = 0; index < polygonEdges.length; index++) {\r\n    var edge = polygonEdges[index];\r\n    if (edge.polygonContourId === contourId) { return edge }\r\n  }\r\n}\r\n\r\nfunction findRingFromEdge(edge, contours) {\r\n  var contour = contours.find(function (c) { return c.id === edge.polygonContourId; });\r\n  return contour.rawCoords\r\n}\r\n\r\nfunction createAsHoleOrAddAsNewOuterRing(unusedRing, outCoordinates) {\r\n  for (var index = 0; index < outCoordinates.length; index++) {\r\n    var existingRing = outCoordinates[index];\r\n    if (inside(unusedRing[0], [existingRing[0]])) {\r\n      existingRing.push(unusedRing);\r\n      return\r\n    }\r\n  }\r\n  // If no match is found push it as a new outer ring\r\n  outCoordinates.push([unusedRing]);\r\n}\r\n\r\n// Walk around the polygon collecting vertices\r\nfunction walkPolygonForwards(intersectionPoint, outPoly) {\r\n  var nextEdge = intersectionPoint.polygonEdge;\r\n  if (nextEdge.intersectionPoints.length > 1) {\r\n    // _debugIntersectionPoint(intersectionPoint)\r\n    var lastPointOnEdge = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];\r\n    if (lastPointOnEdge !== intersectionPoint) {\r\n      var currentIndex = findIndexOfIntersectionPoint(intersectionPoint, nextEdge.intersectionPoints);\r\n      var nextIp = nextEdge.intersectionPoints[currentIndex + 1];\r\n      outPoly.push(nextIp.p);\r\n      nextIp.incrementVisitCount();\r\n      return nextIp\r\n    }\r\n  }\r\n  var condition = true;\r\n  while (condition) {\r\n    outPoly.push(nextEdge.p2.p);\r\n    nextEdge = nextEdge.nextEdge;\r\n    if (nextEdge === null) { return intersectionPoint }\r\n    else if (nextEdge.intersectionPoints.length > 0) { condition = false; }\r\n  }\r\n  nextEdge.intersectionPoints[0].incrementVisitCount();\r\n  outPoly.push(nextEdge.intersectionPoints[0].p);\r\n  return nextEdge.intersectionPoints[0]\r\n}\r\n\r\n// Given a set of intersections find the next one\r\nfunction findIndexOfIntersectionPoint(intersection, intersections) {\r\n  for (var index = 0; index < intersections.length; index++) {\r\n    var int = intersections[index];\r\n    if (int === intersection) { return index }\r\n  }\r\n  return null\r\n}\r\n\r\n\r\nfunction walkPolylineBackwards(intersectionPoint, outPoly) {\r\n  var nextEdge = intersectionPoint.polylineEdge;\r\n  if (nextEdge.intersectionPoints.length === 2) {\r\n    var lastPointOnEdge = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];\r\n    // debugger\r\n    if (lastPointOnEdge === intersectionPoint) {\r\n      var nextIntersection = nextEdge.intersectionPoints[0];\r\n      outPoly.push(nextIntersection.p);\r\n      nextIntersection.incrementVisitCount();\r\n      return nextIntersection\r\n    } else {\r\n      outPoly.push(lastPointOnEdge.p);\r\n      lastPointOnEdge.incrementVisitCount();\r\n      return lastPointOnEdge\r\n    }\r\n  } else if (nextEdge.intersectionPoints.length > 2) {\r\n    // _debugIntersectionPoint(intersectionPoint)\r\n\r\n    var lastPointOnEdge$1 = nextEdge.intersectionPoints[0];\r\n    if (lastPointOnEdge$1 !== intersectionPoint) {\r\n      var currentIndex = findIndexOfIntersectionPoint(intersectionPoint, nextEdge.intersectionPoints);\r\n      var nextIntersection$1 = nextEdge.intersectionPoints[currentIndex - 1];\r\n      outPoly.push(nextIntersection$1.p);\r\n      nextIntersection$1.incrementVisitCount();\r\n      return nextIntersection$1\r\n    }\r\n  }\r\n  var condition = true;\r\n  while (condition) {\r\n    outPoly.push(nextEdge.p1.p);\r\n    nextEdge = nextEdge.prevEdge;\r\n    if (nextEdge.originalIndex === undefined) { return intersectionPoint }\r\n    else if (nextEdge.intersectionPoints.length > 0) {\r\n      condition = false;\r\n    }\r\n  }\r\n  if (nextEdge.originalIndex === undefined) { return intersectionPoint }\r\n  var lastIntersection = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];\r\n  lastIntersection.incrementVisitCount();\r\n  outPoly.push(lastIntersection.p);\r\n  return lastIntersection\r\n}\r\n\r\nfunction walkPolylineForwards(intersectionPoint, outPoly) {\r\n  var nextEdge = intersectionPoint.polylineEdge;\r\n\r\n  if (nextEdge.intersectionPoints.length > 1) {\r\n    // _debugIntersectionPoint(intersectionPoint)\r\n    var lastPointOnEdge = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];\r\n    if (lastPointOnEdge !== intersectionPoint) {\r\n      var currentIndex = findIndexOfIntersectionPoint(intersectionPoint, nextEdge.intersectionPoints);\r\n      var nextIp = nextEdge.intersectionPoints[currentIndex + 1];\r\n      outPoly.push(nextIp.p);\r\n      nextIp.incrementVisitCount();\r\n      return nextIp\r\n    }\r\n  }\r\n  var condition = true;\r\n  while (condition) {\r\n    outPoly.push(nextEdge.p2.p);\r\n    nextEdge = nextEdge.nextEdge;\r\n    if (nextEdge === null) { return intersectionPoint }\r\n    else if (nextEdge.intersectionPoints.length > 0) { condition = false; }\r\n  }\r\n  if (nextEdge === undefined) { return intersectionPoint }\r\n  var lastIntersection = nextEdge.intersectionPoints[0];\r\n  lastIntersection.incrementVisitCount();\r\n  outPoly.push(lastIntersection.p);\r\n  return lastIntersection\r\n}\n\nexport { index as default };\n","export const classes = {\n  CONTROL_BASE: 'mapboxgl-ctrl',\n  CONTROL_PREFIX: 'mapboxgl-ctrl-',\n  CONTROL_BUTTON: 'mapbox-gl-draw_ctrl-draw-btn',\n  CONTROL_BUTTON_LINE: 'mapbox-gl-draw_line',\n  CONTROL_BUTTON_POLYGON: 'mapbox-gl-draw_polygon',\n  CONTROL_BUTTON_POINT: 'mapbox-gl-draw_point',\n  CONTROL_BUTTON_TRASH: 'mapbox-gl-draw_trash',\n  CONTROL_BUTTON_COMBINE_FEATURES: 'mapbox-gl-draw_combine',\n  CONTROL_BUTTON_UNCOMBINE_FEATURES: 'mapbox-gl-draw_uncombine',\n  CONTROL_GROUP: 'mapboxgl-ctrl-group',\n  ATTRIBUTION: 'mapboxgl-ctrl-attrib',\n  ACTIVE_BUTTON: 'active',\n  BOX_SELECT: 'mapbox-gl-draw_boxselect'\n};\n\nexport const sources = {\n  HOT: 'mapbox-gl-draw-hot',\n  COLD: 'mapbox-gl-draw-cold'\n};\n\nexport const cursors = {\n  ADD: 'add',\n  MOVE: 'move',\n  DRAG: 'drag',\n  POINTER: 'pointer',\n  NONE: 'none'\n};\n\nexport const types = {\n  POLYGON: 'polygon',\n  LINE: 'line_string',\n  POINT: 'point'\n};\n\nexport const geojsonTypes = {\n  FEATURE: 'Feature',\n  POLYGON: 'Polygon',\n  LINE_STRING: 'LineString',\n  POINT: 'Point',\n  FEATURE_COLLECTION: 'FeatureCollection',\n  MULTI_PREFIX: 'Multi',\n  MULTI_POINT: 'MultiPoint',\n  MULTI_LINE_STRING: 'MultiLineString',\n  MULTI_POLYGON: 'MultiPolygon'\n};\n\nexport const modes = {\n  DRAW_LINE_STRING: 'draw_line_string',\n  DRAW_POLYGON: 'draw_polygon',\n  DRAW_POINT: 'draw_point',\n  SIMPLE_SELECT: 'simple_select',\n  DIRECT_SELECT: 'direct_select',\n  STATIC: 'static'\n};\n\nexport const events = {\n  CREATE: 'draw.create',\n  DELETE: 'draw.delete',\n  UPDATE: 'draw.update',\n  SELECTION_CHANGE: 'draw.selectionchange',\n  MODE_CHANGE: 'draw.modechange',\n  ACTIONABLE: 'draw.actionable',\n  RENDER: 'draw.render',\n  COMBINE_FEATURES: 'draw.combine',\n  UNCOMBINE_FEATURES: 'draw.uncombine'\n};\n\nexport const updateActions = {\n  MOVE: 'move',\n  CHANGE_COORDINATES: 'change_coordinates'\n};\n\nexport const meta = {\n  FEATURE: 'feature',\n  MIDPOINT: 'midpoint',\n  VERTEX: 'vertex'\n};\n\nexport const activeStates = {\n  ACTIVE: 'true',\n  INACTIVE: 'false'\n};\n\nexport const interactions = [\n  'scrollZoom',\n  'boxZoom',\n  'dragRotate',\n  'dragPan',\n  'keyboard',\n  'doubleClickZoom',\n  'touchZoomRotate'\n];\n\nexport const LAT_MIN = -90;\nexport const LAT_RENDERED_MIN = -85;\nexport const LAT_MAX = 90;\nexport const LAT_RENDERED_MAX = 85;\nexport const LNG_MIN = -270;\nexport const LNG_MAX = 270;\n","import { featureCollection, lineString, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a\n * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {GeoJSON} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return featureCollection(results);\n}\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    if (geometry !== null) {\n        switch (geometry.type) {\n            case \"Polygon\":\n                coords = getCoords(geometry);\n                break;\n            case \"LineString\":\n                coords = [getCoords(geometry)];\n        }\n        coords.forEach(function (coord) {\n            var segments = createSegments(coord, geojson.properties);\n            segments.forEach(function (segment) {\n                segment.id = results.length;\n                results.push(segment);\n            });\n        });\n    }\n}\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = x1 < x2 ? x1 : x2;\n    var south = y1 < y2 ? y1 : y2;\n    var east = x1 > x2 ? x1 : x2;\n    var north = y1 > y2 ? y1 : y2;\n    return [west, south, east, north];\n}\nexport default lineSegment;\n","\nexport default function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import quickselect from 'quickselect';\n\nexport default class RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.37,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return !!input && input.constructor === Object;\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            helpers.feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = helpers.lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              helpers.lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!helpers.isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return helpers.lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!helpers.isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return helpers.point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return helpers.point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return helpers.point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return helpers.point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexports.coordAll = coordAll;\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.findPoint = findPoint;\nexports.findSegment = findSegment;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    meta_1.coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexports.default = bbox;\n","var rbush = require('rbush');\nvar helpers = require('@turf/helpers');\nvar meta = require('@turf/meta');\nvar turfBBox = require('@turf/bbox').default;\nvar featureEach = meta.featureEach;\nvar coordEach = meta.coordEach;\nvar polygon = helpers.polygon;\nvar featureCollection = helpers.featureCollection;\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * var geojsonRbush = require('geojson-rbush').default;\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = new rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     * tree.insert(poly)\n     */\n    tree.insert = function (feature) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {FeatureCollection|Array<Feature>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polys = turf.polygons([\n     *     [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]],\n     *     [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     * ]);\n     * tree.load(polys);\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of Features\n        if (Array.isArray(features)) {\n            features.forEach(function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        } else {\n            // Load a FeatureCollection\n            featureEach(features, function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {Feature} feature remove single GeoJSON Feature\n     * @param {Function} equals Pass a custom equals function to compare by value for removal.\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.remove(poly);\n     */\n    tree.remove = function (feature, equals) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.remove.call(this, feature, equals);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson search with GeoJSON\n     * @returns {FeatureCollection} all features that intersects with the given GeoJSON.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.search(poly);\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return featureCollection(features);\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.collides(poly);\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection} all the features in RBush\n     * @example\n     * tree.all()\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return featureCollection(features);\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollection|Feature} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];\n        else if (geojson.type === 'Feature') bbox = turfBBox(geojson);\n        else if (geojson.type === 'FeatureCollection') bbox = turfBBox(geojson);\n        else throw new Error('invalid geojson')\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\nmodule.exports = geojsonRbush;\nmodule.exports.default = geojsonRbush;\n","import { feature, featureCollection, point, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport lineSegment from \"@turf/line-segment\";\nimport { featureEach } from \"@turf/meta\";\nimport rbush from \"geojson-rbush\";\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {GeoJSON} line1 any LineString or Polygon\n * @param {GeoJSON} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === \"LineString\") {\n        line1 = feature(line1);\n    }\n    if (line2.type === \"LineString\") {\n        line2 = feature(line2);\n    }\n    if (line1.type === \"Feature\" &&\n        line2.type === \"Feature\" &&\n        line1.geometry !== null &&\n        line2.geometry !== null &&\n        line1.geometry.type === \"LineString\" &&\n        line2.geometry.type === \"LineString\" &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) {\n            results.push(intersect);\n        }\n        return featureCollection(results);\n    }\n    // Handles complex GeoJSON Geometries\n    var tree = rbush();\n    tree.load(lineSegment(line2));\n    featureEach(lineSegment(line1), function (segment) {\n        featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = getCoords(intersect).join(\",\");\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return featureCollection(results);\n}\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = getCoords(line1);\n    var coords2 = getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error(\"<intersects> line1 must only contain 2 coordinates\");\n    }\n    if (coords2.length !== 2) {\n        throw new Error(\"<intersects> line2 must only contain 2 coordinates\");\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n    var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n    var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + uA * (x2 - x1);\n        var y = y1 + uA * (y2 - y1);\n        return point([x, y]);\n    }\n    return null;\n}\nexport default lineIntersect;\n","import { getCoord, getGeom } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nexport default function booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = getCoord(point);\n    var geom = getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] &&\n        ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&\n            (xi - pt[0]) * (xj - pt[0]) <= 0 &&\n            (yi - pt[1]) * (yj - pt[1]) <= 0;\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = yi > pt[1] !== yj > pt[1] &&\n            pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);\n}\n","import { featureCollection, lineString, multiLineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Converts a {@link Polygon} to {@link LineString|(Multi)LineString} or {@link MultiPolygon} to a\n * {@link FeatureCollection} of {@link LineString|(Multi)LineString}.\n *\n * @name polygonToLine\n * @param {Feature<Polygon|MultiPolygon>} poly Feature to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @returns {FeatureCollection|Feature<LineString|MultiLinestring>} converted (Multi)Polygon to (Multi)LineString\n * @example\n * var poly = turf.polygon([[[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]]);\n *\n * var line = turf.polygonToLine(poly);\n *\n * //addToMap\n * var addToMap = [line];\n */\nexport default function (poly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(poly);\n    if (!options.properties && poly.type === \"Feature\") {\n        options.properties = poly.properties;\n    }\n    switch (geom.type) {\n        case \"Polygon\":\n            return polygonToLine(geom, options);\n        case \"MultiPolygon\":\n            return multiPolygonToLine(geom, options);\n        default:\n            throw new Error(\"invalid poly\");\n    }\n}\n/**\n * @private\n */\nexport function polygonToLine(poly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(poly);\n    var coords = geom.coordinates;\n    var properties = options.properties\n        ? options.properties\n        : poly.type === \"Feature\"\n            ? poly.properties\n            : {};\n    return coordsToLine(coords, properties);\n}\n/**\n * @private\n */\nexport function multiPolygonToLine(multiPoly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(multiPoly);\n    var coords = geom.coordinates;\n    var properties = options.properties\n        ? options.properties\n        : multiPoly.type === \"Feature\"\n            ? multiPoly.properties\n            : {};\n    var lines = [];\n    coords.forEach(function (coord) {\n        lines.push(coordsToLine(coord, properties));\n    });\n    return featureCollection(lines);\n}\n/**\n * @private\n */\nexport function coordsToLine(coords, properties) {\n    if (coords.length > 1) {\n        return multiLineString(coords, properties);\n    }\n    return lineString(coords[0], properties);\n}\n","import booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport lineIntersect from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport polygonToLine from \"@turf/polygon-to-line\";\n/**\n * Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.\n *\n * @name booleanDisjoint\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanDisjoint(line, point);\n * //=true\n */\nfunction booleanDisjoint(feature1, feature2) {\n    var bool = true;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (bool === false) {\n                return false;\n            }\n            bool = disjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return bool;\n}\n/**\n * Disjoint operation for simple Geometries (Point/LineString/Polygon)\n *\n * @private\n * @param {Geometry<any>} geom1 GeoJSON Geometry\n * @param {Geometry<any>} geom2 GeoJSON Geometry\n * @returns {boolean} true/false\n */\nfunction disjoint(geom1, geom2) {\n    switch (geom1.type) {\n        case \"Point\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !compareCoords(geom1.coordinates, geom2.coordinates);\n                case \"LineString\":\n                    return !isPointOnLine(geom2, geom1);\n                case \"Polygon\":\n                    return !booleanPointInPolygon(geom1, geom2);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"LineString\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !isPointOnLine(geom1, geom2);\n                case \"LineString\":\n                    return !isLineOnLine(geom1, geom2);\n                case \"Polygon\":\n                    return !isLineInPoly(geom2, geom1);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"Polygon\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !booleanPointInPolygon(geom2, geom1);\n                case \"LineString\":\n                    return !isLineInPoly(geom1, geom2);\n                case \"Polygon\":\n                    return !isPolyInPoly(geom2, geom1);\n            }\n    }\n    return false;\n}\n// http://stackoverflow.com/a/11908158/1979085\nfunction isPointOnLine(lineString, pt) {\n    for (var i = 0; i < lineString.coordinates.length - 1; i++) {\n        if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], pt.coordinates)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isLineOnLine(lineString1, lineString2) {\n    var doLinesIntersect = lineIntersect(lineString1, lineString2);\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isLineInPoly(polygon, lineString) {\n    for (var _i = 0, _a = lineString.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (booleanPointInPolygon(coord, polygon)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\n/**\n * Is Polygon (geom1) in Polygon (geom2)\n * Only takes into account outer rings\n * See http://stackoverflow.com/a/4833823/1979085\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1, feature2) {\n    for (var _i = 0, _a = feature1.coordinates[0]; _i < _a.length; _i++) {\n        var coord1 = _a[_i];\n        if (booleanPointInPolygon(coord1, feature2)) {\n            return true;\n        }\n    }\n    for (var _b = 0, _c = feature2.coordinates[0]; _b < _c.length; _b++) {\n        var coord2 = _c[_b];\n        if (booleanPointInPolygon(coord2, feature1)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(polygonToLine(feature1), polygonToLine(feature2));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {\n    var dxc = pt[0] - lineSegmentStart[0];\n    var dyc = pt[1] - lineSegmentStart[1];\n    var dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n    var dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0) {\n        return false;\n    }\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n        if (dxl > 0) {\n            return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];\n        }\n        else {\n            return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n        }\n    }\n    else if (dyl > 0) {\n        return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];\n    }\n    else {\n        return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n    }\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexport default booleanDisjoint;\n","import { flattenEach } from '@turf/meta';\nimport { getType, getCoords } from '@turf/invariant';\nimport { isObject, lineString, multiLineString, lengthToDegrees } from '@turf/helpers';\n\n/**\n * https://github.com/rook2pawn/node-intersection\n *\n * Author @rook2pawn\n */\n\n/**\n * AB\n *\n * @private\n * @param {Array<Array<number>>} segment - 2 vertex line segment\n * @returns {Array<number>} coordinates [x, y]\n */\nfunction ab(segment) {\n  var start = segment[0];\n  var end = segment[1];\n  return [end[0] - start[0], end[1] - start[1]];\n}\n\n/**\n * Cross Product\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Cross Product\n */\nfunction crossProduct(v1, v2) {\n  return v1[0] * v2[1] - v2[0] * v1[1];\n}\n\n/**\n * Add\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Add\n */\nfunction add(v1, v2) {\n  return [v1[0] + v2[0], v1[1] + v2[1]];\n}\n\n/**\n * Sub\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Sub\n */\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\n/**\n * scalarMult\n *\n * @private\n * @param {number} s scalar\n * @param {Array<number>} v coordinates [x, y]\n * @returns {Array<number>} scalarMult\n */\nfunction scalarMult(s, v) {\n  return [s * v[0], s * v[1]];\n}\n\n/**\n * Intersect Segments\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {Array<number>} intersection\n */\nfunction intersectSegments(a, b) {\n  var p = a[0];\n  var r = ab(a);\n  var q = b[0];\n  var s = ab(b);\n\n  var cross = crossProduct(r, s);\n  var qmp = sub(q, p);\n  var numerator = crossProduct(qmp, s);\n  var t = numerator / cross;\n  var intersection = add(p, scalarMult(t, r));\n  return intersection;\n}\n\n/**\n * Is Parallel\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {boolean} true if a and b are parallel (or co-linear)\n */\nfunction isParallel(a, b) {\n  var r = ab(a);\n  var s = ab(b);\n  return crossProduct(r, s) === 0;\n}\n\n/**\n * Intersection\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {Array<number>|boolean} true if a and b are parallel (or co-linear)\n */\nfunction intersection(a, b) {\n  if (isParallel(a, b)) return false;\n  return intersectSegments(a, b);\n}\n\n/**\n * Takes a {@link LineString|line} and returns a {@link LineString|line} at offset by the specified distance.\n *\n * @name lineOffset\n * @param {Geometry|Feature<LineString|MultiLineString>} geojson input GeoJSON\n * @param {number} distance distance to offset the line (can be of negative value)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, kilometers, inches, yards, meters\n * @returns {Feature<LineString|MultiLineString>} Line offset from the input line\n * @example\n * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]], { \"stroke\": \"#F00\" });\n *\n * var offsetLine = turf.lineOffset(line, 2, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [offsetLine, line]\n * offsetLine.properties.stroke = \"#00F\"\n */\nfunction lineOffset(geojson, distance, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n\n  // Valdiation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (distance === undefined || distance === null || isNaN(distance))\n    throw new Error(\"distance is required\");\n\n  var type = getType(geojson);\n  var properties = geojson.properties;\n\n  switch (type) {\n    case \"LineString\":\n      return lineOffsetFeature(geojson, distance, units);\n    case \"MultiLineString\":\n      var coords = [];\n      flattenEach(geojson, function (feature) {\n        coords.push(\n          lineOffsetFeature(feature, distance, units).geometry.coordinates\n        );\n      });\n      return multiLineString(coords, properties);\n    default:\n      throw new Error(\"geometry \" + type + \" is not supported\");\n  }\n}\n\n/**\n * Line Offset\n *\n * @private\n * @param {Geometry|Feature<LineString>} line input line\n * @param {number} distance distance to offset the line (can be of negative value)\n * @param {string} [units=kilometers] units\n * @returns {Feature<LineString>} Line offset from the input line\n */\nfunction lineOffsetFeature(line, distance, units) {\n  var segments = [];\n  var offsetDegrees = lengthToDegrees(distance, units);\n  var coords = getCoords(line);\n  var finalCoords = [];\n  coords.forEach(function (currentCoords, index) {\n    if (index !== coords.length - 1) {\n      var segment = processSegment(\n        currentCoords,\n        coords[index + 1],\n        offsetDegrees\n      );\n      segments.push(segment);\n      if (index > 0) {\n        var seg2Coords = segments[index - 1];\n        var intersects = intersection(segment, seg2Coords);\n\n        // Handling for line segments that aren't straight\n        if (intersects !== false) {\n          seg2Coords[1] = intersects;\n          segment[0] = intersects;\n        }\n\n        finalCoords.push(seg2Coords[0]);\n        if (index === coords.length - 2) {\n          finalCoords.push(segment[0]);\n          finalCoords.push(segment[1]);\n        }\n      }\n      // Handling for lines that only have 1 segment\n      if (coords.length === 2) {\n        finalCoords.push(segment[0]);\n        finalCoords.push(segment[1]);\n      }\n    }\n  });\n  return lineString(finalCoords, line.properties);\n}\n\n/**\n * Process Segment\n * Inspiration taken from http://stackoverflow.com/questions/2825412/draw-a-parallel-line\n *\n * @private\n * @param {Array<number>} point1 Point coordinates\n * @param {Array<number>} point2 Point coordinates\n * @param {number} offset Offset\n * @returns {Array<Array<number>>} offset points\n */\nfunction processSegment(point1, point2, offset) {\n  var L = Math.sqrt(\n    (point1[0] - point2[0]) * (point1[0] - point2[0]) +\n      (point1[1] - point2[1]) * (point1[1] - point2[1])\n  );\n\n  var out1x = point1[0] + (offset * (point2[1] - point1[1])) / L;\n  var out2x = point2[0] + (offset * (point2[1] - point1[1])) / L;\n  var out1y = point1[1] + (offset * (point1[0] - point2[0])) / L;\n  var out2y = point2[1] + (offset * (point1[0] - point2[0])) / L;\n  return [\n    [out1x, out1y],\n    [out2x, out2y],\n  ];\n}\n\nexport default lineOffset;\n","import { coordEach } from \"@turf/meta\";\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexport default bbox;\n","import turfBBox from \"@turf/bbox\";\nimport { getCoords, getGeom } from \"@turf/invariant\";\nimport { polygon, multiPolygon, lineString, } from \"@turf/helpers\";\nimport clone from \"@turf/clone\";\n/**\n * Converts (Multi)LineString(s) to Polygon(s).\n *\n * @name lineToPolygon\n * @param {FeatureCollection|Feature<LineString|MultiLineString>} lines Features to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @param {boolean} [options.autoComplete=true] auto complete linestrings (matches first & last coordinates)\n * @param {boolean} [options.orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\n * @param {boolean} [options.mutate=false] mutate the original linestring using autoComplete (matches first & last coordinates)\n * @returns {Feature<Polygon|MultiPolygon>} converted to Polygons\n * @example\n * var line = turf.lineString([[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]);\n *\n * var polygon = turf.lineToPolygon(line);\n *\n * //addToMap\n * var addToMap = [polygon];\n */\nfunction lineToPolygon(lines, options) {\n    if (options === void 0) { options = {}; }\n    var _a, _b, _c;\n    // Optional parameters\n    var properties = options.properties;\n    var autoComplete = (_a = options.autoComplete) !== null && _a !== void 0 ? _a : true;\n    var orderCoords = (_b = options.orderCoords) !== null && _b !== void 0 ? _b : true;\n    var mutate = (_c = options.mutate) !== null && _c !== void 0 ? _c : false;\n    if (!mutate) {\n        lines = clone(lines);\n    }\n    switch (lines.type) {\n        case \"FeatureCollection\":\n            var coords = [];\n            lines.features.forEach(function (line) {\n                coords.push(getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords)));\n            });\n            return multiPolygon(coords, properties);\n        default:\n            return lineStringToPolygon(lines, properties, autoComplete, orderCoords);\n    }\n}\n/**\n * LineString to Polygon\n *\n * @private\n * @param {Feature<LineString|MultiLineString>} line line\n * @param {Object} [properties] translates GeoJSON properties to Feature\n * @param {boolean} [autoComplete=true] auto complete linestrings\n * @param {boolean} [orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\n * @returns {Feature<Polygon>} line converted to Polygon\n */\nfunction lineStringToPolygon(line, properties, autoComplete, orderCoords) {\n    properties = properties\n        ? properties\n        : line.type === \"Feature\"\n            ? line.properties\n            : {};\n    var geom = getGeom(line);\n    var coords = geom.coordinates;\n    var type = geom.type;\n    if (!coords.length)\n        throw new Error(\"line must contain coordinates\");\n    switch (type) {\n        case \"LineString\":\n            if (autoComplete)\n                coords = autoCompleteCoords(coords);\n            return polygon([coords], properties);\n        case \"MultiLineString\":\n            var multiCoords = [];\n            var largestArea = 0;\n            coords.forEach(function (coord) {\n                if (autoComplete)\n                    coord = autoCompleteCoords(coord);\n                // Largest LineString to be placed in the first position of the coordinates array\n                if (orderCoords) {\n                    var area = calculateArea(turfBBox(lineString(coord)));\n                    if (area > largestArea) {\n                        multiCoords.unshift(coord);\n                        largestArea = area;\n                    }\n                    else\n                        multiCoords.push(coord);\n                }\n                else {\n                    multiCoords.push(coord);\n                }\n            });\n            return polygon(multiCoords, properties);\n        default:\n            throw new Error(\"geometry type \" + type + \" is not supported\");\n    }\n}\n/**\n * Auto Complete Coords - matches first & last coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords Coordinates\n * @returns {Array<Array<number>>} auto completed coordinates\n */\nfunction autoCompleteCoords(coords) {\n    var first = coords[0];\n    var x1 = first[0];\n    var y1 = first[1];\n    var last = coords[coords.length - 1];\n    var x2 = last[0];\n    var y2 = last[1];\n    if (x1 !== x2 || y1 !== y2) {\n        coords.push(first);\n    }\n    return coords;\n}\n/**\n * area - quick approximate area calculation (used to sort)\n *\n * @private\n * @param {Array<number>} bbox BBox [west, south, east, north]\n * @returns {number} very quick area calculation\n */\nfunction calculateArea(bbox) {\n    var west = bbox[0];\n    var south = bbox[1];\n    var east = bbox[2];\n    var north = bbox[3];\n    return Math.abs(west - east) * Math.abs(south - north);\n}\nexport default lineToPolygon;\n","/**\n * splaytree v3.1.1\n * Fast Splay tree for Node and browser\n *\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nvar Node = /** @class */ (function () {\r\n    function Node(key, data) {\r\n        this.next = null;\r\n        this.key = key;\r\n        this.data = data;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n    return Node;\r\n}());\n\n/* follows \"An implementation of top-down splaying\"\r\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n */\r\nfunction DEFAULT_COMPARE(a, b) {\r\n    return a > b ? 1 : a < b ? -1 : 0;\r\n}\r\n/**\r\n * Simple top down splay, not requiring i to be in the tree t.\r\n */\r\nfunction splay(i, t, comparator) {\r\n    var N = new Node(null, null);\r\n    var l = N;\r\n    var r = N;\r\n    while (true) {\r\n        var cmp = comparator(i, t.key);\r\n        //if (i < t.key) {\r\n        if (cmp < 0) {\r\n            if (t.left === null)\r\n                break;\r\n            //if (i < t.left.key) {\r\n            if (comparator(i, t.left.key) < 0) {\r\n                var y = t.left; /* rotate right */\r\n                t.left = y.right;\r\n                y.right = t;\r\n                t = y;\r\n                if (t.left === null)\r\n                    break;\r\n            }\r\n            r.left = t; /* link right */\r\n            r = t;\r\n            t = t.left;\r\n            //} else if (i > t.key) {\r\n        }\r\n        else if (cmp > 0) {\r\n            if (t.right === null)\r\n                break;\r\n            //if (i > t.right.key) {\r\n            if (comparator(i, t.right.key) > 0) {\r\n                var y = t.right; /* rotate left */\r\n                t.right = y.left;\r\n                y.left = t;\r\n                t = y;\r\n                if (t.right === null)\r\n                    break;\r\n            }\r\n            l.right = t; /* link left */\r\n            l = t;\r\n            t = t.right;\r\n        }\r\n        else\r\n            break;\r\n    }\r\n    /* assemble */\r\n    l.right = t.left;\r\n    r.left = t.right;\r\n    t.left = N.right;\r\n    t.right = N.left;\r\n    return t;\r\n}\r\nfunction insert(i, data, t, comparator) {\r\n    var node = new Node(i, data);\r\n    if (t === null) {\r\n        node.left = node.right = null;\r\n        return node;\r\n    }\r\n    t = splay(i, t, comparator);\r\n    var cmp = comparator(i, t.key);\r\n    if (cmp < 0) {\r\n        node.left = t.left;\r\n        node.right = t;\r\n        t.left = null;\r\n    }\r\n    else if (cmp >= 0) {\r\n        node.right = t.right;\r\n        node.left = t;\r\n        t.right = null;\r\n    }\r\n    return node;\r\n}\r\nfunction split(key, v, comparator) {\r\n    var left = null;\r\n    var right = null;\r\n    if (v) {\r\n        v = splay(key, v, comparator);\r\n        var cmp = comparator(v.key, key);\r\n        if (cmp === 0) {\r\n            left = v.left;\r\n            right = v.right;\r\n        }\r\n        else if (cmp < 0) {\r\n            right = v.right;\r\n            v.right = null;\r\n            left = v;\r\n        }\r\n        else {\r\n            left = v.left;\r\n            v.left = null;\r\n            right = v;\r\n        }\r\n    }\r\n    return { left: left, right: right };\r\n}\r\nfunction merge(left, right, comparator) {\r\n    if (right === null)\r\n        return left;\r\n    if (left === null)\r\n        return right;\r\n    right = splay(left.key, right, comparator);\r\n    right.left = left;\r\n    return right;\r\n}\r\n/**\r\n * Prints level of the tree\r\n */\r\nfunction printRow(root, prefix, isTail, out, printNode) {\r\n    if (root) {\r\n        out(\"\" + prefix + (isTail ? ' ' : ' ') + printNode(root) + \"\\n\");\r\n        var indent = prefix + (isTail ? '    ' : '   ');\r\n        if (root.left)\r\n            printRow(root.left, indent, false, out, printNode);\r\n        if (root.right)\r\n            printRow(root.right, indent, true, out, printNode);\r\n    }\r\n}\r\nvar Tree = /** @class */ (function () {\r\n    function Tree(comparator) {\r\n        if (comparator === void 0) { comparator = DEFAULT_COMPARE; }\r\n        this._root = null;\r\n        this._size = 0;\r\n        this._comparator = comparator;\r\n    }\r\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\r\n    Tree.prototype.insert = function (key, data) {\r\n        this._size++;\r\n        return this._root = insert(key, data, this._root, this._comparator);\r\n    };\r\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\r\n    Tree.prototype.add = function (key, data) {\r\n        var node = new Node(key, data);\r\n        if (this._root === null) {\r\n            node.left = node.right = null;\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        var comparator = this._comparator;\r\n        var t = splay(key, this._root, comparator);\r\n        var cmp = comparator(key, t.key);\r\n        if (cmp === 0)\r\n            this._root = t;\r\n        else {\r\n            if (cmp < 0) {\r\n                node.left = t.left;\r\n                node.right = t;\r\n                t.left = null;\r\n            }\r\n            else if (cmp > 0) {\r\n                node.right = t.right;\r\n                node.left = t;\r\n                t.right = null;\r\n            }\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        return this._root;\r\n    };\r\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\r\n    Tree.prototype.remove = function (key) {\r\n        this._root = this._remove(key, this._root, this._comparator);\r\n    };\r\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\r\n    Tree.prototype._remove = function (i, t, comparator) {\r\n        var x;\r\n        if (t === null)\r\n            return null;\r\n        t = splay(i, t, comparator);\r\n        var cmp = comparator(i, t.key);\r\n        if (cmp === 0) { /* found it */\r\n            if (t.left === null) {\r\n                x = t.right;\r\n            }\r\n            else {\r\n                x = splay(i, t.left, comparator);\r\n                x.right = t.right;\r\n            }\r\n            this._size--;\r\n            return x;\r\n        }\r\n        return t; /* It wasn't there */\r\n    };\r\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\r\n    Tree.prototype.pop = function () {\r\n        var node = this._root;\r\n        if (node) {\r\n            while (node.left)\r\n                node = node.left;\r\n            this._root = splay(node.key, this._root, this._comparator);\r\n            this._root = this._remove(node.key, this._root, this._comparator);\r\n            return { key: node.key, data: node.data };\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Find without splaying\r\n     */\r\n    Tree.prototype.findStatic = function (key) {\r\n        var current = this._root;\r\n        var compare = this._comparator;\r\n        while (current) {\r\n            var cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return current;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return null;\r\n    };\r\n    Tree.prototype.find = function (key) {\r\n        if (this._root) {\r\n            this._root = splay(key, this._root, this._comparator);\r\n            if (this._comparator(key, this._root.key) !== 0)\r\n                return null;\r\n        }\r\n        return this._root;\r\n    };\r\n    Tree.prototype.contains = function (key) {\r\n        var current = this._root;\r\n        var compare = this._comparator;\r\n        while (current) {\r\n            var cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return true;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return false;\r\n    };\r\n    Tree.prototype.forEach = function (visitor, ctx) {\r\n        var current = this._root;\r\n        var Q = []; /* Initialize stack s */\r\n        var done = false;\r\n        while (!done) {\r\n            if (current !== null) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length !== 0) {\r\n                    current = Q.pop();\r\n                    visitor.call(ctx, current);\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\r\n    Tree.prototype.range = function (low, high, fn, ctx) {\r\n        var Q = [];\r\n        var compare = this._comparator;\r\n        var node = this._root;\r\n        var cmp;\r\n        while (Q.length !== 0 || node) {\r\n            if (node) {\r\n                Q.push(node);\r\n                node = node.left;\r\n            }\r\n            else {\r\n                node = Q.pop();\r\n                cmp = compare(node.key, high);\r\n                if (cmp > 0) {\r\n                    break;\r\n                }\r\n                else if (compare(node.key, low) >= 0) {\r\n                    if (fn.call(ctx, node))\r\n                        return this; // stop if smth is returned\r\n                }\r\n                node = node.right;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns array of keys\r\n     */\r\n    Tree.prototype.keys = function () {\r\n        var keys = [];\r\n        this.forEach(function (_a) {\r\n            var key = _a.key;\r\n            return keys.push(key);\r\n        });\r\n        return keys;\r\n    };\r\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\r\n    Tree.prototype.values = function () {\r\n        var values = [];\r\n        this.forEach(function (_a) {\r\n            var data = _a.data;\r\n            return values.push(data);\r\n        });\r\n        return values;\r\n    };\r\n    Tree.prototype.min = function () {\r\n        if (this._root)\r\n            return this.minNode(this._root).key;\r\n        return null;\r\n    };\r\n    Tree.prototype.max = function () {\r\n        if (this._root)\r\n            return this.maxNode(this._root).key;\r\n        return null;\r\n    };\r\n    Tree.prototype.minNode = function (t) {\r\n        if (t === void 0) { t = this._root; }\r\n        if (t)\r\n            while (t.left)\r\n                t = t.left;\r\n        return t;\r\n    };\r\n    Tree.prototype.maxNode = function (t) {\r\n        if (t === void 0) { t = this._root; }\r\n        if (t)\r\n            while (t.right)\r\n                t = t.right;\r\n        return t;\r\n    };\r\n    /**\r\n     * Returns node at given index\r\n     */\r\n    Tree.prototype.at = function (index) {\r\n        var current = this._root;\r\n        var done = false;\r\n        var i = 0;\r\n        var Q = [];\r\n        while (!done) {\r\n            if (current) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length > 0) {\r\n                    current = Q.pop();\r\n                    if (i === index)\r\n                        return current;\r\n                    i++;\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    Tree.prototype.next = function (d) {\r\n        var root = this._root;\r\n        var successor = null;\r\n        if (d.right) {\r\n            successor = d.right;\r\n            while (successor.left)\r\n                successor = successor.left;\r\n            return successor;\r\n        }\r\n        var comparator = this._comparator;\r\n        while (root) {\r\n            var cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0) {\r\n                successor = root;\r\n                root = root.left;\r\n            }\r\n            else\r\n                root = root.right;\r\n        }\r\n        return successor;\r\n    };\r\n    Tree.prototype.prev = function (d) {\r\n        var root = this._root;\r\n        var predecessor = null;\r\n        if (d.left !== null) {\r\n            predecessor = d.left;\r\n            while (predecessor.right)\r\n                predecessor = predecessor.right;\r\n            return predecessor;\r\n        }\r\n        var comparator = this._comparator;\r\n        while (root) {\r\n            var cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0)\r\n                root = root.left;\r\n            else {\r\n                predecessor = root;\r\n                root = root.right;\r\n            }\r\n        }\r\n        return predecessor;\r\n    };\r\n    Tree.prototype.clear = function () {\r\n        this._root = null;\r\n        this._size = 0;\r\n        return this;\r\n    };\r\n    Tree.prototype.toList = function () {\r\n        return toList(this._root);\r\n    };\r\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\r\n    Tree.prototype.load = function (keys, values, presort) {\r\n        if (values === void 0) { values = []; }\r\n        if (presort === void 0) { presort = false; }\r\n        var size = keys.length;\r\n        var comparator = this._comparator;\r\n        // sort if needed\r\n        if (presort)\r\n            sort(keys, values, 0, size - 1, comparator);\r\n        if (this._root === null) { // empty tree\r\n            this._root = loadRecursive(keys, values, 0, size);\r\n            this._size = size;\r\n        }\r\n        else { // that re-builds the whole tree from two in-order traversals\r\n            var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\r\n            size = this._size + size;\r\n            this._root = sortedListToBST({ head: mergedList }, 0, size);\r\n        }\r\n        return this;\r\n    };\r\n    Tree.prototype.isEmpty = function () { return this._root === null; };\r\n    Object.defineProperty(Tree.prototype, \"size\", {\r\n        get: function () { return this._size; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Tree.prototype, \"root\", {\r\n        get: function () { return this._root; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Tree.prototype.toString = function (printNode) {\r\n        if (printNode === void 0) { printNode = function (n) { return String(n.key); }; }\r\n        var out = [];\r\n        printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);\r\n        return out.join('');\r\n    };\r\n    Tree.prototype.update = function (key, newKey, newData) {\r\n        var comparator = this._comparator;\r\n        var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;\r\n        if (comparator(key, newKey) < 0) {\r\n            right = insert(newKey, newData, right, comparator);\r\n        }\r\n        else {\r\n            left = insert(newKey, newData, left, comparator);\r\n        }\r\n        this._root = merge(left, right, comparator);\r\n    };\r\n    Tree.prototype.split = function (key) {\r\n        return split(key, this._root, this._comparator);\r\n    };\r\n    Tree.prototype[Symbol.iterator] = function () {\r\n        var n;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    n = this.minNode();\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!n) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, n];\r\n                case 2:\r\n                    _a.sent();\r\n                    n = this.next(n);\r\n                    return [3 /*break*/, 1];\r\n                case 3: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    return Tree;\r\n}());\r\nfunction loadRecursive(keys, values, start, end) {\r\n    var size = end - start;\r\n    if (size > 0) {\r\n        var middle = start + Math.floor(size / 2);\r\n        var key = keys[middle];\r\n        var data = values[middle];\r\n        var node = new Node(key, data);\r\n        node.left = loadRecursive(keys, values, start, middle);\r\n        node.right = loadRecursive(keys, values, middle + 1, end);\r\n        return node;\r\n    }\r\n    return null;\r\n}\r\nfunction createList(keys, values) {\r\n    var head = new Node(null, null);\r\n    var p = head;\r\n    for (var i = 0; i < keys.length; i++) {\r\n        p = p.next = new Node(keys[i], values[i]);\r\n    }\r\n    p.next = null;\r\n    return head.next;\r\n}\r\nfunction toList(root) {\r\n    var current = root;\r\n    var Q = [];\r\n    var done = false;\r\n    var head = new Node(null, null);\r\n    var p = head;\r\n    while (!done) {\r\n        if (current) {\r\n            Q.push(current);\r\n            current = current.left;\r\n        }\r\n        else {\r\n            if (Q.length > 0) {\r\n                current = p = p.next = Q.pop();\r\n                current = current.right;\r\n            }\r\n            else\r\n                done = true;\r\n        }\r\n    }\r\n    p.next = null; // that'll work even if the tree was empty\r\n    return head.next;\r\n}\r\nfunction sortedListToBST(list, start, end) {\r\n    var size = end - start;\r\n    if (size > 0) {\r\n        var middle = start + Math.floor(size / 2);\r\n        var left = sortedListToBST(list, start, middle);\r\n        var root = list.head;\r\n        root.left = left;\r\n        list.head = list.head.next;\r\n        root.right = sortedListToBST(list, middle + 1, end);\r\n        return root;\r\n    }\r\n    return null;\r\n}\r\nfunction mergeLists(l1, l2, compare) {\r\n    var head = new Node(null, null); // dummy\r\n    var p = head;\r\n    var p1 = l1;\r\n    var p2 = l2;\r\n    while (p1 !== null && p2 !== null) {\r\n        if (compare(p1.key, p2.key) < 0) {\r\n            p.next = p1;\r\n            p1 = p1.next;\r\n        }\r\n        else {\r\n            p.next = p2;\r\n            p2 = p2.next;\r\n        }\r\n        p = p.next;\r\n    }\r\n    if (p1 !== null) {\r\n        p.next = p1;\r\n    }\r\n    else if (p2 !== null) {\r\n        p.next = p2;\r\n    }\r\n    return head.next;\r\n}\r\nfunction sort(keys, values, left, right, compare) {\r\n    if (left >= right)\r\n        return;\r\n    var pivot = keys[(left + right) >> 1];\r\n    var i = left - 1;\r\n    var j = right + 1;\r\n    while (true) {\r\n        do\r\n            i++;\r\n        while (compare(keys[i], pivot) < 0);\r\n        do\r\n            j--;\r\n        while (compare(keys[j], pivot) > 0);\r\n        if (i >= j)\r\n            break;\r\n        var tmp = keys[i];\r\n        keys[i] = keys[j];\r\n        keys[j] = tmp;\r\n        tmp = values[i];\r\n        values[i] = values[j];\r\n        values[j] = tmp;\r\n    }\r\n    sort(keys, values, left, j, compare);\r\n    sort(keys, values, j + 1, right, compare);\r\n}\n\nexport default Tree;\n//# sourceMappingURL=splay.esm.js.map\n","import SplayTree from 'splaytree';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */\nvar isInBbox = function isInBbox(bbox, point) {\n  return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n};\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */\n\nvar getBboxOverlap = function getBboxOverlap(b1, b2) {\n  // check if the bboxes overlap at all\n  if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values\n\n  var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n  var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values\n\n  var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n  var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap\n\n  return {\n    ll: {\n      x: lowerX,\n      y: lowerY\n    },\n    ur: {\n      x: upperX,\n      y: upperY\n    }\n  };\n};\n\n/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */\nvar epsilon = Number.EPSILON; // IE Polyfill\n\nif (epsilon === undefined) epsilon = Math.pow(2, -52);\nvar EPSILON_SQ = epsilon * epsilon;\n/* FLP comparator */\n\nvar cmp = function cmp(a, b) {\n  // check if they're both 0\n  if (-epsilon < a && a < epsilon) {\n    if (-epsilon < b && b < epsilon) {\n      return 0;\n    }\n  } // check if they're flp equal\n\n\n  var ab = a - b;\n\n  if (ab * ab < EPSILON_SQ * a * b) {\n    return 0;\n  } // normal comparison\n\n\n  return a < b ? -1 : 1;\n};\n\n/**\n * This class rounds incoming values sufficiently so that\n * floating points problems are, for the most part, avoided.\n *\n * Incoming points are have their x & y values tested against\n * all previously seen x & y values. If either is 'too close'\n * to a previously seen value, it's value is 'snapped' to the\n * previously seen value.\n *\n * All points should be rounded by this class before being\n * stored in any data structures in the rest of this algorithm.\n */\n\nvar PtRounder = /*#__PURE__*/function () {\n  function PtRounder() {\n    _classCallCheck(this, PtRounder);\n\n    this.reset();\n  }\n\n  _createClass(PtRounder, [{\n    key: \"reset\",\n    value: function reset() {\n      this.xRounder = new CoordRounder();\n      this.yRounder = new CoordRounder();\n    }\n  }, {\n    key: \"round\",\n    value: function round(x, y) {\n      return {\n        x: this.xRounder.round(x),\n        y: this.yRounder.round(y)\n      };\n    }\n  }]);\n\n  return PtRounder;\n}();\n\nvar CoordRounder = /*#__PURE__*/function () {\n  function CoordRounder() {\n    _classCallCheck(this, CoordRounder);\n\n    this.tree = new SplayTree(); // preseed with 0 so we don't end up with values < Number.EPSILON\n\n    this.round(0);\n  } // Note: this can rounds input values backwards or forwards.\n  //       You might ask, why not restrict this to just rounding\n  //       forwards? Wouldn't that allow left endpoints to always\n  //       remain left endpoints during splitting (never change to\n  //       right). No - it wouldn't, because we snap intersections\n  //       to endpoints (to establish independence from the segment\n  //       angle for t-intersections).\n\n\n  _createClass(CoordRounder, [{\n    key: \"round\",\n    value: function round(coord) {\n      var node = this.tree.add(coord);\n      var prevNode = this.tree.prev(node);\n\n      if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n        this.tree.remove(coord);\n        return prevNode.key;\n      }\n\n      var nextNode = this.tree.next(node);\n\n      if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n        this.tree.remove(coord);\n        return nextNode.key;\n      }\n\n      return coord;\n    }\n  }]);\n\n  return CoordRounder;\n}(); // singleton available by import\n\n\nvar rounder = new PtRounder();\n\n/* Cross Product of two vectors with first point at origin */\n\nvar crossProduct = function crossProduct(a, b) {\n  return a.x * b.y - a.y * b.x;\n};\n/* Dot Product of two vectors with first point at origin */\n\nvar dotProduct = function dotProduct(a, b) {\n  return a.x * b.x + a.y * b.y;\n};\n/* Comparator for two vectors with same starting point */\n\nvar compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {\n  var v1 = {\n    x: endPt1.x - basePt.x,\n    y: endPt1.y - basePt.y\n  };\n  var v2 = {\n    x: endPt2.x - basePt.x,\n    y: endPt2.y - basePt.y\n  };\n  var kross = crossProduct(v1, v2);\n  return cmp(kross, 0);\n};\nvar length = function length(v) {\n  return Math.sqrt(dotProduct(v, v));\n};\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\n\nvar sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {\n  var vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  var vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\n\nvar cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {\n  var vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  var vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar horizontalIntersection = function horizontalIntersection(pt, v, y) {\n  if (v.y === 0) return null;\n  return {\n    x: pt.x + v.x / v.y * (y - pt.y),\n    y: y\n  };\n};\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar verticalIntersection = function verticalIntersection(pt, v, x) {\n  if (v.x === 0) return null;\n  return {\n    x: x,\n    y: pt.y + v.y / v.x * (x - pt.x)\n  };\n};\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar intersection = function intersection(pt1, v1, pt2, v2) {\n  // take some shortcuts for vertical and horizontal lines\n  // this also ensures we don't calculate an intersection and then discover\n  // it's actually outside the bounding box of the line\n  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.\n  // This algorithm is based on Schneider and Eberly.\n  // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n  var kross = crossProduct(v1, v2);\n  if (kross == 0) return null;\n  var ve = {\n    x: pt2.x - pt1.x,\n    y: pt2.y - pt1.y\n  };\n  var d1 = crossProduct(ve, v1) / kross;\n  var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error\n\n  var x1 = pt1.x + d2 * v1.x,\n      x2 = pt2.x + d1 * v2.x;\n  var y1 = pt1.y + d2 * v1.y,\n      y2 = pt2.y + d1 * v2.y;\n  var x = (x1 + x2) / 2;\n  var y = (y1 + y2) / 2;\n  return {\n    x: x,\n    y: y\n  };\n};\n\nvar SweepEvent = /*#__PURE__*/function () {\n  _createClass(SweepEvent, null, [{\n    key: \"compare\",\n    // for ordering sweep events in the sweep event queue\n    value: function compare(a, b) {\n      // favor event with a point that the sweep line hits first\n      var ptCmp = SweepEvent.comparePoints(a.point, b.point);\n      if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed\n\n      if (a.point !== b.point) a.link(b); // favor right events over left\n\n      if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints\n      // ordering of this case is the same as for their segments\n\n      return Segment.compare(a.segment, b.segment);\n    } // for ordering points in sweep line order\n\n  }, {\n    key: \"comparePoints\",\n    value: function comparePoints(aPt, bPt) {\n      if (aPt.x < bPt.x) return -1;\n      if (aPt.x > bPt.x) return 1;\n      if (aPt.y < bPt.y) return -1;\n      if (aPt.y > bPt.y) return 1;\n      return 0;\n    } // Warning: 'point' input will be modified and re-used (for performance)\n\n  }]);\n\n  function SweepEvent(point, isLeft) {\n    _classCallCheck(this, SweepEvent);\n\n    if (point.events === undefined) point.events = [this];else point.events.push(this);\n    this.point = point;\n    this.isLeft = isLeft; // this.segment, this.otherSE set by factory\n  }\n\n  _createClass(SweepEvent, [{\n    key: \"link\",\n    value: function link(other) {\n      if (other.point === this.point) {\n        throw new Error('Tried to link already linked events');\n      }\n\n      var otherEvents = other.point.events;\n\n      for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {\n        var evt = otherEvents[i];\n        this.point.events.push(evt);\n        evt.point = this.point;\n      }\n\n      this.checkForConsuming();\n    }\n    /* Do a pass over our linked events and check to see if any pair\n     * of segments match, and should be consumed. */\n\n  }, {\n    key: \"checkForConsuming\",\n    value: function checkForConsuming() {\n      // FIXME: The loops in this method run O(n^2) => no good.\n      //        Maintain little ordered sweep event trees?\n      //        Can we maintaining an ordering that avoids the need\n      //        for the re-sorting with getLeftmostComparator in geom-out?\n      // Compare each pair of events to see if other events also match\n      var numEvents = this.point.events.length;\n\n      for (var i = 0; i < numEvents; i++) {\n        var evt1 = this.point.events[i];\n        if (evt1.segment.consumedBy !== undefined) continue;\n\n        for (var j = i + 1; j < numEvents; j++) {\n          var evt2 = this.point.events[j];\n          if (evt2.consumedBy !== undefined) continue;\n          if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n          evt1.segment.consume(evt2.segment);\n        }\n      }\n    }\n  }, {\n    key: \"getAvailableLinkedEvents\",\n    value: function getAvailableLinkedEvents() {\n      // point.events is always of length 2 or greater\n      var events = [];\n\n      for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {\n        var evt = this.point.events[i];\n\n        if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n          events.push(evt);\n        }\n      }\n\n      return events;\n    }\n    /**\n     * Returns a comparator function for sorting linked events that will\n     * favor the event that will give us the smallest left-side angle.\n     * All ring construction starts as low as possible heading to the right,\n     * so by always turning left as sharp as possible we'll get polygons\n     * without uncessary loops & holes.\n     *\n     * The comparator function has a compute cache such that it avoids\n     * re-computing already-computed values.\n     */\n\n  }, {\n    key: \"getLeftmostComparator\",\n    value: function getLeftmostComparator(baseEvent) {\n      var _this = this;\n\n      var cache = new Map();\n\n      var fillCache = function fillCache(linkedEvent) {\n        var nextEvent = linkedEvent.otherSE;\n        cache.set(linkedEvent, {\n          sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),\n          cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)\n        });\n      };\n\n      return function (a, b) {\n        if (!cache.has(a)) fillCache(a);\n        if (!cache.has(b)) fillCache(b);\n\n        var _cache$get = cache.get(a),\n            asine = _cache$get.sine,\n            acosine = _cache$get.cosine;\n\n        var _cache$get2 = cache.get(b),\n            bsine = _cache$get2.sine,\n            bcosine = _cache$get2.cosine; // both on or above x-axis\n\n\n        if (asine >= 0 && bsine >= 0) {\n          if (acosine < bcosine) return 1;\n          if (acosine > bcosine) return -1;\n          return 0;\n        } // both below x-axis\n\n\n        if (asine < 0 && bsine < 0) {\n          if (acosine < bcosine) return -1;\n          if (acosine > bcosine) return 1;\n          return 0;\n        } // one above x-axis, one below\n\n\n        if (bsine < asine) return -1;\n        if (bsine > asine) return 1;\n        return 0;\n      };\n    }\n  }]);\n\n  return SweepEvent;\n}();\n\n// segments and sweep events when all else is identical\n\nvar segmentId = 0;\n\nvar Segment = /*#__PURE__*/function () {\n  _createClass(Segment, null, [{\n    key: \"compare\",\n\n    /* This compare() function is for ordering segments in the sweep\n     * line tree, and does so according to the following criteria:\n     *\n     * Consider the vertical line that lies an infinestimal step to the\n     * right of the right-more of the two left endpoints of the input\n     * segments. Imagine slowly moving a point up from negative infinity\n     * in the increasing y direction. Which of the two segments will that\n     * point intersect first? That segment comes 'before' the other one.\n     *\n     * If neither segment would be intersected by such a line, (if one\n     * or more of the segments are vertical) then the line to be considered\n     * is directly on the right-more of the two left inputs.\n     */\n    value: function compare(a, b) {\n      var alx = a.leftSE.point.x;\n      var blx = b.leftSE.point.x;\n      var arx = a.rightSE.point.x;\n      var brx = b.rightSE.point.x; // check if they're even in the same vertical plane\n\n      if (brx < alx) return 1;\n      if (arx < blx) return -1;\n      var aly = a.leftSE.point.y;\n      var bly = b.leftSE.point.y;\n      var ary = a.rightSE.point.y;\n      var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?\n\n      if (alx < blx) {\n        // are the two segments in the same horizontal plane?\n        if (bly < aly && bly < ary) return 1;\n        if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?\n\n        var aCmpBLeft = a.comparePoint(b.leftSE.point);\n        if (aCmpBLeft < 0) return 1;\n        if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?\n\n        var bCmpARight = b.comparePoint(a.rightSE.point);\n        if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more\n        // left endpoint to be first (arbitrary?)\n\n        return -1;\n      } // is left endpoint of segment A the right-more?\n\n\n      if (alx > blx) {\n        if (aly < bly && aly < bry) return -1;\n        if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?\n\n        var bCmpALeft = b.comparePoint(a.leftSE.point);\n        if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?\n\n        var aCmpBRight = a.comparePoint(b.rightSE.point);\n        if (aCmpBRight < 0) return 1;\n        if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more\n        // left endpoint to be first (arbitrary?)\n\n        return 1;\n      } // if we get here, the two left endpoints are in the same\n      // vertical plane, ie alx === blx\n      // consider the lower left-endpoint to come first\n\n\n      if (aly < bly) return -1;\n      if (aly > bly) return 1; // left endpoints are identical\n      // check for colinearity by using the left-more right endpoint\n      // is the A right endpoint more left-more?\n\n      if (arx < brx) {\n        var _bCmpARight = b.comparePoint(a.rightSE.point);\n\n        if (_bCmpARight !== 0) return _bCmpARight;\n      } // is the B right endpoint more left-more?\n\n\n      if (arx > brx) {\n        var _aCmpBRight = a.comparePoint(b.rightSE.point);\n\n        if (_aCmpBRight < 0) return 1;\n        if (_aCmpBRight > 0) return -1;\n      }\n\n      if (arx !== brx) {\n        // are these two [almost] vertical segments with opposite orientation?\n        // if so, the one with the lower right endpoint comes first\n        var ay = ary - aly;\n        var ax = arx - alx;\n        var by = bry - bly;\n        var bx = brx - blx;\n        if (ay > ax && by < bx) return 1;\n        if (ay < ax && by > bx) return -1;\n      } // we have colinear segments with matching orientation\n      // consider the one with more left-more right endpoint to be first\n\n\n      if (arx > brx) return 1;\n      if (arx < brx) return -1; // if we get here, two two right endpoints are in the same\n      // vertical plane, ie arx === brx\n      // consider the lower right-endpoint to come first\n\n      if (ary < bry) return -1;\n      if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential\n      // fall back on creation order as consistent tie-breaker\n\n      if (a.id < b.id) return -1;\n      if (a.id > b.id) return 1; // identical segment, ie a === b\n\n      return 0;\n    }\n    /* Warning: a reference to ringWindings input will be stored,\n     *  and possibly will be later modified */\n\n  }]);\n\n  function Segment(leftSE, rightSE, rings, windings) {\n    _classCallCheck(this, Segment);\n\n    this.id = ++segmentId;\n    this.leftSE = leftSE;\n    leftSE.segment = this;\n    leftSE.otherSE = rightSE;\n    this.rightSE = rightSE;\n    rightSE.segment = this;\n    rightSE.otherSE = leftSE;\n    this.rings = rings;\n    this.windings = windings; // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n  }\n\n  _createClass(Segment, [{\n    key: \"replaceRightSE\",\n\n    /* When a segment is split, the rightSE is replaced with a new sweep event */\n    value: function replaceRightSE(newRightSE) {\n      this.rightSE = newRightSE;\n      this.rightSE.segment = this;\n      this.rightSE.otherSE = this.leftSE;\n      this.leftSE.otherSE = this.rightSE;\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var y1 = this.leftSE.point.y;\n      var y2 = this.rightSE.point.y;\n      return {\n        ll: {\n          x: this.leftSE.point.x,\n          y: y1 < y2 ? y1 : y2\n        },\n        ur: {\n          x: this.rightSE.point.x,\n          y: y1 > y2 ? y1 : y2\n        }\n      };\n    }\n    /* A vector from the left point to the right */\n\n  }, {\n    key: \"vector\",\n    value: function vector() {\n      return {\n        x: this.rightSE.point.x - this.leftSE.point.x,\n        y: this.rightSE.point.y - this.leftSE.point.y\n      };\n    }\n  }, {\n    key: \"isAnEndpoint\",\n    value: function isAnEndpoint(pt) {\n      return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n    }\n    /* Compare this segment with a point.\n     *\n     * A point P is considered to be colinear to a segment if there\n     * exists a distance D such that if we travel along the segment\n     * from one * endpoint towards the other a distance D, we find\n     * ourselves at point P.\n     *\n     * Return value indicates:\n     *\n     *   1: point lies above the segment (to the left of vertical)\n     *   0: point is colinear to segment\n     *  -1: point lies below the segment (to the right of vertical)\n     */\n\n  }, {\n    key: \"comparePoint\",\n    value: function comparePoint(point) {\n      if (this.isAnEndpoint(point)) return 0;\n      var lPt = this.leftSE.point;\n      var rPt = this.rightSE.point;\n      var v = this.vector(); // Exactly vertical segments.\n\n      if (lPt.x === rPt.x) {\n        if (point.x === lPt.x) return 0;\n        return point.x < lPt.x ? 1 : -1;\n      } // Nearly vertical segments with an intersection.\n      // Check to see where a point on the line with matching Y coordinate is.\n\n\n      var yDist = (point.y - lPt.y) / v.y;\n      var xFromYDist = lPt.x + yDist * v.x;\n      if (point.x === xFromYDist) return 0; // General case.\n      // Check to see where a point on the line with matching X coordinate is.\n\n      var xDist = (point.x - lPt.x) / v.x;\n      var yFromXDist = lPt.y + xDist * v.y;\n      if (point.y === yFromXDist) return 0;\n      return point.y < yFromXDist ? -1 : 1;\n    }\n    /**\n     * Given another segment, returns the first non-trivial intersection\n     * between the two segments (in terms of sweep line ordering), if it exists.\n     *\n     * A 'non-trivial' intersection is one that will cause one or both of the\n     * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n     *\n     *   * endpoint of segA with endpoint of segB --> trivial\n     *   * endpoint of segA with point along segB --> non-trivial\n     *   * endpoint of segB with point along segA --> non-trivial\n     *   * point along segA with point along segB --> non-trivial\n     *\n     * If no non-trivial intersection exists, return null\n     * Else, return null.\n     */\n\n  }, {\n    key: \"getIntersection\",\n    value: function getIntersection(other) {\n      // If bboxes don't overlap, there can't be any intersections\n      var tBbox = this.bbox();\n      var oBbox = other.bbox();\n      var bboxOverlap = getBboxOverlap(tBbox, oBbox);\n      if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.\n      // This will 'snap' intersections to endpoints if possible, and will\n      // handle cases of colinearity.\n\n      var tlp = this.leftSE.point;\n      var trp = this.rightSE.point;\n      var olp = other.leftSE.point;\n      var orp = other.rightSE.point; // does each endpoint touch the other segment?\n      // note that we restrict the 'touching' definition to only allow segments\n      // to touch endpoints that lie forward from where we are in the sweep line pass\n\n      var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n      var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n      var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n      var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?\n\n      if (touchesThisLSE && touchesOtherLSE) {\n        // these two cases are for colinear segments with matching left\n        // endpoints, and one segment being longer than the other\n        if (touchesThisRSE && !touchesOtherRSE) return trp;\n        if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)\n        // or just on their left endpoint (one trivial intersection\n\n        return null;\n      } // does this left endpoint matches (other doesn't)\n\n\n      if (touchesThisLSE) {\n        // check for segments that just intersect on opposing endpoints\n        if (touchesOtherRSE) {\n          if (tlp.x === orp.x && tlp.y === orp.y) return null;\n        } // t-intersection on left endpoint\n\n\n        return tlp;\n      } // does other left endpoint matches (this doesn't)\n\n\n      if (touchesOtherLSE) {\n        // check for segments that just intersect on opposing endpoints\n        if (touchesThisRSE) {\n          if (trp.x === olp.x && trp.y === olp.y) return null;\n        } // t-intersection on left endpoint\n\n\n        return olp;\n      } // trivial intersection on right endpoints\n\n\n      if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint\n\n      if (touchesThisRSE) return trp;\n      if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between\n      // infinite lines laid over the segments\n\n      var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,\n      // they would have an endpoint intersection and that case was already handled above\n\n      if (pt === null) return null; // is the intersection found between the lines not on the segments?\n\n      if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed\n\n      return rounder.round(pt.x, pt.y);\n    }\n    /**\n     * Split the given segment into multiple segments on the given points.\n     *  * Each existing segment will retain its leftSE and a new rightSE will be\n     *    generated for it.\n     *  * A new segment will be generated which will adopt the original segment's\n     *    rightSE, and a new leftSE will be generated for it.\n     *  * If there are more than two points given to split on, new segments\n     *    in the middle will be generated with new leftSE and rightSE's.\n     *  * An array of the newly generated SweepEvents will be returned.\n     *\n     * Warning: input array of points is modified\n     */\n\n  }, {\n    key: \"split\",\n    value: function split(point) {\n      var newEvents = [];\n      var alreadyLinked = point.events !== undefined;\n      var newLeftSE = new SweepEvent(point, true);\n      var newRightSE = new SweepEvent(point, false);\n      var oldRightSE = this.rightSE;\n      this.replaceRightSE(newRightSE);\n      newEvents.push(newRightSE);\n      newEvents.push(newLeftSE);\n      var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,\n      // sometimes one of the resulting new segments is vertical, in which\n      // case its left and right events may need to be swapped\n\n      if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n        newSeg.swapEvents();\n      }\n\n      if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n        this.swapEvents();\n      } // in the point we just used to create new sweep events with was already\n      // linked to other events, we need to check if either of the affected\n      // segments should be consumed\n\n\n      if (alreadyLinked) {\n        newLeftSE.checkForConsuming();\n        newRightSE.checkForConsuming();\n      }\n\n      return newEvents;\n    }\n    /* Swap which event is left and right */\n\n  }, {\n    key: \"swapEvents\",\n    value: function swapEvents() {\n      var tmpEvt = this.rightSE;\n      this.rightSE = this.leftSE;\n      this.leftSE = tmpEvt;\n      this.leftSE.isLeft = true;\n      this.rightSE.isLeft = false;\n\n      for (var i = 0, iMax = this.windings.length; i < iMax; i++) {\n        this.windings[i] *= -1;\n      }\n    }\n    /* Consume another segment. We take their rings under our wing\n     * and mark them as consumed. Use for perfectly overlapping segments */\n\n  }, {\n    key: \"consume\",\n    value: function consume(other) {\n      var consumer = this;\n      var consumee = other;\n\n      while (consumer.consumedBy) {\n        consumer = consumer.consumedBy;\n      }\n\n      while (consumee.consumedBy) {\n        consumee = consumee.consumedBy;\n      }\n\n      var cmp = Segment.compare(consumer, consumee);\n      if (cmp === 0) return; // already consumed\n      // the winner of the consumption is the earlier segment\n      // according to sweep line ordering\n\n      if (cmp > 0) {\n        var tmp = consumer;\n        consumer = consumee;\n        consumee = tmp;\n      } // make sure a segment doesn't consume it's prev\n\n\n      if (consumer.prev === consumee) {\n        var _tmp = consumer;\n        consumer = consumee;\n        consumee = _tmp;\n      }\n\n      for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n        var ring = consumee.rings[i];\n        var winding = consumee.windings[i];\n        var index = consumer.rings.indexOf(ring);\n\n        if (index === -1) {\n          consumer.rings.push(ring);\n          consumer.windings.push(winding);\n        } else consumer.windings[index] += winding;\n      }\n\n      consumee.rings = null;\n      consumee.windings = null;\n      consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue\n\n      consumee.leftSE.consumedBy = consumer.leftSE;\n      consumee.rightSE.consumedBy = consumer.rightSE;\n    }\n    /* The first segment previous segment chain that is in the result */\n\n  }, {\n    key: \"prevInResult\",\n    value: function prevInResult() {\n      if (this._prevInResult !== undefined) return this._prevInResult;\n      if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n      return this._prevInResult;\n    }\n  }, {\n    key: \"beforeState\",\n    value: function beforeState() {\n      if (this._beforeState !== undefined) return this._beforeState;\n      if (!this.prev) this._beforeState = {\n        rings: [],\n        windings: [],\n        multiPolys: []\n      };else {\n        var seg = this.prev.consumedBy || this.prev;\n        this._beforeState = seg.afterState();\n      }\n      return this._beforeState;\n    }\n  }, {\n    key: \"afterState\",\n    value: function afterState() {\n      if (this._afterState !== undefined) return this._afterState;\n      var beforeState = this.beforeState();\n      this._afterState = {\n        rings: beforeState.rings.slice(0),\n        windings: beforeState.windings.slice(0),\n        multiPolys: []\n      };\n      var ringsAfter = this._afterState.rings;\n      var windingsAfter = this._afterState.windings;\n      var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter\n\n      for (var i = 0, iMax = this.rings.length; i < iMax; i++) {\n        var ring = this.rings[i];\n        var winding = this.windings[i];\n        var index = ringsAfter.indexOf(ring);\n\n        if (index === -1) {\n          ringsAfter.push(ring);\n          windingsAfter.push(winding);\n        } else windingsAfter[index] += winding;\n      } // calcualte polysAfter\n\n\n      var polysAfter = [];\n      var polysExclude = [];\n\n      for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {\n        if (windingsAfter[_i] === 0) continue; // non-zero rule\n\n        var _ring = ringsAfter[_i];\n        var poly = _ring.poly;\n        if (polysExclude.indexOf(poly) !== -1) continue;\n        if (_ring.isExterior) polysAfter.push(poly);else {\n          if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n\n          var _index = polysAfter.indexOf(_ring.poly);\n\n          if (_index !== -1) polysAfter.splice(_index, 1);\n        }\n      } // calculate multiPolysAfter\n\n\n      for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {\n        var mp = polysAfter[_i2].multiPoly;\n        if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n      }\n\n      return this._afterState;\n    }\n    /* Is this segment part of the final result? */\n\n  }, {\n    key: \"isInResult\",\n    value: function isInResult() {\n      // if we've been consumed, we're not in the result\n      if (this.consumedBy) return false;\n      if (this._isInResult !== undefined) return this._isInResult;\n      var mpsBefore = this.beforeState().multiPolys;\n      var mpsAfter = this.afterState().multiPolys;\n\n      switch (operation.type) {\n        case 'union':\n          {\n            // UNION - included iff:\n            //  * On one side of us there is 0 poly interiors AND\n            //  * On the other side there is 1 or more.\n            var noBefores = mpsBefore.length === 0;\n            var noAfters = mpsAfter.length === 0;\n            this._isInResult = noBefores !== noAfters;\n            break;\n          }\n\n        case 'intersection':\n          {\n            // INTERSECTION - included iff:\n            //  * on one side of us all multipolys are rep. with poly interiors AND\n            //  * on the other side of us, not all multipolys are repsented\n            //    with poly interiors\n            var least;\n            var most;\n\n            if (mpsBefore.length < mpsAfter.length) {\n              least = mpsBefore.length;\n              most = mpsAfter.length;\n            } else {\n              least = mpsAfter.length;\n              most = mpsBefore.length;\n            }\n\n            this._isInResult = most === operation.numMultiPolys && least < most;\n            break;\n          }\n\n        case 'xor':\n          {\n            // XOR - included iff:\n            //  * the difference between the number of multipolys represented\n            //    with poly interiors on our two sides is an odd number\n            var diff = Math.abs(mpsBefore.length - mpsAfter.length);\n            this._isInResult = diff % 2 === 1;\n            break;\n          }\n\n        case 'difference':\n          {\n            // DIFFERENCE included iff:\n            //  * on exactly one side, we have just the subject\n            var isJustSubject = function isJustSubject(mps) {\n              return mps.length === 1 && mps[0].isSubject;\n            };\n\n            this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n            break;\n          }\n\n        default:\n          throw new Error(\"Unrecognized operation type found \".concat(operation.type));\n      }\n\n      return this._isInResult;\n    }\n  }], [{\n    key: \"fromRing\",\n    value: function fromRing(pt1, pt2, ring) {\n      var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering\n\n      var cmpPts = SweepEvent.comparePoints(pt1, pt2);\n\n      if (cmpPts < 0) {\n        leftPt = pt1;\n        rightPt = pt2;\n        winding = 1;\n      } else if (cmpPts > 0) {\n        leftPt = pt2;\n        rightPt = pt1;\n        winding = -1;\n      } else throw new Error(\"Tried to create degenerate segment at [\".concat(pt1.x, \", \").concat(pt1.y, \"]\"));\n\n      var leftSE = new SweepEvent(leftPt, true);\n      var rightSE = new SweepEvent(rightPt, false);\n      return new Segment(leftSE, rightSE, [ring], [winding]);\n    }\n  }]);\n\n  return Segment;\n}();\n\nvar RingIn = /*#__PURE__*/function () {\n  function RingIn(geomRing, poly, isExterior) {\n    _classCallCheck(this, RingIn);\n\n    if (!Array.isArray(geomRing) || geomRing.length === 0) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    this.poly = poly;\n    this.isExterior = isExterior;\n    this.segments = [];\n\n    if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n    this.bbox = {\n      ll: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      },\n      ur: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      }\n    };\n    var prevPoint = firstPoint;\n\n    for (var i = 1, iMax = geomRing.length; i < iMax; i++) {\n      if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points\n\n      if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n      this.segments.push(Segment.fromRing(prevPoint, point, this));\n      if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n      if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n      if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n      if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n      prevPoint = point;\n    } // add segment from last to first if last is not the same as first\n\n\n    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n    }\n  }\n\n  _createClass(RingIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = [];\n\n      for (var i = 0, iMax = this.segments.length; i < iMax; i++) {\n        var segment = this.segments[i];\n        sweepEvents.push(segment.leftSE);\n        sweepEvents.push(segment.rightSE);\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return RingIn;\n}();\nvar PolyIn = /*#__PURE__*/function () {\n  function PolyIn(geomPoly, multiPoly) {\n    _classCallCheck(this, PolyIn);\n\n    if (!Array.isArray(geomPoly)) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value\n\n    this.bbox = {\n      ll: {\n        x: this.exteriorRing.bbox.ll.x,\n        y: this.exteriorRing.bbox.ll.y\n      },\n      ur: {\n        x: this.exteriorRing.bbox.ur.x,\n        y: this.exteriorRing.bbox.ur.y\n      }\n    };\n    this.interiorRings = [];\n\n    for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      var ring = new RingIn(geomPoly[i], this, false);\n      if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n      if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n      if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n      if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n      this.interiorRings.push(ring);\n    }\n\n    this.multiPoly = multiPoly;\n  }\n\n  _createClass(PolyIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = this.exteriorRing.getSweepEvents();\n\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n        var ringSweepEvents = this.interiorRings[i].getSweepEvents();\n\n        for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n          sweepEvents.push(ringSweepEvents[j]);\n        }\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return PolyIn;\n}();\nvar MultiPolyIn = /*#__PURE__*/function () {\n  function MultiPolyIn(geom, isSubject) {\n    _classCallCheck(this, MultiPolyIn);\n\n    if (!Array.isArray(geom)) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    try {\n      // if the input looks like a polygon, convert it to a multipolygon\n      if (typeof geom[0][0][0] === 'number') geom = [geom];\n    } catch (ex) {// The input is either malformed or has empty arrays.\n      // In either case, it will be handled later on.\n    }\n\n    this.polys = [];\n    this.bbox = {\n      ll: {\n        x: Number.POSITIVE_INFINITY,\n        y: Number.POSITIVE_INFINITY\n      },\n      ur: {\n        x: Number.NEGATIVE_INFINITY,\n        y: Number.NEGATIVE_INFINITY\n      }\n    };\n\n    for (var i = 0, iMax = geom.length; i < iMax; i++) {\n      var poly = new PolyIn(geom[i], this);\n      if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n      if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n      if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n      if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n      this.polys.push(poly);\n    }\n\n    this.isSubject = isSubject;\n  }\n\n  _createClass(MultiPolyIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = [];\n\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n        var polySweepEvents = this.polys[i].getSweepEvents();\n\n        for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n          sweepEvents.push(polySweepEvents[j]);\n        }\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return MultiPolyIn;\n}();\n\nvar RingOut = /*#__PURE__*/function () {\n  _createClass(RingOut, null, [{\n    key: \"factory\",\n\n    /* Given the segments from the sweep line pass, compute & return a series\n     * of closed rings from all the segments marked to be part of the result */\n    value: function factory(allSegments) {\n      var ringsOut = [];\n\n      for (var i = 0, iMax = allSegments.length; i < iMax; i++) {\n        var segment = allSegments[i];\n        if (!segment.isInResult() || segment.ringOut) continue;\n        var prevEvent = null;\n        var event = segment.leftSE;\n        var nextEvent = segment.rightSE;\n        var events = [event];\n        var startingPoint = event.point;\n        var intersectionLEs = [];\n        /* Walk the chain of linked events to form a closed ring */\n\n        while (true) {\n          prevEvent = event;\n          event = nextEvent;\n          events.push(event);\n          /* Is the ring complete? */\n\n          if (event.point === startingPoint) break;\n\n          while (true) {\n            var availableLEs = event.getAvailableLinkedEvents();\n            /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n             * part of the algorithm malfunctioned... please file a bug report. */\n\n            if (availableLEs.length === 0) {\n              var firstPt = events[0].point;\n              var lastPt = events[events.length - 1].point;\n              throw new Error(\"Unable to complete output ring starting at [\".concat(firstPt.x, \",\") + \" \".concat(firstPt.y, \"]. Last matching segment found ends at\") + \" [\".concat(lastPt.x, \", \").concat(lastPt.y, \"].\"));\n            }\n            /* Only one way to go, so cotinue on the path */\n\n\n            if (availableLEs.length === 1) {\n              nextEvent = availableLEs[0].otherSE;\n              break;\n            }\n            /* We must have an intersection. Check for a completed loop */\n\n\n            var indexLE = null;\n\n            for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n              if (intersectionLEs[j].point === event.point) {\n                indexLE = j;\n                break;\n              }\n            }\n            /* Found a completed loop. Cut that off and make a ring */\n\n\n            if (indexLE !== null) {\n              var intersectionLE = intersectionLEs.splice(indexLE)[0];\n              var ringEvents = events.splice(intersectionLE.index);\n              ringEvents.unshift(ringEvents[0].otherSE);\n              ringsOut.push(new RingOut(ringEvents.reverse()));\n              continue;\n            }\n            /* register the intersection */\n\n\n            intersectionLEs.push({\n              index: events.length,\n              point: event.point\n            });\n            /* Choose the left-most option to continue the walk */\n\n            var comparator = event.getLeftmostComparator(prevEvent);\n            nextEvent = availableLEs.sort(comparator)[0].otherSE;\n            break;\n          }\n        }\n\n        ringsOut.push(new RingOut(events));\n      }\n\n      return ringsOut;\n    }\n  }]);\n\n  function RingOut(events) {\n    _classCallCheck(this, RingOut);\n\n    this.events = events;\n\n    for (var i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this;\n    }\n\n    this.poly = null;\n  }\n\n  _createClass(RingOut, [{\n    key: \"getGeom\",\n    value: function getGeom() {\n      // Remove superfluous points (ie extra points along a straight line),\n      var prevPt = this.events[0].point;\n      var points = [prevPt];\n\n      for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n        var _pt = this.events[i].point;\n        var _nextPt = this.events[i + 1].point;\n        if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;\n        points.push(_pt);\n        prevPt = _pt;\n      } // ring was all (within rounding error of angle calc) colinear points\n\n\n      if (points.length === 1) return null; // check if the starting point is necessary\n\n      var pt = points[0];\n      var nextPt = points[1];\n      if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n      points.push(points[0]);\n      var step = this.isExteriorRing() ? 1 : -1;\n      var iStart = this.isExteriorRing() ? 0 : points.length - 1;\n      var iEnd = this.isExteriorRing() ? points.length : -1;\n      var orderedPoints = [];\n\n      for (var _i = iStart; _i != iEnd; _i += step) {\n        orderedPoints.push([points[_i].x, points[_i].y]);\n      }\n\n      return orderedPoints;\n    }\n  }, {\n    key: \"isExteriorRing\",\n    value: function isExteriorRing() {\n      if (this._isExteriorRing === undefined) {\n        var enclosing = this.enclosingRing();\n        this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n      }\n\n      return this._isExteriorRing;\n    }\n  }, {\n    key: \"enclosingRing\",\n    value: function enclosingRing() {\n      if (this._enclosingRing === undefined) {\n        this._enclosingRing = this._calcEnclosingRing();\n      }\n\n      return this._enclosingRing;\n    }\n    /* Returns the ring that encloses this one, if any */\n\n  }, {\n    key: \"_calcEnclosingRing\",\n    value: function _calcEnclosingRing() {\n      // start with the ealier sweep line event so that the prevSeg\n      // chain doesn't lead us inside of a loop of ours\n      var leftMostEvt = this.events[0];\n\n      for (var i = 1, iMax = this.events.length; i < iMax; i++) {\n        var evt = this.events[i];\n        if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n      }\n\n      var prevSeg = leftMostEvt.segment.prevInResult();\n      var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n\n      while (true) {\n        // no segment found, thus no ring can enclose us\n        if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev\n        // segment must loop back around and enclose us\n\n        if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev\n        // segment must either loop around us or the ring of the prev prev\n        // seg, which would make us and the ring of the prev peers\n\n        if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n          if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n            return prevSeg.ringOut;\n          } else return prevSeg.ringOut.enclosingRing();\n        } // two segments are from the same ring, so this was a penisula\n        // of that ring. iterate downward, keep searching\n\n\n        prevSeg = prevPrevSeg.prevInResult();\n        prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n      }\n    }\n  }]);\n\n  return RingOut;\n}();\nvar PolyOut = /*#__PURE__*/function () {\n  function PolyOut(exteriorRing) {\n    _classCallCheck(this, PolyOut);\n\n    this.exteriorRing = exteriorRing;\n    exteriorRing.poly = this;\n    this.interiorRings = [];\n  }\n\n  _createClass(PolyOut, [{\n    key: \"addInterior\",\n    value: function addInterior(ring) {\n      this.interiorRings.push(ring);\n      ring.poly = this;\n    }\n  }, {\n    key: \"getGeom\",\n    value: function getGeom() {\n      var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points\n\n      if (geom[0] === null) return null;\n\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n        var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points\n\n        if (ringGeom === null) continue;\n        geom.push(ringGeom);\n      }\n\n      return geom;\n    }\n  }]);\n\n  return PolyOut;\n}();\nvar MultiPolyOut = /*#__PURE__*/function () {\n  function MultiPolyOut(rings) {\n    _classCallCheck(this, MultiPolyOut);\n\n    this.rings = rings;\n    this.polys = this._composePolys(rings);\n  }\n\n  _createClass(MultiPolyOut, [{\n    key: \"getGeom\",\n    value: function getGeom() {\n      var geom = [];\n\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n        var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points\n\n        if (polyGeom === null) continue;\n        geom.push(polyGeom);\n      }\n\n      return geom;\n    }\n  }, {\n    key: \"_composePolys\",\n    value: function _composePolys(rings) {\n      var polys = [];\n\n      for (var i = 0, iMax = rings.length; i < iMax; i++) {\n        var ring = rings[i];\n        if (ring.poly) continue;\n        if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n          var enclosingRing = ring.enclosingRing();\n          if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n          enclosingRing.poly.addInterior(ring);\n        }\n      }\n\n      return polys;\n    }\n  }]);\n\n  return MultiPolyOut;\n}();\n\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */\n\nvar SweepLine = /*#__PURE__*/function () {\n  function SweepLine(queue) {\n    var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n\n    _classCallCheck(this, SweepLine);\n\n    this.queue = queue;\n    this.tree = new SplayTree(comparator);\n    this.segments = [];\n  }\n\n  _createClass(SweepLine, [{\n    key: \"process\",\n    value: function process(event) {\n      var segment = event.segment;\n      var newEvents = []; // if we've already been consumed by another segment,\n      // clean up our body parts and get out\n\n      if (event.consumedBy) {\n        if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n        return newEvents;\n      }\n\n      var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);\n      if (!node) throw new Error(\"Unable to find segment #\".concat(segment.id, \" \") + \"[\".concat(segment.leftSE.point.x, \", \").concat(segment.leftSE.point.y, \"] -> \") + \"[\".concat(segment.rightSE.point.x, \", \").concat(segment.rightSE.point.y, \"] \") + 'in SweepLine tree. Please submit a bug report.');\n      var prevNode = node;\n      var nextNode = node;\n      var prevSeg = undefined;\n      var nextSeg = undefined; // skip consumed segments still in tree\n\n      while (prevSeg === undefined) {\n        prevNode = this.tree.prev(prevNode);\n        if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n      } // skip consumed segments still in tree\n\n\n      while (nextSeg === undefined) {\n        nextNode = this.tree.next(nextNode);\n        if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n      }\n\n      if (event.isLeft) {\n        // Check for intersections against the previous segment in the sweep line\n        var prevMySplitter = null;\n\n        if (prevSeg) {\n          var prevInter = prevSeg.getIntersection(segment);\n\n          if (prevInter !== null) {\n            if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n\n            if (!prevSeg.isAnEndpoint(prevInter)) {\n              var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n\n              for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                newEvents.push(newEventsFromSplit[i]);\n              }\n            }\n          }\n        } // Check for intersections against the next segment in the sweep line\n\n\n        var nextMySplitter = null;\n\n        if (nextSeg) {\n          var nextInter = nextSeg.getIntersection(segment);\n\n          if (nextInter !== null) {\n            if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n\n            if (!nextSeg.isAnEndpoint(nextInter)) {\n              var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n\n              for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {\n                newEvents.push(_newEventsFromSplit[_i]);\n              }\n            }\n          }\n        } // For simplicity, even if we find more than one intersection we only\n        // spilt on the 'earliest' (sweep-line style) of the intersections.\n        // The other intersection will be handled in a future process().\n\n\n        if (prevMySplitter !== null || nextMySplitter !== null) {\n          var mySplitter = null;\n          if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n            var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n            mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n          } // Rounding errors can cause changes in ordering,\n          // so remove afected segments and right sweep events before splitting\n\n          this.queue.remove(segment.rightSE);\n          newEvents.push(segment.rightSE);\n\n          var _newEventsFromSplit2 = segment.split(mySplitter);\n\n          for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {\n            newEvents.push(_newEventsFromSplit2[_i2]);\n          }\n        }\n\n        if (newEvents.length > 0) {\n          // We found some intersections, so re-do the current event to\n          // make sure sweep line ordering is totally consistent for later\n          // use with the segment 'prev' pointers\n          this.tree.remove(segment);\n          newEvents.push(event);\n        } else {\n          // done with left event\n          this.segments.push(segment);\n          segment.prev = prevSeg;\n        }\n      } else {\n        // event.isRight\n        // since we're about to be removed from the sweep line, check for\n        // intersections between our previous and next segments\n        if (prevSeg && nextSeg) {\n          var inter = prevSeg.getIntersection(nextSeg);\n\n          if (inter !== null) {\n            if (!prevSeg.isAnEndpoint(inter)) {\n              var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);\n\n              for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {\n                newEvents.push(_newEventsFromSplit3[_i3]);\n              }\n            }\n\n            if (!nextSeg.isAnEndpoint(inter)) {\n              var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);\n\n              for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {\n                newEvents.push(_newEventsFromSplit4[_i4]);\n              }\n            }\n          }\n        }\n\n        this.tree.remove(segment);\n      }\n\n      return newEvents;\n    }\n    /* Safely split a segment that is currently in the datastructures\n     * IE - a segment other than the one that is currently being processed. */\n\n  }, {\n    key: \"_splitSafely\",\n    value: function _splitSafely(seg, pt) {\n      // Rounding errors can cause changes in ordering,\n      // so remove afected segments and right sweep events before splitting\n      // removeNode() doesn't work, so have re-find the seg\n      // https://github.com/w8r/splay-tree/pull/5\n      this.tree.remove(seg);\n      var rightSE = seg.rightSE;\n      this.queue.remove(rightSE);\n      var newEvents = seg.split(pt);\n      newEvents.push(rightSE); // splitting can trigger consumption\n\n      if (seg.consumedBy === undefined) this.tree.insert(seg);\n      return newEvents;\n    }\n  }]);\n\n  return SweepLine;\n}();\n\nvar POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\nvar POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\nvar Operation = /*#__PURE__*/function () {\n  function Operation() {\n    _classCallCheck(this, Operation);\n  }\n\n  _createClass(Operation, [{\n    key: \"run\",\n    value: function run(type, geom, moreGeoms) {\n      operation.type = type;\n      rounder.reset();\n      /* Convert inputs to MultiPoly objects */\n\n      var multipolys = [new MultiPolyIn(geom, true)];\n\n      for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n        multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n      }\n\n      operation.numMultiPolys = multipolys.length;\n      /* BBox optimization for difference operation\n       * If the bbox of a multipolygon that's part of the clipping doesn't\n       * intersect the bbox of the subject at all, we can just drop that\n       * multiploygon. */\n\n      if (operation.type === 'difference') {\n        // in place removal\n        var subject = multipolys[0];\n        var _i = 1;\n\n        while (_i < multipolys.length) {\n          if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;else multipolys.splice(_i, 1);\n        }\n      }\n      /* BBox optimization for intersection operation\n       * If we can find any pair of multipolygons whose bbox does not overlap,\n       * then the result will be empty. */\n\n\n      if (operation.type === 'intersection') {\n        // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n        //       it could be optimized to O(n * ln(n))\n        for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {\n          var mpA = multipolys[_i2];\n\n          for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {\n            if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n          }\n        }\n      }\n      /* Put segment endpoints in a priority queue */\n\n\n      var queue = new SplayTree(SweepEvent.compare);\n\n      for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {\n        var sweepEvents = multipolys[_i3].getSweepEvents();\n\n        for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {\n          queue.insert(sweepEvents[_j]);\n\n          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');\n          }\n        }\n      }\n      /* Pass the sweep line over those endpoints */\n\n\n      var sweepLine = new SweepLine(queue);\n      var prevQueueSize = queue.size;\n      var node = queue.pop();\n\n      while (node) {\n        var evt = node.key;\n\n        if (queue.size === prevQueueSize) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          var seg = evt.segment;\n          throw new Error(\"Unable to pop() \".concat(evt.isLeft ? 'left' : 'right', \" SweepEvent \") + \"[\".concat(evt.point.x, \", \").concat(evt.point.y, \"] from segment #\").concat(seg.id, \" \") + \"[\".concat(seg.leftSE.point.x, \", \").concat(seg.leftSE.point.y, \"] -> \") + \"[\".concat(seg.rightSE.point.x, \", \").concat(seg.rightSE.point.y, \"] from queue. \") + 'Please file a bug report.');\n        }\n\n        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');\n        }\n\n        if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');\n        }\n\n        var newEvents = sweepLine.process(evt);\n\n        for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {\n          var _evt = newEvents[_i4];\n          if (_evt.consumedBy === undefined) queue.insert(_evt);\n        }\n\n        prevQueueSize = queue.size;\n        node = queue.pop();\n      } // free some memory we don't need anymore\n\n\n      rounder.reset();\n      /* Collect and compile segments we're keeping into a multipolygon */\n\n      var ringsOut = RingOut.factory(sweepLine.segments);\n      var result = new MultiPolyOut(ringsOut);\n      return result.getGeom();\n    }\n  }]);\n\n  return Operation;\n}(); // singleton available by import\n\nvar operation = new Operation();\n\nvar union = function union(geom) {\n  for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    moreGeoms[_key - 1] = arguments[_key];\n  }\n\n  return operation.run('union', geom, moreGeoms);\n};\n\nvar intersection$1 = function intersection(geom) {\n  for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    moreGeoms[_key2 - 1] = arguments[_key2];\n  }\n\n  return operation.run('intersection', geom, moreGeoms);\n};\n\nvar xor = function xor(geom) {\n  for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    moreGeoms[_key3 - 1] = arguments[_key3];\n  }\n\n  return operation.run('xor', geom, moreGeoms);\n};\n\nvar difference = function difference(subjectGeom) {\n  for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    clippingGeoms[_key4 - 1] = arguments[_key4];\n  }\n\n  return operation.run('difference', subjectGeom, clippingGeoms);\n};\n\nvar index = {\n  union: union,\n  intersection: intersection$1,\n  xor: xor,\n  difference: difference\n};\n\nexport default index;\n","import polygonClipping from 'polygon-clipping';\nimport { polygon, multiPolygon } from '@turf/helpers';\nimport { getGeom } from '@turf/invariant';\n\n/**\n * Finds the difference between two {@link Polygon|polygons} by clipping the second polygon from the first.\n *\n * @name difference\n * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature\n * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1\n * @returns {Feature<Polygon|MultiPolygon>|null} a Polygon or MultiPolygon feature showing the area of `polygon1` excluding the area of `polygon2` (if empty returns `null`)\n * @example\n * var polygon1 = turf.polygon([[\n *   [128, -26],\n *   [141, -26],\n *   [141, -21],\n *   [128, -21],\n *   [128, -26]\n * ]], {\n *   \"fill\": \"#F00\",\n *   \"fill-opacity\": 0.1\n * });\n * var polygon2 = turf.polygon([[\n *   [126, -28],\n *   [140, -28],\n *   [140, -20],\n *   [126, -20],\n *   [126, -28]\n * ]], {\n *   \"fill\": \"#00F\",\n *   \"fill-opacity\": 0.1\n * });\n *\n * var difference = turf.difference(polygon1, polygon2);\n *\n * //addToMap\n * var addToMap = [polygon1, polygon2, difference];\n */\nfunction difference(polygon1, polygon2) {\n  var geom1 = getGeom(polygon1);\n  var geom2 = getGeom(polygon2);\n  var properties = polygon1.properties || {};\n\n  var differenced = polygonClipping.difference(\n    geom1.coordinates,\n    geom2.coordinates\n  );\n  if (differenced.length === 0) return null;\n  if (differenced.length === 1) return polygon(differenced[0], properties);\n  return multiPolygon(differenced, properties);\n}\n\nexport default difference;\n","export const modeName = \"split_polygon\";\n\n/// This mode uses the `mapbox-gl-draw-passing-mode` mode to draw the spilitting lineString.\n/// here is the name used to add that mode:\nexport const passingModeName = `${modeName}_passing_draw_line_string`;\n\n/// when a (multi-)polygon feature is selected to be splitted, it gets highlighted.\n/// here is the name of the property indicating the highlight.\nexport const highlightPropertyName = `${modeName}_highlight`;\n\nexport const defaultOptions = {\n  highlightColor: \"#222\",\n  lineWidth: 0,\n  lineWidthUnit: \"kilometers\",\n  onSelectFeatureRequest() {\n    throw new Error(\"no Feature is selected to split.\");\n  },\n};\n","import polygonSplitter from \"polygon-splitter\";\n\nimport { geojsonTypes, events } from \"@mapbox/mapbox-gl-draw/src/constants\";\n\nimport lineIntersect from \"@turf/line-intersect\";\nimport booleanDisjoint from \"@turf/boolean-disjoint\";\nimport lineOffset from \"@turf/line-offset\";\nimport lineToPolygon from \"@turf/line-to-polygon\";\nimport difference from \"@turf/difference\";\nimport { lineString } from \"@turf/helpers\";\n\nimport {\n  modeName,\n  passingModeName,\n  highlightPropertyName,\n  defaultOptions,\n} from \"./constants\";\n\nconst SplitPolygonMode = {};\n\nSplitPolygonMode.onSetup = function (opt) {\n  const {\n    featureIds = [],\n    highlightColor = defaultOptions.highlightColor,\n    lineWidth = defaultOptions.lineWidth,\n    lineWidthUnit = defaultOptions.lineWidthUnit,\n    onSelectFeatureRequest = defaultOptions.onSelectFeatureRequest,\n  } = opt || {};\n\n  const api = this._ctx.api;\n\n  const featuresToSplit = [];\n  const selectedFeatures = this.getSelected();\n\n  if (featureIds.length !== 0) {\n    featuresToSplit.push.apply(\n      featuresToSplit,\n      featureIds.map((id) => api.get(id))\n    );\n  } else if (selectedFeatures.length !== 0) {\n    featuresToSplit.push.apply(\n      featuresToSplit,\n      selectedFeatures\n        .filter(\n          (f) =>\n            f.type === geojsonTypes.POLYGON ||\n            f.type === geojsonTypes.MULTI_POLYGON\n        )\n        .map((f) => f.toGeoJSON())\n    );\n  } else {\n    return onSelectFeatureRequest();\n  }\n\n  const state = {\n    options: {\n      highlightColor,\n      lineWidth,\n      lineWidthUnit,\n    },\n    featuresToSplit,\n    api,\n  };\n\n  /// `onSetup` job should complete for this mode to work.\n  /// so `setTimeout` is used to bupass mode change after `onSetup` is done executing.\n  setTimeout(this.drawAndSplit.bind(this, state), 0);\n  this.highlighFeatures(state);\n\n  return state;\n};\n\nSplitPolygonMode.drawAndSplit = function (state) {\n  const { api, options } = state;\n  const { lineWidth, lineWidthUnit } = options;\n\n  try {\n    this.changeMode(passingModeName, {\n      onDraw: (cuttingLineString) => {\n        const newPolygons = [];\n        state.featuresToSplit.forEach((el) => {\n          if (booleanDisjoint(el, cuttingLineString)) {\n            console.info(`Line was outside of Polygon ${el.id}`);\n            newPolygons.push(el);\n            return;\n          } else if (lineWidth === 0) {\n            const polycut = polygonCut(el.geometry, cuttingLineString.geometry);\n            polycut.id = el.id;\n            api.add(polycut);\n            newPolygons.push(polycut);\n          } else {\n            const polycut = polygonCutWithSpacing(\n              el.geometry,\n              cuttingLineString.geometry,\n              {\n                line_width: lineWidth,\n                line_width_unit: lineWidthUnit,\n              }\n            );\n            polycut.id = el.id;\n            api.add(polycut);\n            newPolygons.push(polycut);\n          }\n        });\n\n        this.fireUpdate(newPolygons);\n        this.highlighFeatures(state, false);\n      },\n      onCancel: () => {\n        setTimeout(() => {\n          try {\n            state.api.changeMode(\"simple_select\");\n            state.api.deleteAll();\n          } catch (error) {\n            console.error(\" ~ file: mode.js ~ line 115 ~ err\", error);\n          }\n        }, 0);\n        this.highlighFeatures(state, false);\n      },\n    });\n  } catch (err) {\n    console.error(\" ~ file: mode.js ~ line 122 ~ err\", err);\n  }\n};\n\nSplitPolygonMode.highlighFeatures = function (state, shouldHighlight = true) {\n  const color = shouldHighlight ? state.options.highlightColor : undefined;\n\n  state.featuresToSplit.forEach((f) => {\n    state.api.setFeatureProperty(f.id, highlightPropertyName, color);\n  });\n};\n\nSplitPolygonMode.toDisplayFeatures = function (state, geojson, display) {\n  display(geojson);\n};\n\nSplitPolygonMode.fireUpdate = function (newF) {\n  this.map.fire(events.UPDATE, {\n    action: modeName,\n    features: newF,\n  });\n};\n\nexport default SplitPolygonMode;\n\n/// Note: currently has some issues, but generally is a better approach\nfunction polygonCut(poly, line) {\n  return polygonSplitter(poly, line);\n}\n\n/// Adopted from https://gis.stackexchange.com/a/344277/145409\nfunction polygonCutWithSpacing(poly, line, options) {\n  const { line_width, line_width_unit } = options || {};\n\n  const offsetLine = [];\n  const retVal = null;\n  let i, j, intersectPoints, forCut, forSelect;\n  let thickLineString, thickLinePolygon, clipped;\n\n  if (\n    typeof line_width === \"undefined\" ||\n    typeof line_width_unit === \"undefined\" ||\n    (poly.type != geojsonTypes.POLYGON &&\n      poly.type != geojsonTypes.MULTI_POLYGON) ||\n    line.type != geojsonTypes.LINE_STRING\n  ) {\n    return retVal;\n  }\n\n  /// if line and polygon don't intersect return.\n  if (booleanDisjoint(line, poly)) {\n    return retVal;\n  }\n\n  intersectPoints = lineIntersect(poly, line);\n  if (intersectPoints.features.length === 0) {\n    return retVal;\n  }\n\n  /// Creating two new lines at sides of the splitting lineString\n  offsetLine[0] = lineOffset(line, line_width, {\n    units: line_width_unit,\n  });\n  offsetLine[1] = lineOffset(line, -line_width, {\n    units: line_width_unit,\n  });\n\n  for (i = 0; i <= 1; i++) {\n    forCut = i;\n    forSelect = (i + 1) % 2;\n    const polyCoords = [];\n    for (j = 0; j < line.coordinates.length; j++) {\n      polyCoords.push(line.coordinates[j]);\n    }\n    for (j = offsetLine[forCut].geometry.coordinates.length - 1; j >= 0; j--) {\n      polyCoords.push(offsetLine[forCut].geometry.coordinates[j]);\n    }\n    polyCoords.push(line.coordinates[0]);\n\n    thickLineString = lineString(polyCoords);\n    thickLinePolygon = lineToPolygon(thickLineString);\n    clipped = difference(poly, thickLinePolygon);\n  }\n\n  return clipped;\n}\n","import {\n  modeName,\n  highlightPropertyName as _highlightPropertyName,\n} from \"./constants\";\n\nconst highlightPropertyName = `user_${_highlightPropertyName}`;\n\nconst customDrawStyles = (defaultStyle) =>\n  defaultStyle\n    .map((style) => {\n      if (style.id.endsWith(\"inactive\")) {\n        return {\n          ...style,\n          /// here \"!has\" is used cause the gl-draw supported that instead of ['!', ['has', ...]]\n          filter: [...style.filter, [\"!has\", highlightPropertyName]],\n        };\n      }\n\n      return style;\n    })\n    .concat([\n      {\n        id: `${modeName}-fill-active`,\n        type: \"fill\",\n        filter: [\n          \"all\",\n          [\"==\", \"active\", \"false\"],\n          [\"==\", \"$type\", \"Polygon\"],\n          [\"has\", highlightPropertyName],\n        ],\n        paint: {\n          \"fill-color\": [\"get\", highlightPropertyName],\n          \"fill-outline-color\": [\"get\", highlightPropertyName],\n          \"fill-opacity\": 0.1,\n        },\n      },\n      {\n        id: `${modeName}-stroke-active`,\n        type: \"line\",\n        filter: [\n          \"all\",\n          [\"==\", \"active\", \"false\"],\n          [\"==\", \"$type\", \"Polygon\"],\n          [\"has\", highlightPropertyName],\n        ],\n        layout: {\n          \"line-cap\": \"round\",\n          \"line-join\": \"round\",\n        },\n        paint: {\n          \"line-color\": [\"get\", highlightPropertyName],\n          \"line-dasharray\": [0.2, 2],\n          \"line-width\": 2,\n        },\n      },\n    ]);\n\nexport default customDrawStyles;\n","import * as Constants from '../constants';\n\nexport function isOfMetaType(type) {\n  return function(e) {\n    const featureTarget = e.featureTarget;\n    if (!featureTarget) return false;\n    if (!featureTarget.properties) return false;\n    return featureTarget.properties.meta === type;\n  };\n}\n\nexport function isShiftMousedown(e) {\n  if (!e.originalEvent) return false;\n  if (!e.originalEvent.shiftKey) return false;\n  return e.originalEvent.button === 0;\n}\n\nexport function isActiveFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.active === Constants.activeStates.ACTIVE &&\n    e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function isInactiveFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.active === Constants.activeStates.INACTIVE &&\n    e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function noTarget(e) {\n  return e.featureTarget === undefined;\n}\n\nexport function isFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function isVertex(e) {\n  const featureTarget = e.featureTarget;\n  if (!featureTarget) return false;\n  if (!featureTarget.properties) return false;\n  return featureTarget.properties.meta === Constants.meta.VERTEX;\n}\n\nexport function isShiftDown(e) {\n  if (!e.originalEvent) return false;\n  return e.originalEvent.shiftKey === true;\n}\n\nexport function isEscapeKey(e) {\n  return e.keyCode === 27;\n}\n\nexport function isEnterKey(e) {\n  return e.keyCode === 13;\n}\n\nexport function isTrue() {\n  return true;\n}\n","import * as CommonSelectors from '../lib/common_selectors';\nimport * as Constants from '../constants';\n\nconst DrawPoint = {};\n\nDrawPoint.onSetup = function() {\n  const point = this.newFeature({\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: Constants.geojsonTypes.POINT,\n      coordinates: []\n    }\n  });\n\n  this.addFeature(point);\n\n  this.clearSelectedFeatures();\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.activateUIButton(Constants.types.POINT);\n\n  this.setActionableState({\n    trash: true\n  });\n\n  return { point };\n};\n\nDrawPoint.stopDrawingAndRemove = function(state) {\n  this.deleteFeature([state.point.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nDrawPoint.onTap = DrawPoint.onClick = function(state, e) {\n  this.updateUIClasses({ mouse: Constants.cursors.MOVE });\n  state.point.updateCoordinate('', e.lngLat.lng, e.lngLat.lat);\n  this.map.fire(Constants.events.CREATE, {\n    features: [state.point.toGeoJSON()]\n  });\n  this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.point.id] });\n};\n\nDrawPoint.onStop = function(state) {\n  this.activateUIButton();\n  if (!state.point.getCoordinate().length) {\n    this.deleteFeature([state.point.id], { silent: true });\n  }\n};\n\nDrawPoint.toDisplayFeatures = function(state, geojson, display) {\n  // Never render the point we're drawing\n  const isActivePoint = geojson.properties.id === state.point.id;\n  geojson.properties.active = (isActivePoint) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  if (!isActivePoint) return display(geojson);\n};\n\nDrawPoint.onTrash = DrawPoint.stopDrawingAndRemove;\n\nDrawPoint.onKeyUp = function(state, e) {\n  if (CommonSelectors.isEscapeKey(e) || CommonSelectors.isEnterKey(e)) {\n    return this.stopDrawingAndRemove(state, e);\n  }\n};\n\nexport default DrawPoint;\n","import draw_point from \"@mapbox/mapbox-gl-draw/src/modes/draw_point\";\nimport * as Constants from \"@mapbox/mapbox-gl-draw/src/constants\";\n\nconst {\n  onSetup: originOnSetup,\n  onClick: originOnClick,\n  ...restOriginMethods\n} = draw_point;\n\nconst passing_draw_point = {\n  originOnSetup,\n  originOnClick,\n  ...restOriginMethods,\n};\n\npassing_draw_point.onSetup = function (opt) {\n  const state = this.originOnSetup();\n  const { onDraw, onCancel } = opt;\n  state.onDraw = onDraw;\n  state.onCancel = onCancel;\n  return state;\n};\n\npassing_draw_point.onTap = passing_draw_point.onClick = function (state, e) {\n  this.updateUIClasses({ mouse: Constants.cursors.MOVE });\n  state.point.updateCoordinate(\"\", e.lngLat.lng, e.lngLat.lat);\n\n  if (typeof state.onDraw === \"function\") state.onDraw(state.point.toGeoJSON());\n  else\n    this.map.fire(\"draw.passing-create\", {\n      features: [state.point.toGeoJSON()],\n    });\n\n  this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n};\n\npassing_draw_point.onMouseMove = function (state, e) {\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  state.point.updateCoordinate(e.lngLat.lng, e.lngLat.lat);\n};\n\npassing_draw_point.onStop = function (state) {\n  const f = state.point;\n\n  /// check to see if we've deleted this feature\n  const drawnFeature = this.getFeature(f.id);\n  if (drawnFeature === undefined) {\n    /// Call `onCancel` if exists.\n    if (typeof state.onCancel === \"function\") state.onCancel();\n    return;\n  }\n\n  this.activateUIButton();\n  this.deleteFeature([state.point.id], { silent: true });\n};\n\nexport default passing_draw_point;\n","function isEventAtCoordinates(event, coordinates) {\n  if (!event.lngLat) return false;\n  return event.lngLat.lng === coordinates[0] && event.lngLat.lat === coordinates[1];\n}\n\nexport default isEventAtCoordinates;\n","export default {\n  enable(ctx) {\n    setTimeout(() => {\n      // First check we've got a map and some context.\n      if (!ctx.map || !ctx.map.doubleClickZoom || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue) return;\n      // Now check initial state wasn't false (we leave it disabled if so)\n      if (!ctx._ctx.store.getInitialConfigValue('doubleClickZoom')) return;\n      ctx.map.doubleClickZoom.enable();\n    }, 0);\n  },\n  disable(ctx) {\n    setTimeout(() => {\n      if (!ctx.map || !ctx.map.doubleClickZoom) return;\n      // Always disable here, as it's necessary in some cases.\n      ctx.map.doubleClickZoom.disable();\n    }, 0);\n  }\n};\n","import * as Constants from '../constants';\n\n/**\n * Returns GeoJSON for a Point representing the\n * vertex of another feature.\n *\n * @param {string} parentId\n * @param {Array<number>} coordinates\n * @param {string} path - Dot-separated numbers indicating exactly\n *   where the point exists within its parent feature's coordinates.\n * @param {boolean} selected\n * @return {GeoJSON} Point\n */\nexport default function(parentId, coordinates, path, selected) {\n  return {\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {\n      meta: Constants.meta.VERTEX,\n      parent: parentId,\n      coord_path: path,\n      active: (selected) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE\n    },\n    geometry: {\n      type: Constants.geojsonTypes.POINT,\n      coordinates\n    }\n  };\n}\n","import * as CommonSelectors from '../lib/common_selectors';\nimport isEventAtCoordinates from '../lib/is_event_at_coordinates';\nimport doubleClickZoom from '../lib/double_click_zoom';\nimport * as Constants from '../constants';\nimport createVertex from '../lib/create_vertex';\n\nconst DrawLineString = {};\n\nDrawLineString.onSetup = function(opts) {\n  opts = opts || {};\n  const featureId = opts.featureId;\n\n  let line, currentVertexPosition;\n  let direction = 'forward';\n  if (featureId) {\n    line = this.getFeature(featureId);\n    if (!line) {\n      throw new Error('Could not find a feature with the provided featureId');\n    }\n    let from = opts.from;\n    if (from && from.type === 'Feature' && from.geometry && from.geometry.type === 'Point') {\n      from = from.geometry;\n    }\n    if (from && from.type === 'Point' && from.coordinates && from.coordinates.length === 2) {\n      from = from.coordinates;\n    }\n    if (!from || !Array.isArray(from)) {\n      throw new Error('Please use the `from` property to indicate which point to continue the line from');\n    }\n    const lastCoord = line.coordinates.length - 1;\n    if (line.coordinates[lastCoord][0] === from[0] && line.coordinates[lastCoord][1] === from[1]) {\n      currentVertexPosition = lastCoord + 1;\n      // add one new coordinate to continue from\n      line.addCoordinate(currentVertexPosition, ...line.coordinates[lastCoord]);\n    } else if (line.coordinates[0][0] === from[0] && line.coordinates[0][1] === from[1]) {\n      direction = 'backwards';\n      currentVertexPosition = 0;\n      // add one new coordinate to continue from\n      line.addCoordinate(currentVertexPosition, ...line.coordinates[0]);\n    } else {\n      throw new Error('`from` should match the point at either the start or the end of the provided LineString');\n    }\n  } else {\n    line = this.newFeature({\n      type: Constants.geojsonTypes.FEATURE,\n      properties: {},\n      geometry: {\n        type: Constants.geojsonTypes.LINE_STRING,\n        coordinates: []\n      }\n    });\n    currentVertexPosition = 0;\n    this.addFeature(line);\n  }\n\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.activateUIButton(Constants.types.LINE);\n  this.setActionableState({\n    trash: true\n  });\n\n  return {\n    line,\n    currentVertexPosition,\n    direction\n  };\n};\n\nDrawLineString.clickAnywhere = function(state, e) {\n  if (state.currentVertexPosition > 0 && isEventAtCoordinates(e, state.line.coordinates[state.currentVertexPosition - 1]) ||\n      state.direction === 'backwards' && isEventAtCoordinates(e, state.line.coordinates[state.currentVertexPosition + 1])) {\n    return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });\n  }\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);\n  if (state.direction === 'forward') {\n    state.currentVertexPosition++;\n    state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);\n  } else {\n    state.line.addCoordinate(0, e.lngLat.lng, e.lngLat.lat);\n  }\n};\n\nDrawLineString.clickOnVertex = function(state) {\n  return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });\n};\n\nDrawLineString.onMouseMove = function(state, e) {\n  state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);\n  if (CommonSelectors.isVertex(e)) {\n    this.updateUIClasses({ mouse: Constants.cursors.POINTER });\n  }\n};\n\nDrawLineString.onTap = DrawLineString.onClick = function(state, e) {\n  if (CommonSelectors.isVertex(e)) return this.clickOnVertex(state, e);\n  this.clickAnywhere(state, e);\n};\n\nDrawLineString.onKeyUp = function(state, e) {\n  if (CommonSelectors.isEnterKey(e)) {\n    this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });\n  } else if (CommonSelectors.isEscapeKey(e)) {\n    this.deleteFeature([state.line.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT);\n  }\n};\n\nDrawLineString.onStop = function(state) {\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  // check to see if we've deleted this feature\n  if (this.getFeature(state.line.id) === undefined) return;\n\n  //remove last added coordinate\n  state.line.removeCoordinate(`${state.currentVertexPosition}`);\n  if (state.line.isValid()) {\n    this.map.fire(Constants.events.CREATE, {\n      features: [state.line.toGeoJSON()]\n    });\n  } else {\n    this.deleteFeature([state.line.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n  }\n};\n\nDrawLineString.onTrash = function(state) {\n  this.deleteFeature([state.line.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nDrawLineString.toDisplayFeatures = function(state, geojson, display) {\n  const isActiveLine = geojson.properties.id === state.line.id;\n  geojson.properties.active = (isActiveLine) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  if (!isActiveLine) return display(geojson);\n  // Only render the line if it has at least one real coordinate\n  if (geojson.geometry.coordinates.length < 2) return;\n  geojson.properties.meta = Constants.meta.FEATURE;\n  display(createVertex(\n    state.line.id,\n    geojson.geometry.coordinates[state.direction === 'forward' ? geojson.geometry.coordinates.length - 2 : 1],\n    `${state.direction === 'forward' ? geojson.geometry.coordinates.length - 2 : 1}`,\n    false\n  ));\n\n  display(geojson);\n};\n\nexport default DrawLineString;\n","import draw_line_string from \"@mapbox/mapbox-gl-draw/src/modes/draw_line_string\";\nimport doubleClickZoom from \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\";\nimport * as Constants from \"@mapbox/mapbox-gl-draw/src/constants\";\n\nconst {\n  onSetup: originOnSetup,\n  onMouseMove: originOnMouseMove,\n  ...restOriginMethods\n} = draw_line_string;\n\nconst passing_draw_line_string = {\n  originOnSetup,\n  originOnMouseMove,\n  ...restOriginMethods,\n};\n\npassing_draw_line_string.onSetup = function (opt) {\n  const state = this.originOnSetup();\n  const { onDraw, onCancel } = opt;\n  state.onDraw = onDraw;\n  state.onCancel = onCancel;\n  return state;\n};\n\npassing_draw_line_string.onMouseMove = function (state, e) {\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.originOnMouseMove(state, e);\n};\n\npassing_draw_line_string.onStop = function (state) {\n  const f = state.line;\n\n  this.updateUIClasses({ mouse: Constants.cursors.NONE });\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  /// check to see if we've deleted this feature\n  const drawnFeature = this.getFeature(f.id);\n  if (drawnFeature === undefined) {\n    /// Call `onCancel` if exists.\n    if (typeof state.onCancel === \"function\") state.onCancel();\n    return;\n  }\n  /// remove last added coordinate\n  else f.removeCoordinate(`${state.currentVertexPosition}`);\n\n  if (f.isValid()) {\n    if (typeof state.onDraw === \"function\") state.onDraw(f.toGeoJSON());\n    else\n      this.map.fire(\"draw.passing-create\", {\n        features: [f.toGeoJSON()],\n      });\n  }\n  this.deleteFeature([f.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n};\n\nexport default passing_draw_line_string;\n","import * as CommonSelectors from '../lib/common_selectors';\nimport doubleClickZoom from '../lib/double_click_zoom';\nimport * as Constants from '../constants';\nimport isEventAtCoordinates from '../lib/is_event_at_coordinates';\nimport createVertex from '../lib/create_vertex';\n\nconst DrawPolygon = {};\n\nDrawPolygon.onSetup = function() {\n  const polygon = this.newFeature({\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: Constants.geojsonTypes.POLYGON,\n      coordinates: [[]]\n    }\n  });\n\n  this.addFeature(polygon);\n\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.activateUIButton(Constants.types.POLYGON);\n  this.setActionableState({\n    trash: true\n  });\n\n  return {\n    polygon,\n    currentVertexPosition: 0\n  };\n};\n\nDrawPolygon.clickAnywhere = function(state, e) {\n  if (state.currentVertexPosition > 0 && isEventAtCoordinates(e, state.polygon.coordinates[0][state.currentVertexPosition - 1])) {\n    return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });\n  }\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);\n  state.currentVertexPosition++;\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);\n};\n\nDrawPolygon.clickOnVertex = function(state) {\n  return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });\n};\n\nDrawPolygon.onMouseMove = function(state, e) {\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);\n  if (CommonSelectors.isVertex(e)) {\n    this.updateUIClasses({ mouse: Constants.cursors.POINTER });\n  }\n};\n\nDrawPolygon.onTap = DrawPolygon.onClick = function(state, e) {\n  if (CommonSelectors.isVertex(e)) return this.clickOnVertex(state, e);\n  return this.clickAnywhere(state, e);\n};\n\nDrawPolygon.onKeyUp = function(state, e) {\n  if (CommonSelectors.isEscapeKey(e)) {\n    this.deleteFeature([state.polygon.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT);\n  } else if (CommonSelectors.isEnterKey(e)) {\n    this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });\n  }\n};\n\nDrawPolygon.onStop = function(state) {\n  this.updateUIClasses({ mouse: Constants.cursors.NONE });\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  // check to see if we've deleted this feature\n  if (this.getFeature(state.polygon.id) === undefined) return;\n\n  //remove last added coordinate\n  state.polygon.removeCoordinate(`0.${state.currentVertexPosition}`);\n  if (state.polygon.isValid()) {\n    this.map.fire(Constants.events.CREATE, {\n      features: [state.polygon.toGeoJSON()]\n    });\n  } else {\n    this.deleteFeature([state.polygon.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n  }\n};\n\nDrawPolygon.toDisplayFeatures = function(state, geojson, display) {\n  const isActivePolygon = geojson.properties.id === state.polygon.id;\n  geojson.properties.active = (isActivePolygon) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  if (!isActivePolygon) return display(geojson);\n\n  // Don't render a polygon until it has two positions\n  // (and a 3rd which is just the first repeated)\n  if (geojson.geometry.coordinates.length === 0) return;\n\n  const coordinateCount = geojson.geometry.coordinates[0].length;\n  // 2 coordinates after selecting a draw type\n  // 3 after creating the first point\n  if (coordinateCount < 3) {\n    return;\n  }\n  geojson.properties.meta = Constants.meta.FEATURE;\n  display(createVertex(state.polygon.id, geojson.geometry.coordinates[0][0], '0.0', false));\n  if (coordinateCount > 3) {\n    // Add a start position marker to the map, clicking on this will finish the feature\n    // This should only be shown when we're in a valid spot\n    const endPos = geojson.geometry.coordinates[0].length - 3;\n    display(createVertex(state.polygon.id, geojson.geometry.coordinates[0][endPos], `0.${endPos}`, false));\n  }\n  if (coordinateCount <= 4) {\n    // If we've only drawn two positions (plus the closer),\n    // make a LineString instead of a Polygon\n    const lineCoordinates = [\n      [geojson.geometry.coordinates[0][0][0], geojson.geometry.coordinates[0][0][1]], [geojson.geometry.coordinates[0][1][0], geojson.geometry.coordinates[0][1][1]]\n    ];\n    // create an initial vertex so that we can track the first point on mobile devices\n    display({\n      type: Constants.geojsonTypes.FEATURE,\n      properties: geojson.properties,\n      geometry: {\n        coordinates: lineCoordinates,\n        type: Constants.geojsonTypes.LINE_STRING\n      }\n    });\n    if (coordinateCount === 3) {\n      return;\n    }\n  }\n  // render the Polygon\n  return display(geojson);\n};\n\nDrawPolygon.onTrash = function(state) {\n  this.deleteFeature([state.polygon.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nexport default DrawPolygon;\n","import draw_polygon from \"@mapbox/mapbox-gl-draw/src/modes/draw_polygon\";\nimport doubleClickZoom from \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\";\nimport * as Constants from \"@mapbox/mapbox-gl-draw/src/constants\";\n\nconst {\n  onSetup: originOnSetup,\n  onMouseMove: originOnMouseMove,\n  ...restOriginMethods\n} = draw_polygon;\n\nconst passing_draw_polygon = {\n  originOnSetup,\n  originOnMouseMove,\n  ...restOriginMethods,\n};\n\npassing_draw_polygon.onSetup = function (opt) {\n  const state = this.originOnSetup();\n  const { onDraw, onCancel } = opt;\n  state.onDraw = onDraw;\n  state.onCancel = onCancel;\n  return state;\n};\n\npassing_draw_polygon.onMouseMove = function (state, e) {\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.originOnMouseMove(state, e);\n};\n\npassing_draw_polygon.onStop = function (state) {\n  const f = state.polygon;\n\n  this.updateUIClasses({ mouse: Constants.cursors.NONE });\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  /// check to see if we've deleted this feature\n  const drawnFeature = this.getFeature(f.id);\n  if (drawnFeature === undefined) {\n    /// Call `onCancel` if exists.\n    if (typeof state.onCancel === \"function\") state.onCancel();\n    return;\n  }\n  /// remove last added coordinate\n  else f.removeCoordinate(`${state.currentVertexPosition}`);\n\n  if (f.isValid()) {\n    if (typeof state.onDraw === \"function\") state.onDraw(f.toGeoJSON());\n    else\n      this.map.fire(\"draw.passing-create\", {\n        features: [f.toGeoJSON()],\n      });\n  }\n  this.deleteFeature([f.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n};\n\nexport default passing_draw_polygon;\n","export const modeName = \"select_feature\";\n\n/// when a (multi-)polygon feature is hovered to be selected, it gets highlighted.\n/// here is the name of the property indicating the highlight.\nexport const highlightPropertyName = `${modeName}_highlight`;\n\nexport const defaultOptions = {\n  highlightColor: \"#222\",\n};\n","import doubleClickZoom from \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\";\nimport * as Constants from \"@mapbox/mapbox-gl-draw/src/constants\";\nimport { isEscapeKey } from \"@mapbox/mapbox-gl-draw/src/lib/common_selectors\";\n\nimport { defaultOptions, highlightPropertyName } from \"./constants\";\n\nconst select_mode = {};\n\nselect_mode.onSetup = function (opt) {\n  const { selectHighlightColor, onSelect, onCancel } = opt;\n  const state = {};\n  state.hoveredFeatureID = null;\n  state.selectedFeatureID = null;\n  state.onSelect = onSelect;\n  state.onCancel = onCancel;\n  state.api = this._ctx.api;\n  const {\n    selectHighlightColor:\n      defaultSelectHighlightColor = defaultOptions.highlightColor,\n  } = this._ctx.options;\n  state.options = {\n    selectHighlightColor: selectHighlightColor || defaultSelectHighlightColor,\n  };\n\n  return state;\n};\n\nselect_mode.onMouseMove = function (state, e) {\n  const { api } = state;\n  const { featureTarget } = e;\n  // this.originOnMouseMove(state, e);\n\n  if (featureTarget) {\n    this.updateUIClasses({ mouse: Constants.cursors.POINTER });\n    const hoveringFeatureID = featureTarget.properties.id;\n    if (\n      state.hoveredFeatureID !== null &&\n      state.hoveredFeatureID !== hoveringFeatureID\n    ) {\n      api.setFeatureProperty(\n        state.hoveredFeatureID,\n        highlightPropertyName,\n        undefined\n      );\n    }\n    state.hoveredFeatureID = hoveringFeatureID;\n    api.setFeatureProperty(\n      state.hoveredFeatureID,\n      highlightPropertyName,\n      state.options.selectHighlightColor\n    );\n  } else {\n    if (state.hoveredFeatureID)\n      api.setFeatureProperty(\n        state.hoveredFeatureID,\n        highlightPropertyName,\n        undefined\n      );\n    state.hoveredFeatureID = null;\n  }\n};\n\nselect_mode.onClick = function (state, e) {\n  state.selectedFeatureID = state.hoveredFeatureID;\n  this.onStop(state, e);\n};\n\nselect_mode.toDisplayFeatures = function (state, geojson, display) {\n  display(geojson);\n};\n\nselect_mode.onKeyUp = function (state, e) {\n  if (isEscapeKey(e)) {\n    this.changeMode(Constants.modes.SIMPLE_SELECT);\n  }\n};\n\nselect_mode.onStop = function (state) {\n  this.updateUIClasses({ mouse: Constants.cursors.NONE });\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  if (state.selectedFeatureID) {\n    if (typeof state.onSelect === \"function\")\n      state.onSelect(state.selectedFeatureID);\n    else\n      this.map.fire(\"draw.select_mode.select\", {\n        featureID: state.selectedFeatureID,\n      });\n\n    state.selectedFeatureID = null;\n    this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n  } else {\n    /// Call `onCancel` if exists.\n    if (typeof state.onCancel === \"function\") state.onCancel();\n  }\n\n  if (state.hoveredFeatureID) {\n    this._ctx.api.setFeatureProperty(\n      state.hoveredFeatureID,\n      highlightPropertyName,\n      undefined\n    );\n    state.hoveredFeatureID = null;\n  }\n};\n\nexport default select_mode;\n","import { default as selectFeatureMode } from \"./mode.js\";\nimport { default as drawStyles } from \"./customDrawStyles.js\";\n\nimport { modeName } from \"./constants\";\n\nexport { selectFeatureMode };\nexport { drawStyles };\n\nexport default function SelectFeatureMode(modes) {\n  return {\n    ...modes,\n    [modeName]: selectFeatureMode,\n  };\n}\n","import { default as splitPolygonMode } from \"./mode.js\";\nimport { default as drawStyles } from \"./customDrawStyles.js\";\nimport * as Constants from \"./constants\";\n\nimport { passing_draw_line_string } from \"mapbox-gl-draw-passing-mode\";\nimport SelectFeatureMode from \"mapbox-gl-draw-select-mode\";\nimport { modeName, passingModeName } from \"./constants\";\n\nexport { splitPolygonMode };\nexport { drawStyles };\nexport { Constants };\n\nexport default function SplitPolygonMode(modes) {\n  return {\n    ...SelectFeatureMode(modes),\n    [passingModeName]: passing_draw_line_string,\n    [modeName]: splitPolygonMode,\n  };\n}\n"],"names":["clone","geojson","Error","type","cloneFeature","cloned","Object","keys","forEach","key","features","map","feature","cloneFeatureCollection","cloneGeometry","properties","cloneProperties","geometry","value","Array","isArray","item","geom","bbox","geometries","g","coordinates","deepSlice","coords","slice","coord","earthRadius","factors","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","options","feat","id","polygon","_i","coordinates_1","length","ring","j","lineString","featureCollection","fc","multiLineString","multiPolygon","lengthToDegrees","distance","units","factor","lengthToRadians","Math","PI","isNumber","num","isNaN","isObject","input","constructor","getCoords","getGeom","booleanClockwise","line","prev","cur","sum","i","coordEach","callback","excludeWrapCoord","k","l","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","featureEach","geomEach","featureProperties","featureBBox","featureId","undefined","flattenEach","coordinate","rewindFeature","reverse","rewindLineString","rewindPolygon","lineCoords","pointInPolygon","p","ii","f","u1","v1","u2","v2","currentP","nextP","x","y","numContours","contourLen","contour","splitter","elen","e","flen","h","Q","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","vec","n","Float64Array","B","C1","C2","D","u","orient2d","ax","ay","bx","by","cx","cy","detleft","detright","det","detsum","abs","acxtail","acytail","bcxtail","bcytail","c","ahi","alo","bhi","blo","_j","_0","s1","s0","t1","t0","u3","acx","bcx","acy","bcy","estimate","errbound","C1len","C2len","Dlen","orient2dadapt","Edge","p1","p2","edgeType","index","contourId","this","originalIndex","polygonContourId","interiorRing","minX","min","minY","maxX","max","maxY","intersectionPoints","nextEdge","Point","Contour","rawCoords","edgeIntersectsBbox","edge","IntersectionPoint","edge1","edge2","isHeadingIn","polylineEdge","polygonEdge","distanceFromPolylineEdgeStart","distanceFromPolygonEdgeStart","push","visitCount","xs","ys","sqrt","prototype","incrementVisitCount","crossProduct","a","b","dotProduct","toPoint","s","d","getEdgeIntersection","lineEdge","potentialEdge","noEndpointTouch","va","vb","kross","sqrKross","sqrLenA","t","sqrLenE","sa","sb","smin","smax","poly","mutate","results","result","rewind","intersections","polygonEdges","polylineEdges","contours","polyEdges","lineEdges","polylineBbox","numberOfRingsInPolygon","linegeom","linecoords","edgeCount","lineLength","prevEdge","nextPoint","prevPoint","polygeom","polycoords","polyLength","i$1","polyLenth2","ii$1","polygonSet","polyLenth3","firstPoint","p1$1","p2$1","e$1","prevEdge$1","firstEdge","iii","intersectPolylineBbox","fillQueue","Infinity","intersectingPoints","count","polyCount","intersection","ip","sort","findIntersectionPoints","numberIntersectionsByRing","infiniteLoopGuard","outPolys","firstPolyStart","pe","polyStart","nextPolyStart","unvisitedPolyFound","index$1","outPoly","nextIntersection","walkPolygonForwards","override","index$2","walkPolylineForwards","walkPolylineBackwards","unvisitedPolyFound$1","index$3","intersection$2","outCoordinates","index$4","createAsHoleOrAddAsNewOuterRing","findRingFromEdge","findFirstPolygonEdge","parseInt","find","unusedRing","existingRing","inside","intersectionPoint","currentIndex","findIndexOfIntersectionPoint","nextIp","condition","lastPointOnEdge","nextIntersection$1","lastIntersection","cursors","types","geojsonTypes","modes","events","meta","activeStates","lineSegment","segments","reduce","previousCoords","currentCoords","coords1","coords2","x1","y1","x2","y2","segment","createSegments","lineSegmentFeature","quickselect","arr","left","right","compare","quickselectStep","defaultCompare","m","z","log","exp","sd","floor","swap","tmp","findItem","items","equalsFn","indexOf","calcBBox","node","toBBox","distBBox","children","destNode","createNode","child","extend","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","intersectionArea","contains","intersects","height","multiSelect","stack","pop","mid","ceil","maxEntries","_maxEntries","_minEntries","clear","all","_all","data","search","nodesToSearch","childBBox","collides","load","insert","_build","_splitRoot","tmpNode","_insert","remove","path","indexes","parent","goingUp","splice","_condense","compareMinX","compareMinY","toJSON","fromJSON","N","M","pow","N2","N1","right2","right3","_chooseSubtree","level","targetNode","minArea","minEnlargement","area","enlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","minOverlap","bbox1","bbox2","overlap","_allDistMargin","leftBBox","rightBBox","margin","siblings","point","multiPoint","radiansToLength","exports","radiansToDegrees","defineProperty","unitsFactors","areaFactors","acres","hectares","_options","points","polygons","lineStrings","geometryCollection","round","precision","multiplier","bearingToAzimuth","bearing","angle","degreesToRadians","convertLength","originalUnit","finalUnit","convertArea","startFactor","finalFactor","validateBBox","validateId","js","helpers","require$$0","propEach","segmentEach","segmentIndex","previousFeatureIndex","previousMultiIndex","prevGeomIndex","currentCoord","featureIndexCoord","multiPartIndexCoord","currentSegment","lineEach","js$1","coordAll","coordReduce","initialValue","previousValue","featureReduce","currentFeature","findPoint","findSegment","flattenReduce","geomReduce","currentGeometry","lineReduce","currentLine","propReduce","currentProperties","segmentReduce","started","meta_1","default","rbush","require$$1","require$$2","turfBBox","require$$3","geojsonRbush","tree","call","equals","json","lineIntersect","line1","line2","unique","intersect","match","join","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","booleanPointInPolygon","pt","getCoord","polys","inBBox","insidePoly","inRing","ignoreBoundary","inHole","isInside","xi","yi","xj","yj","polygonToLine","coordsToLine","multiPoly","lines","multiPolygonToLine","booleanDisjoint","feature1","feature2","bool","flatten1","flatten2","geom1","geom2","pair1","pair2","isPointOnLine","lineString1","lineString2","isLineOnLine","isLineInPoly","_a","_b","_c","isPolyInPoly","disjoint","isPointOnLineSegment","lineSegmentStart","lineSegmentEnd","dxc","dyc","dxl","dyl","ab","start","end","isParallel","r","q","cross","add","v","scalarMult","intersectSegments","lineOffset","_name","getType","lineOffsetFeature","offsetDegrees","finalCoords","point1","point2","offset","L","out1x","out2x","out1y","out2y","seg2Coords","lineToPolygon","autoComplete","orderCoords","lineStringToPolygon","autoCompleteCoords","multiCoords","largestArea","west","south","east","north","calculateArea","unshift","first","last","__generator","thisArg","body","_","label","sent","trys","ops","next","verb","throw","return","Symbol","iterator","op","TypeError","done","step","geojsonRbushModule","geojsonRbush$1","Node","DEFAULT_COMPARE","splay","comparator","cmp","split","printRow","root","prefix","isTail","out","printNode","indent","Tree","_root","_size","_comparator","_remove","findStatic","current","visitor","ctx","range","low","high","fn","values","minNode","maxNode","at","successor","predecessor","toList","head","presort","size","loadRecursive","mergedList","l1","l2","mergeLists","createList","sortedListToBST","isEmpty","get","enumerable","configurable","toString","String","update","newKey","newData","merge","middle","list","pivot","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","writable","_createClass","protoProps","staticProps","isInBbox","ll","ur","getBboxOverlap","b1","b2","lowerX","upperX","epsilon","Number","EPSILON","EPSILON_SQ","PtRounder","reset","xRounder","CoordRounder","yRounder","SplayTree","prevNode","nextNode","rounder","compareVectorAngles","basePt","endPt1","endPt2","cosineOfAngle","pShared","pBase","pAngle","vBase","vAngle","horizontalIntersection","verticalIntersection","SweepEvent","isLeft","ptCmp","comparePoints","link","Segment","aPt","bPt","other","otherEvents","iMax","evt","checkForConsuming","numEvents","evt1","consumedBy","evt2","otherSE","consume","ringOut","isInResult","baseEvent","_this","cache","Map","fillCache","linkedEvent","nextEvent","set","sine","cosine","has","_cache$get","asine","acosine","_cache$get2","bsine","bcosine","segmentId","leftSE","rightSE","rings","windings","alx","blx","arx","brx","aly","bly","ary","bry","aCmpBLeft","comparePoint","bCmpARight","bCmpALeft","aCmpBRight","_bCmpARight","_aCmpBRight","newRightSE","isAnEndpoint","lPt","rPt","vector","yDist","xFromYDist","xDist","yFromXDist","tBbox","oBbox","bboxOverlap","tlp","trp","olp","orp","touchesOtherLSE","touchesThisLSE","touchesOtherRSE","touchesThisRSE","pt1","pt2","ve","d1","d2","newEvents","alreadyLinked","newLeftSE","oldRightSE","replaceRightSE","newSeg","swapEvents","tmpEvt","consumer","consumee","_tmp","winding","_prevInResult","prevInResult","_beforeState","seg","afterState","multiPolys","_afterState","beforeState","ringsAfter","windingsAfter","mpsAfter","polysAfter","polysExclude","_iMax","_ring","isExterior","_index","_i2","_iMax2","mp","_isInResult","mpsBefore","operation","noBefores","noAfters","least","most","numMultiPolys","diff","isJustSubject","mps","isSubject","concat","leftPt","rightPt","cmpPts","RingIn","geomRing","fromRing","sweepEvents","PolyIn","geomPoly","exteriorRing","interiorRings","getSweepEvents","ringSweepEvents","jMax","MultiPolyIn","ex","POSITIVE_INFINITY","NEGATIVE_INFINITY","polySweepEvents","RingOut","allSegments","ringsOut","prevEvent","event","startingPoint","intersectionLEs","availableLEs","getAvailableLinkedEvents","firstPt","lastPt","indexLE","getLeftmostComparator","intersectionLE","ringEvents","prevPt","_pt","_nextPt","nextPt","shift","isExteriorRing","iStart","iEnd","orderedPoints","_isExteriorRing","enclosing","enclosingRing","_enclosingRing","_calcEnclosingRing","leftMostEvt","prevSeg","prevPrevSeg","PolyOut","ringGeom","MultiPolyOut","_composePolys","polyGeom","addInterior","SweepLine","queue","arguments","nextSeg","prevMySplitter","prevInter","getIntersection","newEventsFromSplit","_splitSafely","nextMySplitter","nextInter","_newEventsFromSplit","mySplitter","_newEventsFromSplit2","inter","_newEventsFromSplit3","_i3","_iMax3","_newEventsFromSplit4","_i4","_iMax4","POLYGON_CLIPPING_MAX_QUEUE_SIZE","process","env","POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS","Operation","moreGeoms","multipolys","subject","mpA","_jMax","sweepLine","prevQueueSize","_evt","factory","subjectGeom","_len4","clippingGeoms","_key4","run","difference","polygon1","polygon2","differenced","polygonClipping","modeName","passingModeName","highlightPropertyName","defaultOptions","highlightColor","lineWidth","lineWidthUnit","onSelectFeatureRequest","SplitPolygonMode","onSetup","opt","featureIds","api","_ctx","featuresToSplit","selectedFeatures","getSelected","apply","filter","toGeoJSON","state","setTimeout","drawAndSplit","bind","highlighFeatures","changeMode","onDraw","cuttingLineString","newPolygons","el","console","info","polycut","polygonSplitter","line_width","line_width_unit","offsetLine","retVal","intersectPoints","forCut","thickLineString","thickLinePolygon","clipped","polyCoords","polygonCutWithSpacing","fireUpdate","onCancel","deleteAll","error","err","SplitPolygonMode$1","shouldHighlight","color","setFeatureProperty","toDisplayFeatures","display","newF","fire","action","isVertex","featureTarget","Constants.meta","isEscapeKey","keyCode","isEnterKey","DrawPoint","newFeature","Constants.geojsonTypes","addFeature","clearSelectedFeatures","updateUIClasses","mouse","Constants.cursors","activateUIButton","Constants.types","setActionableState","trash","deleteFeature","silent","Constants.modes","onTap","onClick","updateCoordinate","lngLat","lng","lat","Constants.events","onStop","getCoordinate","isActivePoint","active","Constants.activeStates","onTrash","stopDrawingAndRemove","onKeyUp","CommonSelectors.isEscapeKey","CommonSelectors.isEnterKey","originOnSetup","originOnClick","restOriginMethods","draw_point","isEventAtCoordinates","doubleClickZoom","enable","store","getInitialConfigValue","disable","createVertex","parentId","selected","coord_path","DrawLineString","opts","currentVertexPosition","direction","getFeature","from","lastCoord","addCoordinate","CommonSelectors.isVertex","clickOnVertex","clickAnywhere","removeCoordinate","isValid","isActiveLine","onMouseMove","originOnMouseMove","draw_line_string","passing_draw_line_string","DrawPolygon","isActivePolygon","coordinateCount","endPos","lineCoordinates","draw_polygon","select_mode","SelectFeatureMode","selectFeatureMode","selectHighlightColor","onSelect","defaultSelectHighlightColor","hoveringFeatureID","hoveredFeatureID","selectedFeatureID","featureID","modeName$1","splitPolygonMode","defaultStyle","style","endsWith","paint","layout"],"mappings":"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"}