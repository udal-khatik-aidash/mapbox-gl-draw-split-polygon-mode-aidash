{"version":3,"file":"index.js","sources":["../node_modules/@turf/clone/dist/es/index.js","../node_modules/@turf/invariant/dist/es/index.js","../node_modules/@turf/boolean-clockwise/dist/es/index.js","../node_modules/@turf/meta/node_modules/@turf/helpers/dist/es/index.js","../node_modules/@turf/meta/dist/es/index.js","../node_modules/@turf/rewind/dist/es/index.js","../node_modules/@turf/rewind/node_modules/@turf/helpers/dist/es/index.js","../node_modules/point-in-polygon-hao/dist/pointInPolygon.mjs","../node_modules/robust-predicates/esm/util.js","../node_modules/robust-predicates/esm/orient2d.js","../node_modules/polygon-splitter/dist/polygonsplitter.mjs","../node_modules/@mapbox/mapbox-gl-draw/src/constants.js","../node_modules/@turf/helpers/dist/esm/index.js","../node_modules/sweepline-intersections/dist/sweeplineIntersections.esm.js","../node_modules/@turf/line-intersect/dist/esm/index.js","../node_modules/@turf/boolean-disjoint/node_modules/@turf/invariant/dist/esm/index.js","../node_modules/@turf/boolean-disjoint/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js","../node_modules/@turf/boolean-disjoint/node_modules/@turf/meta/dist/esm/index.js","../node_modules/@turf/boolean-disjoint/node_modules/@turf/polygon-to-line/dist/esm/index.js","../node_modules/@turf/boolean-disjoint/dist/esm/index.js","../node_modules/@turf/line-offset/node_modules/@turf/meta/dist/esm/index.js","../node_modules/@turf/line-offset/dist/esm/index.js","../node_modules/@turf/line-offset/node_modules/@turf/invariant/dist/esm/index.js","../node_modules/@turf/line-to-polygon/node_modules/@turf/meta/dist/esm/index.js","../node_modules/@turf/line-to-polygon/node_modules/@turf/bbox/dist/esm/index.js","../node_modules/@turf/line-to-polygon/node_modules/@turf/clone/dist/esm/index.js","../node_modules/@turf/line-to-polygon/dist/esm/index.js","../node_modules/@turf/line-to-polygon/node_modules/@turf/invariant/dist/esm/index.js","../node_modules/bignumber.js/bignumber.mjs","../node_modules/splaytree-ts/dist/esm/index.js","../node_modules/polyclip-ts/dist/esm/index.js","../node_modules/@turf/difference/dist/esm/index.js","../node_modules/@turf/difference/node_modules/@turf/meta/dist/esm/index.js","../node_modules/@turf/bbox/dist/es/index.js","../node_modules/@turf/boolean-point-in-polygon/dist/es/index.js","../node_modules/@turf/boolean-point-on-line/dist/es/index.js","../node_modules/@turf/boolean-contains/dist/es/index.js","../src/constants.js","../src/utils.js","../src/mode.js","../src/customDrawStyles.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js","../node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_point.js","../node_modules/mapbox-gl-draw-passing-mode/src/passing_draw_point.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/is_event_at_coordinates.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js","../node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_line_string.js","../node_modules/mapbox-gl-draw-passing-mode/src/passing_draw_line_string.js","../node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_polygon.js","../node_modules/mapbox-gl-draw-passing-mode/src/passing_draw_polygon.js","../node_modules/mapbox-gl-draw-select-mode/src/constants.js","../node_modules/mapbox-gl-draw-select-mode/src/mode.js","../node_modules/mapbox-gl-draw-select-mode/src/index.js","../src/index.js"],"sourcesContent":["/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @name clone\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    switch (geojson.type) {\n        case \"Feature\":\n            return cloneFeature(geojson);\n        case \"FeatureCollection\":\n            return cloneFeatureCollection(geojson);\n        case \"Point\":\n        case \"LineString\":\n        case \"Polygon\":\n        case \"MultiPoint\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n        case \"GeometryCollection\":\n            return cloneGeometry(geojson);\n        default:\n            throw new Error(\"unknown GeoJSON type\");\n    }\n}\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson) {\n    var cloned = { type: \"Feature\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"properties\":\n            case \"geometry\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add properties & geometry last\n    cloned.properties = cloneProperties(geojson.properties);\n    cloned.geometry = cloneGeometry(geojson.geometry);\n    return cloned;\n}\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties) {\n    var cloned = {};\n    if (!properties) {\n        return cloned;\n    }\n    Object.keys(properties).forEach(function (key) {\n        var value = properties[key];\n        if (typeof value === \"object\") {\n            if (value === null) {\n                // handle null\n                cloned[key] = null;\n            }\n            else if (Array.isArray(value)) {\n                // handle Array\n                cloned[key] = value.map(function (item) {\n                    return item;\n                });\n            }\n            else {\n                // handle generic Object\n                cloned[key] = cloneProperties(value);\n            }\n        }\n        else {\n            cloned[key] = value;\n        }\n    });\n    return cloned;\n}\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson) {\n    var cloned = { type: \"FeatureCollection\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"features\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add features\n    cloned.features = geojson.features.map(function (feature) {\n        return cloneFeature(feature);\n    });\n    return cloned;\n}\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry) {\n    var geom = { type: geometry.type };\n    if (geometry.bbox) {\n        geom.bbox = geometry.bbox;\n    }\n    if (geometry.type === \"GeometryCollection\") {\n        geom.geometries = geometry.geometries.map(function (g) {\n            return cloneGeometry(g);\n        });\n        return geom;\n    }\n    geom.coordinates = deepSlice(geometry.coordinates);\n    return geom;\n}\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice(coords) {\n    var cloned = coords;\n    if (typeof cloned[0] !== \"object\") {\n        return cloned.slice();\n    }\n    return cloned.map(function (coord) {\n        return deepSlice(coord);\n    });\n}\nexport default clone;\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoords } from \"@turf/invariant\";\n/**\n * Takes a ring and return true or false whether or not the ring is clockwise or counter-clockwise.\n *\n * @name booleanClockwise\n * @param {Feature<LineString>|LineString|Array<Array<number>>} line to be evaluated\n * @returns {boolean} true/false\n * @example\n * var clockwiseRing = turf.lineString([[0,0],[1,1],[1,0],[0,0]]);\n * var counterClockwiseRing = turf.lineString([[0,0],[1,0],[1,1],[0,0]]);\n *\n * turf.booleanClockwise(clockwiseRing)\n * //=true\n * turf.booleanClockwise(counterClockwiseRing)\n * //=false\n */\nexport default function booleanClockwise(line) {\n    var ring = getCoords(line);\n    var sum = 0;\n    var i = 1;\n    var prev;\n    var cur;\n    while (i < ring.length) {\n        prev = cur || ring[0];\n        cur = ring[i];\n        sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);\n        i++;\n    }\n    return sum > 0;\n}\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { feature, lineString, isObject, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\n","import clone from '@turf/clone';\nimport booleanClockwise from '@turf/boolean-clockwise';\nimport { featureEach, geomEach } from '@turf/meta';\nimport { getCoords } from '@turf/invariant';\nimport { isObject, featureCollection } from '@turf/helpers';\n\n/**\n * Rewind {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon} outer ring counterclockwise and inner rings clockwise (Uses {@link http://en.wikipedia.org/wiki/Shoelace_formula|Shoelace Formula}).\n *\n * @name rewind\n * @param {GeoJSON} geojson input GeoJSON Polygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.reverse=false] enable reverse winding\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} rewind Polygon\n * @example\n * var polygon = turf.polygon([[[121, -29], [138, -29], [138, -18], [121, -18], [121, -29]]]);\n *\n * var rewind = turf.rewind(polygon);\n *\n * //addToMap\n * var addToMap = [rewind];\n */\nfunction rewind(geojson, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var reverse = options.reverse || false;\n  var mutate = options.mutate || false;\n\n  // validation\n  if (!geojson) throw new Error(\"<geojson> is required\");\n  if (typeof reverse !== \"boolean\")\n    throw new Error(\"<reverse> must be a boolean\");\n  if (typeof mutate !== \"boolean\")\n    throw new Error(\"<mutate> must be a boolean\");\n\n  // prevent input mutation\n  if (mutate === false) geojson = clone(geojson);\n\n  // Support Feature Collection or Geometry Collection\n  var results = [];\n  switch (geojson.type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        rewindFeature(geometry, reverse);\n      });\n      return geojson;\n    case \"FeatureCollection\":\n      featureEach(geojson, function (feature) {\n        featureEach(rewindFeature(feature, reverse), function (result) {\n          results.push(result);\n        });\n      });\n      return featureCollection(results);\n  }\n  // Support Feature or Geometry Objects\n  return rewindFeature(geojson, reverse);\n}\n\n/**\n * Rewind\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Geometry or Feature\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {Geometry|Feature<any>} rewind Geometry or Feature\n */\nfunction rewindFeature(geojson, reverse) {\n  var type = geojson.type === \"Feature\" ? geojson.geometry.type : geojson.type;\n\n  // Support all GeoJSON Geometry Objects\n  switch (type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        rewindFeature(geometry, reverse);\n      });\n      return geojson;\n    case \"LineString\":\n      rewindLineString(getCoords(geojson), reverse);\n      return geojson;\n    case \"Polygon\":\n      rewindPolygon(getCoords(geojson), reverse);\n      return geojson;\n    case \"MultiLineString\":\n      getCoords(geojson).forEach(function (lineCoords) {\n        rewindLineString(lineCoords, reverse);\n      });\n      return geojson;\n    case \"MultiPolygon\":\n      getCoords(geojson).forEach(function (lineCoords) {\n        rewindPolygon(lineCoords, reverse);\n      });\n      return geojson;\n    case \"Point\":\n    case \"MultiPoint\":\n      return geojson;\n  }\n}\n\n/**\n * Rewind LineString - outer ring clockwise\n *\n * @private\n * @param {Array<Array<number>>} coords GeoJSON LineString geometry coordinates\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {void} mutates coordinates\n */\nfunction rewindLineString(coords, reverse) {\n  if (booleanClockwise(coords) === reverse) coords.reverse();\n}\n\n/**\n * Rewind Polygon - outer ring counterclockwise and inner rings clockwise.\n *\n * @private\n * @param {Array<Array<Array<number>>>} coords GeoJSON Polygon geometry coordinates\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {void} mutates coordinates\n */\nfunction rewindPolygon(coords, reverse) {\n  // outer ring\n  if (booleanClockwise(coords[0]) !== reverse) {\n    coords[0].reverse();\n  }\n  // inner rings\n  for (var i = 1; i < coords.length; i++) {\n    if (booleanClockwise(coords[i]) === reverse) {\n      coords[i].reverse();\n    }\n  }\n}\n\nexport default rewind;\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","function pointInPolygon(p, polygon) {\n    var i = 0;\n    var ii = 0;\n    var k = 0;\n    var f = 0;\n    var u1 = 0;\n    var v1 = 0;\n    var u2 = 0;\n    var v2 = 0;\n    var currentP = null;\n    var nextP = null;\n\n    var x = p[0];\n    var y = p[1];\n\n    var numContours = polygon.length;\n    for (i; i < numContours; i++) {\n        ii = 0;\n        var contourLen = polygon[i].length - 1;\n        var contour = polygon[i];\n\n        currentP = contour[0];\n        if (currentP[0] !== contour[contourLen][0] &&\n            currentP[1] !== contour[contourLen][1]) {\n            throw new Error('First and last coordinates in a ring must be the same')\n        }\n\n        u1 = currentP[0] - x;\n        v1 = currentP[1] - y;\n\n        for (ii; ii < contourLen; ii++) {\n            nextP = contour[ii + 1];\n\n            v2 = nextP[1] - y;\n\n            if ((v1 < 0 && v2 < 0) || (v1 > 0 && v2 > 0)) {\n                currentP = nextP;\n                v1 = v2;\n                u1 = currentP[0] - x;\n                continue\n            }\n\n            u2 = nextP[0] - p[0];\n\n            if (v2 > 0 && v1 <= 0) {\n                f = (u1 * v2) - (u2 * v1);\n                if (f > 0) { k = k + 1; }\n                else if (f === 0) { return 0 }\n            } else if (v1 > 0 && v2 <= 0) {\n                f = (u1 * v2) - (u2 * v1);\n                if (f < 0) { k = k + 1; }\n                else if (f === 0) { return 0 }\n            } else if (v2 === 0 && v1 < 0) {\n                f = (u1 * v2) - (u2 * v1);\n                if (f === 0) { return 0 }\n            } else if (v1 === 0 && v2 < 0) {\n                f = u1 * v2 - u2 * v1;\n                if (f === 0) { return 0 }\n            } else if (v1 === 0 && v2 === 0) {\n                if (u2 <= 0 && u1 >= 0) {\n                    return 0\n                } else if (u1 <= 0 && u2 >= 0) {\n                    return 0\n                }\n            }\n            currentP = nextP;\n            v1 = v2;\n            u1 = u2;\n        }\n    }\n\n    if (k % 2 === 0) { return false }\n    return true\n}\n\nexport default pointInPolygon;\n","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    if (detleft === 0 || detright === 0 || (detleft > 0) !== (detright > 0)) return det;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","import rewind from '@turf/rewind';\nimport inside from 'point-in-polygon-hao';\nimport { orient2d } from 'robust-predicates';\n\nvar Edge = function Edge(p1, p2, edgeType, index, contourId) {\r\n  this.p1 = p1;\r\n  this.p2 = p2;\r\n  this.edgeType = edgeType;\r\n  this.originalIndex = index;\r\n\r\n  this.polygonContourId = contourId;\r\n  this.interiorRing = false;\r\n\r\n  this.minX = Math.min(p1.p[0], p2.p[0]);\r\n  this.minY = Math.min(p1.p[1], p2.p[1]);\r\n\r\n  this.maxX = Math.max(p1.p[0], p2.p[0]);\r\n  this.maxY = Math.max(p1.p[1], p2.p[1]);\r\n\r\n  this.intersectionPoints = [];\r\n  this.nextEdge = null;\r\n};\n\nvar Point = function Point(p) {\r\n  this.p = p;\r\n};\n\nvar Contour = function Contour(contourId, coords) {\n  this.id = contourId;\n  this.rawCoords = coords;\n};\n\nfunction fillQueue(polygon, line, polyEdges, lineEdges, polylineBbox) {\r\n  var numberOfRingsInPolygon = 0;\r\n  var contours = [];\r\n\r\n  var linegeom = line.type === 'Feature' ? line.geometry : line;\r\n  var linecoords = linegeom.type === 'LineString' ? [linegeom.coordinates] : linegeom.coordinates;\r\n\r\n  var edgeCount = 0;\r\n\r\n  for (var i = 0; i < linecoords.length; i++) {\r\n\r\n    var lineLength = linecoords[i].length - 1;\r\n    var p1 = new Point(linecoords[i][0]);\r\n    var p2 = null;\r\n    var prevEdge = {nextEdge: null};\r\n\r\n    for (var ii = 0; ii < lineLength; ii++) {\r\n      p2 = new Point(linecoords[i][ii + 1]);\r\n      p1.nextPoint = p2;\r\n      p2.prevPoint = p1;\r\n      var e = new Edge(p1, p2, 'polyline', edgeCount, null);\r\n      lineEdges.push(e);\r\n      prevEdge.nextEdge = e;\r\n      e.prevEdge = prevEdge;\r\n      polylineBbox[0] = Math.min(polylineBbox[0], p1.p[0]);\r\n      polylineBbox[1] = Math.min(polylineBbox[1], p1.p[1]);\r\n      polylineBbox[2] = Math.max(polylineBbox[2], p1.p[0]);\r\n      polylineBbox[3] = Math.max(polylineBbox[3], p1.p[1]);\r\n\r\n      p1 = p2;\r\n      edgeCount = edgeCount + 1;\r\n      prevEdge = e;\r\n    }\r\n    polylineBbox[0] = Math.min(polylineBbox[0], linecoords[i][lineLength][0]);\r\n    polylineBbox[1] = Math.min(polylineBbox[1], linecoords[i][lineLength][1]);\r\n    polylineBbox[2] = Math.max(polylineBbox[2], linecoords[i][lineLength][0]);\r\n    polylineBbox[3] = Math.max(polylineBbox[3], linecoords[i][lineLength][1]);\r\n  }\r\n\r\n  var polygeom = polygon.type === 'Feature' ? polygon.geometry : polygon;\r\n  var polycoords = polygeom.type === 'Polygon' ? [polygeom.coordinates] : polygeom.coordinates;\r\n\r\n  var polyLength = polycoords.length;\r\n\r\n  for (var i$1 = 0; i$1 < polyLength; i$1++) {\r\n\r\n    var polyLenth2 = polycoords[i$1].length;\r\n\r\n    for (var ii$1 = 0; ii$1 < polyLenth2; ii$1++) {\r\n      numberOfRingsInPolygon = numberOfRingsInPolygon + 1;\r\n\r\n      var polygonSet = polycoords[i$1][ii$1];\r\n      var polyLenth3 = polygonSet.length;\r\n      \r\n      contours.push(new Contour(numberOfRingsInPolygon, polygonSet));\r\n\r\n      var firstPoint = new Point(polygonSet[0]);\r\n      var p1$1 = firstPoint;\r\n      var p2$1 = (void 0), e$1 = null;\r\n      var prevEdge$1 = {nextEdge: null, prevEdge: null};\r\n      var firstEdge = null;\r\n\r\n      for (var iii = 1; iii < polyLenth3; iii++) {\r\n        p2$1 = new Point(polygonSet[iii]);\r\n        p1$1.nextPoint = p2$1;\r\n        p2$1.prevPoint = p1$1;\r\n\r\n        e$1 = new Edge(p1$1, p2$1, 'polygon', edgeCount, numberOfRingsInPolygon);\r\n        prevEdge$1.nextEdge = e$1;\r\n        e$1.prevEdge = prevEdge$1;\r\n        if (iii === 1) { firstEdge = e$1; }\r\n\r\n        if (ii$1 > 0) { e$1.interiorRing = true; }\r\n        e$1.intersectPolylineBbox = edgeIntersectsBbox(e$1, polylineBbox);\r\n        polyEdges.push(e$1);\r\n\r\n        p1$1 = p2$1;\r\n        edgeCount = edgeCount + 1;\r\n        prevEdge$1 = e$1;\r\n      }\r\n\r\n      e$1.nextEdge = firstEdge;\r\n      firstEdge.prevEdge = e$1;\r\n      p2$1.nextPoint = firstPoint.nextPoint;\r\n      firstPoint.prevPoint = p2$1.prevPoint;\r\n    }\r\n  }\r\n  return contours\r\n}\r\n\r\nfunction edgeIntersectsBbox(edge, bbox) {\r\n  if (edge.maxX < bbox[0]) { return false }\r\n  if (edge.minX > bbox[2]) { return false }\r\n  if (edge.maxY < bbox[1]) { return false }\r\n  if (edge.minY > bbox[3]) { return false }\r\n  return true\r\n}\n\nvar IntersectionPoint = function IntersectionPoint(p, edge1, edge2, isHeadingIn) {\r\n  this.p = p;\r\n  this.polylineEdge = edge1;\r\n  this.polygonEdge = edge2;\r\n  this.isHeadingIn = isHeadingIn;\r\n\r\n  this.distanceFromPolylineEdgeStart = distance(this.polylineEdge.p1.p, this.p);\r\n  this.distanceFromPolygonEdgeStart = distance(this.polygonEdge.p1.p, this.p);\r\n\r\n  this.polygonEdge.intersectionPoints.push(this);\r\n  this.polylineEdge.intersectionPoints.push(this);\r\n\r\n  this.visitCount = 0;\r\n};\r\n\r\nIntersectionPoint.prototype.incrementVisitCount = function incrementVisitCount () {\r\n  this.visitCount = this.visitCount + 1;\r\n};\r\n\r\nfunction distance(p1, p2) {\r\n  var xs = p2[0] - p1[0];\r\n  var ys = p2[1] - p1[1];\r\n  xs *= xs;\r\n  ys *= ys;\r\n\r\n  return Math.sqrt(xs + ys)\r\n}\n\nfunction findIntersectionPoints(polygonEdges, lineEdges, intersectingPoints) {\r\n  var i, ii, iii;\r\n  var count = lineEdges.length;\r\n  var polyCount = polygonEdges.length;\r\n  for (i = 0; i < count; i++) {\r\n    var lineEdge = lineEdges[i];\r\n\r\n    for (ii = 0; ii < polyCount; ii++) {\r\n      var polygonEdge = polygonEdges[ii];\r\n      if (!polygonEdge.intersectPolylineBbox) { continue }\r\n\r\n      if (polygonEdge.maxX < lineEdge.minX || polygonEdge.minX > lineEdge.maxX) { continue }\r\n      if (polygonEdge.maxY < lineEdge.minY || polygonEdge.minY > lineEdge.maxY) { continue }\r\n      var intersection = getEdgeIntersection(lineEdge, polygonEdge);\r\n      if (intersection !== null) {\r\n        for (iii = 0; iii < intersection.length; iii++) {\r\n          var isHeadingIn = orient2d(polygonEdge.p1.p[0], polygonEdge.p1.p[1], polygonEdge.p2.p[0], polygonEdge.p2.p[1], lineEdge.p1.p[0], lineEdge.p1.p[1]);\r\n          var ip = new IntersectionPoint(intersection[iii], lineEdge, polygonEdge, isHeadingIn > 0);\r\n          intersectingPoints.push(ip);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  lineEdges.forEach(function (edge) {\r\n    edge.intersectionPoints.sort(function (a, b) {\r\n      return a.distanceFromPolylineEdgeStart - b.distanceFromPolylineEdgeStart\r\n    });\r\n  });\r\n\r\n  polygonEdges.forEach(function (edge) {\r\n    edge.intersectionPoints.sort(function (a, b) {\r\n      return a.distanceFromPolygonEdgeStart - b.distanceFromPolygonEdgeStart\r\n    });\r\n  });\r\n}\r\n\r\nvar EPSILON = 1e-9;\r\n\r\nfunction crossProduct(a, b) {\r\n  return (a[0] * b[1]) - (a[1] * b[0])\r\n}\r\n\r\nfunction dotProduct(a, b) {\r\n  return (a[0] * b[0]) + (a[1] * b[1])\r\n}\r\n\r\nfunction toPoint(p, s, d) {\r\n  return [\r\n    p[0] + s * d[0],\r\n    p[1] + s * d[1]\r\n  ]\r\n}\r\n\r\nfunction getEdgeIntersection(lineEdge, potentialEdge, noEndpointTouch) {\r\n  var va = [lineEdge.p2.p[0] - lineEdge.p1.p[0], lineEdge.p2.p[1] - lineEdge.p1.p[1]];\r\n  var vb = [potentialEdge.p2.p[0] - potentialEdge.p1.p[0], potentialEdge.p2.p[1] - potentialEdge.p1.p[1]];\r\n\r\n  var e = [potentialEdge.p1.p[0] - lineEdge.p1.p[0], potentialEdge.p1.p[1] - lineEdge.p1.p[1]];\r\n  var kross = crossProduct(va, vb);\r\n  var sqrKross = kross * kross;\r\n  var sqrLenA  = dotProduct(va, va);\r\n\r\n  if (sqrKross > 0) {\r\n\r\n    var s = crossProduct(e, vb) / kross;\r\n    if (s < 0 || s > 1) { return null }\r\n    var t = crossProduct(e, va) / kross;\r\n    if (t < 0 || t > 1) { return null }\r\n    if (s === 0 || s === 1) {\r\n      // on an endpoint of line segment a\r\n      return noEndpointTouch ? null : [toPoint(lineEdge.p1.p, s, va)]\r\n    }\r\n    if (t === 0 || t === 1) {\r\n      // on an endpoint of line segment b\r\n      return noEndpointTouch ? null : [toPoint(potentialEdge.p1.p, t, vb)]\r\n    }\r\n    return [toPoint(lineEdge.p1.p, s, va)]\r\n  }\r\n\r\n  var sqrLenE = dotProduct(e, e);\r\n  kross = crossProduct(e, va);\r\n  sqrKross = kross * kross;\r\n\r\n  if (sqrKross > EPSILON * sqrLenA * sqrLenE) { return null }\r\n\r\n  var sa = dotProduct(va, e) / sqrLenA;\r\n  var sb = sa + dotProduct(va, vb) / sqrLenA;\r\n  var smin = Math.min(sa, sb);\r\n  var smax = Math.max(sa, sb);\r\n\r\n  if (smin <= 1 && smax >= 0) {\r\n\r\n    if (smin === 1) { return noEndpointTouch ? null : [toPoint(lineEdge.p1.p, smin > 0 ? smin : 0, va)] }\r\n\r\n    if (smax === 0) { return noEndpointTouch ? null : [toPoint(lineEdge.p1.p, smax < 1 ? smax : 1, va)] }\r\n\r\n    if (noEndpointTouch && smin === 0 && smax === 1) { return null }\r\n\r\n    return [\r\n      toPoint(lineEdge.p1.p, smin > 0 ? smin : 0, va),\r\n      toPoint(lineEdge.p1.p, smax < 1 ? smax : 1, va)\r\n    ]\r\n  }\r\n\r\n  return null\r\n}\n\n// import { _debugCandidatePoly, _debugIntersectionPoint, _debugLinePoints, _debugIntersectionPoints, _debugPolyStart } from './debug'\r\n\r\nfunction index (polygon, line) {\r\n  var poly = rewind(polygon);\r\n\r\n  var intersections = [];\r\n  var polygonEdges = [];\r\n  var polylineEdges = [];\r\n  var polylineBbox = [Infinity, Infinity, Infinity, Infinity];\r\n\r\n  var contours = fillQueue(poly, line, polygonEdges, polylineEdges, polylineBbox);\r\n\r\n  findIntersectionPoints(polygonEdges, polylineEdges, intersections);\r\n\r\n  if (intersections.length === 0) {\r\n    return polygon\r\n  }\r\n\r\n  // Track the number of intersections per contour\r\n  // This is useful for holes or outerrings that aren't intersected\r\n  // so that we can manually add them back in at the end\r\n  var numberIntersectionsByRing = {};\r\n  contours.forEach(function (c) { return numberIntersectionsByRing[c.id] = 0; }); //eslint-disable-line\r\n  intersections.forEach(function (i) {\r\n    var id = i.polygonEdge.polygonContourId;\r\n    numberIntersectionsByRing[id] = numberIntersectionsByRing[id] + 1;\r\n  });\r\n\r\n\r\n  var infiniteLoopGuard = 0;\r\n  var outPolys = [];\r\n  // _debugIntersectionPoints(intersections)\r\n  // Start the rewiring of the outputs from the first intersection point along the polyline line\r\n  // This step makes a difference (eg see the another.geojson harness file)\r\n  var firstPolyStart = null;\r\n  for (var index = 0; index < polylineEdges.length; index++) {\r\n    var pe = polylineEdges[index];\r\n    if (pe.intersectionPoints.length > 0) {\r\n      firstPolyStart = pe.intersectionPoints[0];\r\n      break\r\n    }\r\n  }\r\n\r\n  var polyStart = firstPolyStart;\r\n  var nextPolyStart = {visitCount: 1};\r\n  // Basically we're going to walk our way around the outside of the polygon\r\n  // to find new output polygons until we get back to the beginning\r\n  while (firstPolyStart !== nextPolyStart) {\r\n    if (infiniteLoopGuard > intersections.length * 2) {\r\n      break\r\n    }\r\n    infiniteLoopGuard = infiniteLoopGuard++;\r\n\r\n    // If we've already visited this intersection point a couple of times we've\r\n    // already used it in it's two output polygons\r\n\r\n    if (nextPolyStart.visitCount >= 2) {\r\n      var unvisitedPolyFound = false;\r\n      for (var index$1 = 0; index$1 < intersections.length; index$1++) {\r\n        var intersection = intersections[index$1];\r\n        if (intersection.visitCount < 2) {\r\n          polyStart = intersection;\r\n          unvisitedPolyFound = true;\r\n          break\r\n        }\r\n      }\r\n      if (!unvisitedPolyFound) { break }\r\n    }\r\n\r\n    polyStart.visitCount = polyStart.visitCount + 1;\r\n    var outPoly = [];\r\n    outPolys.push(outPoly);\r\n    outPoly.push(polyStart.p);\r\n\r\n    polyStart.visitCount = polyStart.visitCount + 1;\r\n    var nextIntersection = walkPolygonForwards(polyStart, outPoly);\r\n    // _debugCandidatePoly(outPolys)\r\n    // After we've walked the first stretch of the polygon we now have the\r\n    // starting point for our next output polygon\r\n    nextPolyStart = nextIntersection;\r\n\r\n\r\n    // Although sometimes we walk all the way around the outside\r\n    // because our split line goes from outer to inner ring\r\n    var override = false;\r\n    if (nextIntersection === nextPolyStart && intersections.length === 2) {\r\n      for (var index$2 = 0; index$2 < intersections.length; index$2++) {\r\n        var intersection$1 = intersections[index$2];\r\n        if (intersection$1.visitCount < 2) {\r\n          override = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // An ouput polygon has to contain at least 1 stretch from the original polygon\r\n    // and one stretch from the polyline\r\n    // However it can contain many stretches of each\r\n    // So we walk continually from polyline to polygon collecting the output\r\n    while (nextIntersection !== polyStart || override) {\r\n      var methodForPolyline = nextIntersection.isHeadingIn ? walkPolylineForwards : walkPolylineBackwards;\r\n      nextIntersection = methodForPolyline(nextIntersection, outPoly);\r\n      // _debugCandidatePoly(outPolys)\r\n\r\n      if (nextIntersection !== polyStart) {\r\n        nextIntersection = walkPolygonForwards(nextIntersection, outPoly);\r\n        // _debugCandidatePoly(outPolys)\r\n      }\r\n      override = false;\r\n    }\r\n\r\n    if (nextPolyStart.visitCount >= 2) {\r\n      var unvisitedPolyFound$1 = false;\r\n      for (var index$3 = 0; index$3 < intersections.length; index$3++) {\r\n        var intersection$2 = intersections[index$3];\r\n        if (intersection$2.visitCount < 2) {\r\n          polyStart = intersection$2;\r\n          unvisitedPolyFound$1 = true;\r\n          break\r\n        }\r\n      }\r\n      if (unvisitedPolyFound$1) {\r\n        nextPolyStart = polyStart;\r\n      }\r\n    }\r\n\r\n    // Finally we set the next start point based on what we found earlier\r\n    polyStart = nextPolyStart;\r\n  }\r\n\r\n  var outCoordinates = outPolys.map(function (poly) { return [poly]; });\r\n\r\n  var keys = Object.keys(numberIntersectionsByRing);\r\n  for (var index$4 = 0; index$4 < keys.length; index$4++) {\r\n    var key = keys[index$4];\r\n    var value = numberIntersectionsByRing[key];\r\n    if (value === 0) {\r\n      var edge = findFirstPolygonEdge(polygonEdges, parseInt(key));\r\n      var ring = findRingFromEdge(edge, contours);\r\n      createAsHoleOrAddAsNewOuterRing(ring, outCoordinates);\r\n    }\r\n  }\r\n\r\n  return {\r\n    type: 'Feature',\r\n    properties: {},\r\n    geometry: {\r\n      type: 'MultiPolygon',\r\n      coordinates: outCoordinates\r\n    }\r\n  }\r\n}\r\n\r\nfunction findFirstPolygonEdge(polygonEdges, contourId) {\r\n  for (var index = 0; index < polygonEdges.length; index++) {\r\n    var edge = polygonEdges[index];\r\n    if (edge.polygonContourId === contourId) { return edge }\r\n  }\r\n}\r\n\r\nfunction findRingFromEdge(edge, contours) {\r\n  var contour = contours.find(function (c) { return c.id === edge.polygonContourId; });\r\n  return contour.rawCoords\r\n}\r\n\r\nfunction createAsHoleOrAddAsNewOuterRing(unusedRing, outCoordinates) {\r\n  for (var index = 0; index < outCoordinates.length; index++) {\r\n    var existingRing = outCoordinates[index];\r\n    if (inside(unusedRing[0], [existingRing[0]])) {\r\n      existingRing.push(unusedRing);\r\n      return\r\n    }\r\n  }\r\n  // If no match is found push it as a new outer ring\r\n  outCoordinates.push([unusedRing]);\r\n}\r\n\r\n// Walk around the polygon collecting vertices\r\nfunction walkPolygonForwards(intersectionPoint, outPoly) {\r\n  var nextEdge = intersectionPoint.polygonEdge;\r\n  if (nextEdge.intersectionPoints.length > 1) {\r\n    // _debugIntersectionPoint(intersectionPoint)\r\n    var lastPointOnEdge = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];\r\n    if (lastPointOnEdge !== intersectionPoint) {\r\n      var currentIndex = findIndexOfIntersectionPoint(intersectionPoint, nextEdge.intersectionPoints);\r\n      var nextIp = nextEdge.intersectionPoints[currentIndex + 1];\r\n      outPoly.push(nextIp.p);\r\n      nextIp.incrementVisitCount();\r\n      return nextIp\r\n    }\r\n  }\r\n  var condition = true;\r\n  while (condition) {\r\n    outPoly.push(nextEdge.p2.p);\r\n    nextEdge = nextEdge.nextEdge;\r\n    if (nextEdge === null) { return intersectionPoint }\r\n    else if (nextEdge.intersectionPoints.length > 0) { condition = false; }\r\n  }\r\n  nextEdge.intersectionPoints[0].incrementVisitCount();\r\n  outPoly.push(nextEdge.intersectionPoints[0].p);\r\n  return nextEdge.intersectionPoints[0]\r\n}\r\n\r\n// Given a set of intersections find the next one\r\nfunction findIndexOfIntersectionPoint(intersection, intersections) {\r\n  for (var index = 0; index < intersections.length; index++) {\r\n    var int = intersections[index];\r\n    if (int === intersection) { return index }\r\n  }\r\n  return null\r\n}\r\n\r\n\r\nfunction walkPolylineBackwards(intersectionPoint, outPoly) {\r\n  var nextEdge = intersectionPoint.polylineEdge;\r\n  if (nextEdge.intersectionPoints.length === 2) {\r\n    var lastPointOnEdge = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];\r\n    // debugger\r\n    if (lastPointOnEdge === intersectionPoint) {\r\n      var nextIntersection = nextEdge.intersectionPoints[0];\r\n      outPoly.push(nextIntersection.p);\r\n      nextIntersection.incrementVisitCount();\r\n      return nextIntersection\r\n    } else {\r\n      outPoly.push(lastPointOnEdge.p);\r\n      lastPointOnEdge.incrementVisitCount();\r\n      return lastPointOnEdge\r\n    }\r\n  } else if (nextEdge.intersectionPoints.length > 2) {\r\n    // _debugIntersectionPoint(intersectionPoint)\r\n\r\n    var lastPointOnEdge$1 = nextEdge.intersectionPoints[0];\r\n    if (lastPointOnEdge$1 !== intersectionPoint) {\r\n      var currentIndex = findIndexOfIntersectionPoint(intersectionPoint, nextEdge.intersectionPoints);\r\n      var nextIntersection$1 = nextEdge.intersectionPoints[currentIndex - 1];\r\n      outPoly.push(nextIntersection$1.p);\r\n      nextIntersection$1.incrementVisitCount();\r\n      return nextIntersection$1\r\n    }\r\n  }\r\n  var condition = true;\r\n  while (condition) {\r\n    outPoly.push(nextEdge.p1.p);\r\n    nextEdge = nextEdge.prevEdge;\r\n    if (nextEdge.originalIndex === undefined) { return intersectionPoint }\r\n    else if (nextEdge.intersectionPoints.length > 0) {\r\n      condition = false;\r\n    }\r\n  }\r\n  if (nextEdge.originalIndex === undefined) { return intersectionPoint }\r\n  var lastIntersection = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];\r\n  lastIntersection.incrementVisitCount();\r\n  outPoly.push(lastIntersection.p);\r\n  return lastIntersection\r\n}\r\n\r\nfunction walkPolylineForwards(intersectionPoint, outPoly) {\r\n  var nextEdge = intersectionPoint.polylineEdge;\r\n\r\n  if (nextEdge.intersectionPoints.length > 1) {\r\n    // _debugIntersectionPoint(intersectionPoint)\r\n    var lastPointOnEdge = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];\r\n    if (lastPointOnEdge !== intersectionPoint) {\r\n      var currentIndex = findIndexOfIntersectionPoint(intersectionPoint, nextEdge.intersectionPoints);\r\n      var nextIp = nextEdge.intersectionPoints[currentIndex + 1];\r\n      outPoly.push(nextIp.p);\r\n      nextIp.incrementVisitCount();\r\n      return nextIp\r\n    }\r\n  }\r\n  var condition = true;\r\n  while (condition) {\r\n    outPoly.push(nextEdge.p2.p);\r\n    nextEdge = nextEdge.nextEdge;\r\n    if (nextEdge === null) { return intersectionPoint }\r\n    else if (nextEdge.intersectionPoints.length > 0) { condition = false; }\r\n  }\r\n  if (nextEdge === undefined) { return intersectionPoint }\r\n  var lastIntersection = nextEdge.intersectionPoints[0];\r\n  lastIntersection.incrementVisitCount();\r\n  outPoly.push(lastIntersection.p);\r\n  return lastIntersection\r\n}\n\nexport { index as default };\n","export const classes = {\n  CONTROL_BASE: 'mapboxgl-ctrl',\n  CONTROL_PREFIX: 'mapboxgl-ctrl-',\n  CONTROL_BUTTON: 'mapbox-gl-draw_ctrl-draw-btn',\n  CONTROL_BUTTON_LINE: 'mapbox-gl-draw_line',\n  CONTROL_BUTTON_POLYGON: 'mapbox-gl-draw_polygon',\n  CONTROL_BUTTON_POINT: 'mapbox-gl-draw_point',\n  CONTROL_BUTTON_TRASH: 'mapbox-gl-draw_trash',\n  CONTROL_BUTTON_COMBINE_FEATURES: 'mapbox-gl-draw_combine',\n  CONTROL_BUTTON_UNCOMBINE_FEATURES: 'mapbox-gl-draw_uncombine',\n  CONTROL_GROUP: 'mapboxgl-ctrl-group',\n  ATTRIBUTION: 'mapboxgl-ctrl-attrib',\n  ACTIVE_BUTTON: 'active',\n  BOX_SELECT: 'mapbox-gl-draw_boxselect'\n};\n\nexport const sources = {\n  HOT: 'mapbox-gl-draw-hot',\n  COLD: 'mapbox-gl-draw-cold'\n};\n\nexport const cursors = {\n  ADD: 'add',\n  MOVE: 'move',\n  DRAG: 'drag',\n  POINTER: 'pointer',\n  NONE: 'none'\n};\n\nexport const types = {\n  POLYGON: 'polygon',\n  LINE: 'line_string',\n  POINT: 'point'\n};\n\nexport const geojsonTypes = {\n  FEATURE: 'Feature',\n  POLYGON: 'Polygon',\n  LINE_STRING: 'LineString',\n  POINT: 'Point',\n  FEATURE_COLLECTION: 'FeatureCollection',\n  MULTI_PREFIX: 'Multi',\n  MULTI_POINT: 'MultiPoint',\n  MULTI_LINE_STRING: 'MultiLineString',\n  MULTI_POLYGON: 'MultiPolygon'\n};\n\nexport const modes = {\n  DRAW_LINE_STRING: 'draw_line_string',\n  DRAW_POLYGON: 'draw_polygon',\n  DRAW_POINT: 'draw_point',\n  SIMPLE_SELECT: 'simple_select',\n  DIRECT_SELECT: 'direct_select',\n  STATIC: 'static'\n};\n\nexport const events = {\n  CREATE: 'draw.create',\n  DELETE: 'draw.delete',\n  UPDATE: 'draw.update',\n  SELECTION_CHANGE: 'draw.selectionchange',\n  MODE_CHANGE: 'draw.modechange',\n  ACTIONABLE: 'draw.actionable',\n  RENDER: 'draw.render',\n  COMBINE_FEATURES: 'draw.combine',\n  UNCOMBINE_FEATURES: 'draw.uncombine'\n};\n\nexport const updateActions = {\n  MOVE: 'move',\n  CHANGE_COORDINATES: 'change_coordinates'\n};\n\nexport const meta = {\n  FEATURE: 'feature',\n  MIDPOINT: 'midpoint',\n  VERTEX: 'vertex'\n};\n\nexport const activeStates = {\n  ACTIVE: 'true',\n  INACTIVE: 'false'\n};\n\nexport const interactions = [\n  'scrollZoom',\n  'boxZoom',\n  'dragRotate',\n  'dragPan',\n  'keyboard',\n  'doubleClickZoom',\n  'touchZoomRotate'\n];\n\nexport const LAT_MIN = -90;\nexport const LAT_RENDERED_MIN = -85;\nexport const LAT_MAX = 90;\nexport const LAT_RENDERED_MAX = 85;\nexport const LNG_MIN = -270;\nexport const LNG_MAX = 270;\n","// index.ts\nvar earthRadius = 63710088e-1;\nvar factors = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: 360 / (2 * Math.PI),\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1e3,\n  kilometres: earthRadius / 1e3,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1e3,\n  millimetres: earthRadius * 1e3,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936\n};\nvar areaFactors = {\n  acres: 247105e-9,\n  centimeters: 1e4,\n  centimetres: 1e4,\n  feet: 10.763910417,\n  hectares: 1e-4,\n  inches: 1550.003100006,\n  kilometers: 1e-6,\n  kilometres: 1e-6,\n  meters: 1,\n  metres: 1,\n  miles: 386e-9,\n  nauticalmiles: 29155334959812285e-23,\n  millimeters: 1e6,\n  millimetres: 1e6,\n  yards: 1.195990046\n};\nfunction feature(geom, properties, options = {}) {\n  const feat = { type: \"Feature\" };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\nfunction geometry(type, coordinates, _options = {}) {\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\nfunction point(coordinates, properties, options = {}) {\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n  const geom = {\n    type: \"Point\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction points(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return point(coords, properties);\n    }),\n    options\n  );\n}\nfunction polygon(coordinates, properties, options = {}) {\n  for (const ring of coordinates) {\n    if (ring.length < 4) {\n      throw new Error(\n        \"Each LinearRing of a Polygon must have 4 or more Positions.\"\n      );\n    }\n    if (ring[ring.length - 1].length !== ring[0].length) {\n      throw new Error(\"First and last Position are not equivalent.\");\n    }\n    for (let j = 0; j < ring[ring.length - 1].length; j++) {\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  const geom = {\n    type: \"Polygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction polygons(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return polygon(coords, properties);\n    }),\n    options\n  );\n}\nfunction lineString(coordinates, properties, options = {}) {\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  const geom = {\n    type: \"LineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction lineStrings(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return lineString(coords, properties);\n    }),\n    options\n  );\n}\nfunction featureCollection(features, options = {}) {\n  const fc = { type: \"FeatureCollection\" };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\nfunction multiLineString(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiLineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPoint(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPoint\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPolygon(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPolygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction geometryCollection(geometries, properties, options = {}) {\n  const geom = {\n    type: \"GeometryCollection\",\n    geometries\n  };\n  return feature(geom, properties, options);\n}\nfunction round(num, precision = 0) {\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  const multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\nfunction radiansToLength(radians, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\nfunction lengthToRadians(distance, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\nfunction bearingToAzimuth(bearing) {\n  let angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\nfunction azimuthToBearing(angle) {\n  angle = angle % 360;\n  if (angle > 180) {\n    return angle - 360;\n  } else if (angle < -180) {\n    return angle + 360;\n  }\n  return angle;\n}\nfunction radiansToDegrees(radians) {\n  const normalisedRadians = radians % (2 * Math.PI);\n  return normalisedRadians * 180 / Math.PI;\n}\nfunction degreesToRadians(degrees) {\n  const normalisedDegrees = degrees % 360;\n  return normalisedDegrees * Math.PI / 180;\n}\nfunction convertLength(length, originalUnit = \"kilometers\", finalUnit = \"kilometers\") {\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nfunction convertArea(area, originalUnit = \"meters\", finalUnit = \"kilometers\") {\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n  const startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n  const finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n  return area / startFactor * finalFactor;\n}\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nfunction isObject(input) {\n  return input !== null && typeof input === \"object\" && !Array.isArray(input);\n}\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach((num) => {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\nfunction validateId(id) {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\nexport {\n  areaFactors,\n  azimuthToBearing,\n  bearingToAzimuth,\n  convertArea,\n  convertLength,\n  degreesToRadians,\n  earthRadius,\n  factors,\n  feature,\n  featureCollection,\n  geometry,\n  geometryCollection,\n  isNumber,\n  isObject,\n  lengthToDegrees,\n  lengthToRadians,\n  lineString,\n  lineStrings,\n  multiLineString,\n  multiPoint,\n  multiPolygon,\n  point,\n  points,\n  polygon,\n  polygons,\n  radiansToDegrees,\n  radiansToLength,\n  round,\n  validateBBox,\n  validateId\n};\n//# sourceMappingURL=index.js.map","class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nfunction checkWhichEventIsLeft (e1, e2) {\n    if (e1.p.x > e2.p.x) return 1\n    if (e1.p.x < e2.p.x) return -1\n\n    if (e1.p.y !== e2.p.y) return e1.p.y > e2.p.y ? 1 : -1\n    return 1\n}\n\nfunction checkWhichSegmentHasRightEndpointFirst (seg1, seg2) {\n    if (seg1.rightSweepEvent.p.x > seg2.rightSweepEvent.p.x) return 1\n    if (seg1.rightSweepEvent.p.x < seg2.rightSweepEvent.p.x) return -1\n\n    if (seg1.rightSweepEvent.p.y !== seg2.rightSweepEvent.p.y) return seg1.rightSweepEvent.p.y < seg2.rightSweepEvent.p.y ? 1 : -1\n    return 1\n}\n\nclass Event {\n\n    constructor (p, featureId, ringId, eventId) {\n        this.p = {\n            x: p[0],\n            y: p[1]\n        };\n        this.featureId = featureId;\n        this.ringId = ringId;\n        this.eventId = eventId;\n\n        this.otherEvent = null;\n        this.isLeftEndpoint = null;\n    }\n\n    isSamePoint (eventToCheck) {\n        return this.p.x === eventToCheck.p.x && this.p.y === eventToCheck.p.y\n    }\n}\n\nfunction fillEventQueue (geojson, eventQueue) {\n    if (geojson.type === 'FeatureCollection') {\n        const features = geojson.features;\n        for (let i = 0; i < features.length; i++) {\n            processFeature(features[i], eventQueue);\n        }\n    } else {\n        processFeature(geojson, eventQueue);\n    }\n}\n\nlet featureId = 0;\nlet ringId = 0;\nlet eventId = 0;\nfunction processFeature (featureOrGeometry, eventQueue) {\n    const geom = featureOrGeometry.type === 'Feature' ? featureOrGeometry.geometry : featureOrGeometry;\n    let coords = geom.coordinates;\n    // standardise the input\n    if (geom.type === 'Polygon' || geom.type === 'MultiLineString') coords = [coords];\n    if (geom.type === 'LineString') coords = [[coords]];\n\n    for (let i = 0; i < coords.length; i++) {\n        for (let ii = 0; ii < coords[i].length; ii++) {\n            let currentP = coords[i][ii][0];\n            let nextP = null;\n            ringId = ringId + 1;\n            for (let iii = 0; iii < coords[i][ii].length - 1; iii++) {\n                nextP = coords[i][ii][iii + 1];\n\n                const e1 = new Event(currentP, featureId, ringId, eventId);\n                const e2 = new Event(nextP, featureId, ringId, eventId + 1);\n\n                e1.otherEvent = e2;\n                e2.otherEvent = e1;\n\n                if (checkWhichEventIsLeft(e1, e2) > 0) {\n                    e2.isLeftEndpoint = true;\n                    e1.isLeftEndpoint = false;\n                } else {\n                    e1.isLeftEndpoint = true;\n                    e2.isLeftEndpoint = false;\n                }\n                eventQueue.push(e1);\n                eventQueue.push(e2);\n\n                currentP = nextP;\n                eventId = eventId + 1;\n            }\n        }\n    }\n    featureId = featureId + 1;\n}\n\nclass Segment {\n\n    constructor (event) {\n        this.leftSweepEvent = event;\n        this.rightSweepEvent = event.otherEvent;\n    }\n}\n\nfunction testSegmentIntersect (seg1, seg2) {\n    if (seg1 === null || seg2 === null) return false\n\n    if (seg1.leftSweepEvent.ringId === seg2.leftSweepEvent.ringId &&\n        (seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) ||\n        seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) ||\n        seg1.rightSweepEvent.isSamePoint(seg2.rightSweepEvent) ||\n        seg1.leftSweepEvent.isSamePoint(seg2.leftSweepEvent) ||\n        seg1.leftSweepEvent.isSamePoint(seg2.rightSweepEvent))) return false\n\n    const x1 = seg1.leftSweepEvent.p.x;\n    const y1 = seg1.leftSweepEvent.p.y;\n    const x2 = seg1.rightSweepEvent.p.x;\n    const y2 = seg1.rightSweepEvent.p.y;\n    const x3 = seg2.leftSweepEvent.p.x;\n    const y3 = seg2.leftSweepEvent.p.y;\n    const x4 = seg2.rightSweepEvent.p.x;\n    const y4 = seg2.rightSweepEvent.p.y;\n\n    const denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n    const numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n    const numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) return false\n        return false\n    }\n\n    const uA = numeA / denom;\n    const uB = numeB / denom;\n\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        const x = x1 + (uA * (x2 - x1));\n        const y = y1 + (uA * (y2 - y1));\n        return [x, y]\n    }\n    return false\n}\n\n// import {debugEventAndSegments, debugRemovingSegment} from './debug'\n\nfunction runCheck (eventQueue, ignoreSelfIntersections) {\n    ignoreSelfIntersections = ignoreSelfIntersections ? ignoreSelfIntersections : false;\n\n    const intersectionPoints = [];\n    const outQueue = new TinyQueue([], checkWhichSegmentHasRightEndpointFirst);\n\n    while (eventQueue.length) {\n        const event = eventQueue.pop();\n        if (event.isLeftEndpoint) {\n            // debugEventAndSegments(event.p, outQueue.data)\n            const segment = new Segment(event);\n            for (let i = 0; i < outQueue.data.length; i++) {\n                const otherSeg = outQueue.data[i];\n                if (ignoreSelfIntersections) {\n                    if (otherSeg.leftSweepEvent.featureId === event.featureId) continue\n                }\n                const intersection = testSegmentIntersect(segment, otherSeg);\n                if (intersection !== false) intersectionPoints.push(intersection);\n            }\n            outQueue.push(segment);\n        } else if (event.isLeftEndpoint === false) {\n            outQueue.pop();\n            // const seg = outQueue.pop()\n            // debugRemovingSegment(event.p, seg)\n        }\n    }\n    return intersectionPoints\n}\n\nfunction sweeplineIntersections (geojson, ignoreSelfIntersections) {\n    const eventQueue = new TinyQueue([], checkWhichEventIsLeft);\n    fillEventQueue(geojson, eventQueue);\n    return runCheck(eventQueue, ignoreSelfIntersections)\n}\n\nexport default sweeplineIntersections;\n","// index.ts\nimport { feature, featureCollection, point } from \"@turf/helpers\";\n\n// lib/sweepline-intersections-export.ts\nimport lib from \"sweepline-intersections\";\nvar sweeplineIntersections = lib;\n\n// index.ts\nfunction lineIntersect(line1, line2, options = {}) {\n  const { removeDuplicates = true, ignoreSelfIntersections = true } = options;\n  let features = [];\n  if (line1.type === \"FeatureCollection\")\n    features = features.concat(line1.features);\n  else if (line1.type === \"Feature\") features.push(line1);\n  else if (line1.type === \"LineString\" || line1.type === \"Polygon\" || line1.type === \"MultiLineString\" || line1.type === \"MultiPolygon\") {\n    features.push(feature(line1));\n  }\n  if (line2.type === \"FeatureCollection\")\n    features = features.concat(line2.features);\n  else if (line2.type === \"Feature\") features.push(line2);\n  else if (line2.type === \"LineString\" || line2.type === \"Polygon\" || line2.type === \"MultiLineString\" || line2.type === \"MultiPolygon\") {\n    features.push(feature(line2));\n  }\n  const intersections = sweeplineIntersections(\n    featureCollection(features),\n    ignoreSelfIntersections\n  );\n  let results = [];\n  if (removeDuplicates) {\n    const unique = {};\n    intersections.forEach((intersection) => {\n      const key = intersection.join(\",\");\n      if (!unique[key]) {\n        unique[key] = true;\n        results.push(intersection);\n      }\n    });\n  } else {\n    results = intersections;\n  }\n  return featureCollection(results.map((r) => point(r)));\n}\nvar turf_line_intersect_default = lineIntersect;\nexport {\n  turf_line_intersect_default as default,\n  lineIntersect\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { isNumber } from \"@turf/helpers\";\nfunction getCoord(coord) {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n  if (!Array.isArray(coord)) {\n    if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\n      return [...coord.geometry.coordinates];\n    }\n    if (coord.type === \"Point\") {\n      return [...coord.coordinates];\n    }\n  }\n  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\n    return [...coord];\n  }\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\nfunction getCoords(coords) {\n  if (Array.isArray(coords)) {\n    return coords;\n  }\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n  throw new Error(\n    \"coords must be GeoJSON Feature, Geometry Object or an Array\"\n  );\n}\nfunction containsNumber(coordinates) {\n  if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n    return true;\n  }\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n  throw new Error(\"coordinates must only contain numbers\");\n}\nfunction geojsonType(value, type, name) {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n  if (!value || value.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type\n    );\n  }\n}\nfunction featureOf(feature, type, name) {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\n      \"Invalid input to \" + name + \", Feature with geometry required\"\n    );\n  }\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n    );\n  }\n}\nfunction collectionOf(featureCollection, type, name) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\n      \"Invalid input to \" + name + \", FeatureCollection required\"\n    );\n  }\n  for (const feature of featureCollection.features) {\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\n        \"Invalid input to \" + name + \", Feature with geometry required\"\n      );\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\n        \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n      );\n    }\n  }\n}\nfunction getGeom(geojson) {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n  return geojson;\n}\nfunction getType(geojson, _name) {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n  return geojson.type;\n}\nexport {\n  collectionOf,\n  containsNumber,\n  featureOf,\n  geojsonType,\n  getCoord,\n  getCoords,\n  getGeom,\n  getType\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport pip from \"point-in-polygon-hao\";\nimport { getCoord, getGeom } from \"@turf/invariant\";\nfunction booleanPointInPolygon(point, polygon, options = {}) {\n  if (!point) {\n    throw new Error(\"point is required\");\n  }\n  if (!polygon) {\n    throw new Error(\"polygon is required\");\n  }\n  const pt = getCoord(point);\n  const geom = getGeom(polygon);\n  const type = geom.type;\n  const bbox = polygon.bbox;\n  let polys = geom.coordinates;\n  if (bbox && inBBox(pt, bbox) === false) {\n    return false;\n  }\n  if (type === \"Polygon\") {\n    polys = [polys];\n  }\n  let result = false;\n  for (var i = 0; i < polys.length; ++i) {\n    const polyResult = pip(pt, polys[i]);\n    if (polyResult === 0) return options.ignoreBoundary ? false : true;\n    else if (polyResult) result = true;\n  }\n  return result;\n}\nfunction inBBox(pt, bbox) {\n  return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];\n}\nvar turf_boolean_point_in_polygon_default = booleanPointInPolygon;\nexport {\n  booleanPointInPolygon,\n  turf_boolean_point_in_polygon_default as default\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { feature, point, lineString, isObject } from \"@turf/helpers\";\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  if (geojson === null) return;\n  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === \"FeatureCollection\", isFeature = type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(\n            coords,\n            coordIndex,\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(\n              coords[j],\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false)\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(\n                coords[j][k],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false)\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(\n                  coords[j][k][l],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false)\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (coordIndex === 0 && initialValue === void 0)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function(currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function(currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function(coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\nfunction geomEach(geojson, callback) {\n  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === \"FeatureCollection\", isFeature = geojson.type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      if (geometry === null) {\n        if (callback(\n          null,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        ) === false)\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (callback(\n            geometry,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false)\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (callback(\n              geometry.geometries[j],\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false)\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    featureIndex++;\n  }\n}\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(\n          feature(geometry, properties, { bbox, id }),\n          featureIndex,\n          0\n        ) === false)\n          return false;\n        return;\n    }\n    var geomType;\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)\n        return false;\n    }\n  });\n}\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function(currentFeature, featureIndex, multiFeatureIndex) {\n      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n    if (!feature2.geometry) return;\n    var type = feature2.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(\n      feature2,\n      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n          previousCoords = currentCoord;\n          previousFeatureIndex = featureIndex;\n          previousMultiIndex = multiPartIndexCoord;\n          prevGeomIndex = geometryIndex;\n          segmentIndex = 0;\n          return;\n        }\n        var currentSegment = lineString(\n          [previousCoords, currentCoord],\n          feature2.properties\n        );\n        if (callback(\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        ) === false)\n          return false;\n        segmentIndex++;\n        previousCoords = currentCoord;\n      }\n    ) === false)\n      return false;\n  });\n}\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n      if (started === false && initialValue === void 0)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\nfunction lineEach(geojson, callback) {\n  if (!geojson) throw new Error(\"geojson is required\");\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    if (feature2.geometry === null) return;\n    var type = feature2.geometry.type;\n    var coords = feature2.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(\n            lineString(coords[geometryIndex], feature2.properties),\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n        }\n        break;\n    }\n  });\n}\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction findSegment(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nfunction findPoint(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nexport {\n  coordAll,\n  coordEach,\n  coordReduce,\n  featureEach,\n  featureReduce,\n  findPoint,\n  findSegment,\n  flattenEach,\n  flattenReduce,\n  geomEach,\n  geomReduce,\n  lineEach,\n  lineReduce,\n  propEach,\n  propReduce,\n  segmentEach,\n  segmentReduce\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { featureCollection, lineString, multiLineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\nfunction polygonToLine(poly, options = {}) {\n  const geom = getGeom(poly);\n  if (!options.properties && poly.type === \"Feature\") {\n    options.properties = poly.properties;\n  }\n  switch (geom.type) {\n    case \"Polygon\":\n      return singlePolygonToLine(geom, options);\n    case \"MultiPolygon\":\n      return multiPolygonToLine(geom, options);\n    default:\n      throw new Error(\"invalid poly\");\n  }\n}\nfunction singlePolygonToLine(poly, options = {}) {\n  const geom = getGeom(poly);\n  const coords = geom.coordinates;\n  const properties = options.properties ? options.properties : poly.type === \"Feature\" ? poly.properties : {};\n  return coordsToLine(coords, properties);\n}\nfunction multiPolygonToLine(multiPoly, options = {}) {\n  const geom = getGeom(multiPoly);\n  const coords = geom.coordinates;\n  const properties = options.properties ? options.properties : multiPoly.type === \"Feature\" ? multiPoly.properties : {};\n  const lines = [];\n  coords.forEach((coord) => {\n    lines.push(coordsToLine(coord, properties));\n  });\n  return featureCollection(lines);\n}\nfunction coordsToLine(coords, properties) {\n  if (coords.length > 1) {\n    return multiLineString(coords, properties);\n  }\n  return lineString(coords[0], properties);\n}\nvar turf_polygon_to_line_default = polygonToLine;\nexport {\n  coordsToLine,\n  turf_polygon_to_line_default as default,\n  multiPolygonToLine,\n  polygonToLine,\n  singlePolygonToLine\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { lineIntersect } from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { polygonToLine } from \"@turf/polygon-to-line\";\nfunction booleanDisjoint(feature1, feature2, {\n  ignoreSelfIntersections = true\n} = { ignoreSelfIntersections: true }) {\n  let bool = true;\n  flattenEach(feature1, (flatten1) => {\n    flattenEach(feature2, (flatten2) => {\n      if (bool === false) {\n        return false;\n      }\n      bool = disjoint(\n        flatten1.geometry,\n        flatten2.geometry,\n        ignoreSelfIntersections\n      );\n    });\n  });\n  return bool;\n}\nfunction disjoint(geom1, geom2, ignoreSelfIntersections) {\n  switch (geom1.type) {\n    case \"Point\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !compareCoords(geom1.coordinates, geom2.coordinates);\n        case \"LineString\":\n          return !isPointOnLine(geom2, geom1);\n        case \"Polygon\":\n          return !booleanPointInPolygon(geom1, geom2);\n      }\n      break;\n    case \"LineString\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !isPointOnLine(geom1, geom2);\n        case \"LineString\":\n          return !isLineOnLine(geom1, geom2, ignoreSelfIntersections);\n        case \"Polygon\":\n          return !isLineInPoly(geom2, geom1, ignoreSelfIntersections);\n      }\n      break;\n    case \"Polygon\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !booleanPointInPolygon(geom2, geom1);\n        case \"LineString\":\n          return !isLineInPoly(geom1, geom2, ignoreSelfIntersections);\n        case \"Polygon\":\n          return !isPolyInPoly(geom2, geom1, ignoreSelfIntersections);\n      }\n  }\n  return false;\n}\nfunction isPointOnLine(lineString, pt) {\n  for (let i = 0; i < lineString.coordinates.length - 1; i++) {\n    if (isPointOnLineSegment(\n      lineString.coordinates[i],\n      lineString.coordinates[i + 1],\n      pt.coordinates\n    )) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isLineOnLine(lineString1, lineString2, ignoreSelfIntersections) {\n  const doLinesIntersect = lineIntersect(lineString1, lineString2, {\n    ignoreSelfIntersections\n  });\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\nfunction isLineInPoly(polygon, lineString, ignoreSelfIntersections) {\n  for (const coord of lineString.coordinates) {\n    if (booleanPointInPolygon(coord, polygon)) {\n      return true;\n    }\n  }\n  const doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon), {\n    ignoreSelfIntersections\n  });\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\nfunction isPolyInPoly(feature1, feature2, ignoreSelfIntersections) {\n  for (const coord1 of feature1.coordinates[0]) {\n    if (booleanPointInPolygon(coord1, feature2)) {\n      return true;\n    }\n  }\n  for (const coord2 of feature2.coordinates[0]) {\n    if (booleanPointInPolygon(coord2, feature1)) {\n      return true;\n    }\n  }\n  const doLinesIntersect = lineIntersect(\n    polygonToLine(feature1),\n    polygonToLine(feature2),\n    { ignoreSelfIntersections }\n  );\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {\n  const dxc = pt[0] - lineSegmentStart[0];\n  const dyc = pt[1] - lineSegmentStart[1];\n  const dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n  const dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n  const cross = dxc * dyl - dyc * dxl;\n  if (cross !== 0) {\n    return false;\n  }\n  if (Math.abs(dxl) >= Math.abs(dyl)) {\n    if (dxl > 0) {\n      return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];\n    } else {\n      return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n    }\n  } else if (dyl > 0) {\n    return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];\n  } else {\n    return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n  }\n}\nfunction compareCoords(pair1, pair2) {\n  return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nvar turf_boolean_disjoint_default = booleanDisjoint;\nexport {\n  booleanDisjoint,\n  turf_boolean_disjoint_default as default\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { feature, point, lineString, isObject } from \"@turf/helpers\";\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  if (geojson === null) return;\n  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === \"FeatureCollection\", isFeature = type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(\n            coords,\n            coordIndex,\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(\n              coords[j],\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false)\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(\n                coords[j][k],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false)\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(\n                  coords[j][k][l],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false)\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (coordIndex === 0 && initialValue === void 0)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function(currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function(currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function(coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\nfunction geomEach(geojson, callback) {\n  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === \"FeatureCollection\", isFeature = geojson.type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      if (geometry === null) {\n        if (callback(\n          null,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        ) === false)\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (callback(\n            geometry,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false)\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (callback(\n              geometry.geometries[j],\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false)\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    featureIndex++;\n  }\n}\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(\n          feature(geometry, properties, { bbox, id }),\n          featureIndex,\n          0\n        ) === false)\n          return false;\n        return;\n    }\n    var geomType;\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)\n        return false;\n    }\n  });\n}\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function(currentFeature, featureIndex, multiFeatureIndex) {\n      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n    if (!feature2.geometry) return;\n    var type = feature2.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(\n      feature2,\n      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n          previousCoords = currentCoord;\n          previousFeatureIndex = featureIndex;\n          previousMultiIndex = multiPartIndexCoord;\n          prevGeomIndex = geometryIndex;\n          segmentIndex = 0;\n          return;\n        }\n        var currentSegment = lineString(\n          [previousCoords, currentCoord],\n          feature2.properties\n        );\n        if (callback(\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        ) === false)\n          return false;\n        segmentIndex++;\n        previousCoords = currentCoord;\n      }\n    ) === false)\n      return false;\n  });\n}\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n      if (started === false && initialValue === void 0)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\nfunction lineEach(geojson, callback) {\n  if (!geojson) throw new Error(\"geojson is required\");\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    if (feature2.geometry === null) return;\n    var type = feature2.geometry.type;\n    var coords = feature2.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(\n            lineString(coords[geometryIndex], feature2.properties),\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n        }\n        break;\n    }\n  });\n}\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction findSegment(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nfunction findPoint(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nexport {\n  coordAll,\n  coordEach,\n  coordReduce,\n  featureEach,\n  featureReduce,\n  findPoint,\n  findSegment,\n  flattenEach,\n  flattenReduce,\n  geomEach,\n  geomReduce,\n  lineEach,\n  lineReduce,\n  propEach,\n  propReduce,\n  segmentEach,\n  segmentReduce\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { flattenEach } from \"@turf/meta\";\nimport { getCoords, getType } from \"@turf/invariant\";\nimport {\n  isObject,\n  lineString,\n  multiLineString,\n  lengthToDegrees\n} from \"@turf/helpers\";\n\n// lib/intersection.js\nfunction ab(segment) {\n  var start = segment[0];\n  var end = segment[1];\n  return [end[0] - start[0], end[1] - start[1]];\n}\nfunction crossProduct(v1, v2) {\n  return v1[0] * v2[1] - v2[0] * v1[1];\n}\nfunction add(v1, v2) {\n  return [v1[0] + v2[0], v1[1] + v2[1]];\n}\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\nfunction scalarMult(s, v) {\n  return [s * v[0], s * v[1]];\n}\nfunction intersectSegments(a, b) {\n  var p = a[0];\n  var r = ab(a);\n  var q = b[0];\n  var s = ab(b);\n  var cross = crossProduct(r, s);\n  var qmp = sub(q, p);\n  var numerator = crossProduct(qmp, s);\n  var t = numerator / cross;\n  var intersection2 = add(p, scalarMult(t, r));\n  return intersection2;\n}\nfunction isParallel(a, b) {\n  var r = ab(a);\n  var s = ab(b);\n  return crossProduct(r, s) === 0;\n}\nfunction intersection(a, b) {\n  if (isParallel(a, b)) return false;\n  return intersectSegments(a, b);\n}\n\n// index.js\nfunction lineOffset(geojson, distance, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (distance === void 0 || distance === null || isNaN(distance))\n    throw new Error(\"distance is required\");\n  var type = getType(geojson);\n  var properties = geojson.properties;\n  switch (type) {\n    case \"LineString\":\n      return lineOffsetFeature(geojson, distance, units);\n    case \"MultiLineString\":\n      var coords = [];\n      flattenEach(geojson, function(feature) {\n        coords.push(\n          lineOffsetFeature(feature, distance, units).geometry.coordinates\n        );\n      });\n      return multiLineString(coords, properties);\n    default:\n      throw new Error(\"geometry \" + type + \" is not supported\");\n  }\n}\nfunction lineOffsetFeature(line, distance, units) {\n  var segments = [];\n  var offsetDegrees = lengthToDegrees(distance, units);\n  var coords = getCoords(line);\n  var finalCoords = [];\n  coords.forEach(function(currentCoords, index) {\n    if (index !== coords.length - 1) {\n      var segment = processSegment(\n        currentCoords,\n        coords[index + 1],\n        offsetDegrees\n      );\n      segments.push(segment);\n      if (index > 0) {\n        var seg2Coords = segments[index - 1];\n        var intersects = intersection(segment, seg2Coords);\n        if (intersects !== false) {\n          seg2Coords[1] = intersects;\n          segment[0] = intersects;\n        }\n        finalCoords.push(seg2Coords[0]);\n        if (index === coords.length - 2) {\n          finalCoords.push(segment[0]);\n          finalCoords.push(segment[1]);\n        }\n      }\n      if (coords.length === 2) {\n        finalCoords.push(segment[0]);\n        finalCoords.push(segment[1]);\n      }\n    }\n  });\n  return lineString(finalCoords, line.properties);\n}\nfunction processSegment(point1, point2, offset) {\n  var L = Math.sqrt(\n    (point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1])\n  );\n  var out1x = point1[0] + offset * (point2[1] - point1[1]) / L;\n  var out2x = point2[0] + offset * (point2[1] - point1[1]) / L;\n  var out1y = point1[1] + offset * (point1[0] - point2[0]) / L;\n  var out2y = point2[1] + offset * (point1[0] - point2[0]) / L;\n  return [\n    [out1x, out1y],\n    [out2x, out2y]\n  ];\n}\nvar turf_line_offset_default = lineOffset;\nexport {\n  turf_line_offset_default as default,\n  lineOffset\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { isNumber } from \"@turf/helpers\";\nfunction getCoord(coord) {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n  if (!Array.isArray(coord)) {\n    if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\n      return [...coord.geometry.coordinates];\n    }\n    if (coord.type === \"Point\") {\n      return [...coord.coordinates];\n    }\n  }\n  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\n    return [...coord];\n  }\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\nfunction getCoords(coords) {\n  if (Array.isArray(coords)) {\n    return coords;\n  }\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n  throw new Error(\n    \"coords must be GeoJSON Feature, Geometry Object or an Array\"\n  );\n}\nfunction containsNumber(coordinates) {\n  if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n    return true;\n  }\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n  throw new Error(\"coordinates must only contain numbers\");\n}\nfunction geojsonType(value, type, name) {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n  if (!value || value.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type\n    );\n  }\n}\nfunction featureOf(feature, type, name) {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\n      \"Invalid input to \" + name + \", Feature with geometry required\"\n    );\n  }\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n    );\n  }\n}\nfunction collectionOf(featureCollection, type, name) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\n      \"Invalid input to \" + name + \", FeatureCollection required\"\n    );\n  }\n  for (const feature of featureCollection.features) {\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\n        \"Invalid input to \" + name + \", Feature with geometry required\"\n      );\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\n        \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n      );\n    }\n  }\n}\nfunction getGeom(geojson) {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n  return geojson;\n}\nfunction getType(geojson, _name) {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n  return geojson.type;\n}\nexport {\n  collectionOf,\n  containsNumber,\n  featureOf,\n  geojsonType,\n  getCoord,\n  getCoords,\n  getGeom,\n  getType\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { feature, point, lineString, isObject } from \"@turf/helpers\";\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  if (geojson === null) return;\n  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === \"FeatureCollection\", isFeature = type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(\n            coords,\n            coordIndex,\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(\n              coords[j],\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false)\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(\n                coords[j][k],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false)\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(\n                  coords[j][k][l],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false)\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (coordIndex === 0 && initialValue === void 0)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function(currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function(currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function(coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\nfunction geomEach(geojson, callback) {\n  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === \"FeatureCollection\", isFeature = geojson.type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      if (geometry === null) {\n        if (callback(\n          null,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        ) === false)\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (callback(\n            geometry,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false)\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (callback(\n              geometry.geometries[j],\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false)\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    featureIndex++;\n  }\n}\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(\n          feature(geometry, properties, { bbox, id }),\n          featureIndex,\n          0\n        ) === false)\n          return false;\n        return;\n    }\n    var geomType;\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)\n        return false;\n    }\n  });\n}\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function(currentFeature, featureIndex, multiFeatureIndex) {\n      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n    if (!feature2.geometry) return;\n    var type = feature2.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(\n      feature2,\n      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n          previousCoords = currentCoord;\n          previousFeatureIndex = featureIndex;\n          previousMultiIndex = multiPartIndexCoord;\n          prevGeomIndex = geometryIndex;\n          segmentIndex = 0;\n          return;\n        }\n        var currentSegment = lineString(\n          [previousCoords, currentCoord],\n          feature2.properties\n        );\n        if (callback(\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        ) === false)\n          return false;\n        segmentIndex++;\n        previousCoords = currentCoord;\n      }\n    ) === false)\n      return false;\n  });\n}\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n      if (started === false && initialValue === void 0)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\nfunction lineEach(geojson, callback) {\n  if (!geojson) throw new Error(\"geojson is required\");\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    if (feature2.geometry === null) return;\n    var type = feature2.geometry.type;\n    var coords = feature2.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(\n            lineString(coords[geometryIndex], feature2.properties),\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n        }\n        break;\n    }\n  });\n}\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction findSegment(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nfunction findPoint(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nexport {\n  coordAll,\n  coordEach,\n  coordReduce,\n  featureEach,\n  featureReduce,\n  findPoint,\n  findSegment,\n  flattenEach,\n  flattenReduce,\n  geomEach,\n  geomReduce,\n  lineEach,\n  lineReduce,\n  propEach,\n  propReduce,\n  segmentEach,\n  segmentReduce\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { coordEach } from \"@turf/meta\";\nfunction bbox(geojson, options = {}) {\n  if (geojson.bbox != null && true !== options.recompute) {\n    return geojson.bbox;\n  }\n  const result = [Infinity, Infinity, -Infinity, -Infinity];\n  coordEach(geojson, (coord) => {\n    if (result[0] > coord[0]) {\n      result[0] = coord[0];\n    }\n    if (result[1] > coord[1]) {\n      result[1] = coord[1];\n    }\n    if (result[2] < coord[0]) {\n      result[2] = coord[0];\n    }\n    if (result[3] < coord[1]) {\n      result[3] = coord[1];\n    }\n  });\n  return result;\n}\nvar turf_bbox_default = bbox;\nexport {\n  bbox,\n  turf_bbox_default as default\n};\n//# sourceMappingURL=index.js.map","// index.ts\nfunction clone(geojson) {\n  if (!geojson) {\n    throw new Error(\"geojson is required\");\n  }\n  switch (geojson.type) {\n    case \"Feature\":\n      return cloneFeature(geojson);\n    case \"FeatureCollection\":\n      return cloneFeatureCollection(geojson);\n    case \"Point\":\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiPoint\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n    case \"GeometryCollection\":\n      return cloneGeometry(geojson);\n    default:\n      throw new Error(\"unknown GeoJSON type\");\n  }\n}\nfunction cloneFeature(geojson) {\n  const cloned = { type: \"Feature\" };\n  Object.keys(geojson).forEach((key) => {\n    switch (key) {\n      case \"type\":\n      case \"properties\":\n      case \"geometry\":\n        return;\n      default:\n        cloned[key] = geojson[key];\n    }\n  });\n  cloned.properties = cloneProperties(geojson.properties);\n  if (geojson.geometry == null) {\n    cloned.geometry = null;\n  } else {\n    cloned.geometry = cloneGeometry(geojson.geometry);\n  }\n  return cloned;\n}\nfunction cloneProperties(properties) {\n  const cloned = {};\n  if (!properties) {\n    return cloned;\n  }\n  Object.keys(properties).forEach((key) => {\n    const value = properties[key];\n    if (typeof value === \"object\") {\n      if (value === null) {\n        cloned[key] = null;\n      } else if (Array.isArray(value)) {\n        cloned[key] = value.map((item) => {\n          return item;\n        });\n      } else {\n        cloned[key] = cloneProperties(value);\n      }\n    } else {\n      cloned[key] = value;\n    }\n  });\n  return cloned;\n}\nfunction cloneFeatureCollection(geojson) {\n  const cloned = { type: \"FeatureCollection\" };\n  Object.keys(geojson).forEach((key) => {\n    switch (key) {\n      case \"type\":\n      case \"features\":\n        return;\n      default:\n        cloned[key] = geojson[key];\n    }\n  });\n  cloned.features = geojson.features.map((feature) => {\n    return cloneFeature(feature);\n  });\n  return cloned;\n}\nfunction cloneGeometry(geometry) {\n  const geom = { type: geometry.type };\n  if (geometry.bbox) {\n    geom.bbox = geometry.bbox;\n  }\n  if (geometry.type === \"GeometryCollection\") {\n    geom.geometries = geometry.geometries.map((g) => {\n      return cloneGeometry(g);\n    });\n    return geom;\n  }\n  geom.coordinates = deepSlice(geometry.coordinates);\n  return geom;\n}\nfunction deepSlice(coords) {\n  const cloned = coords;\n  if (typeof cloned[0] !== \"object\") {\n    return cloned.slice();\n  }\n  return cloned.map((coord) => {\n    return deepSlice(coord);\n  });\n}\nvar turf_clone_default = clone;\nexport {\n  clone,\n  cloneProperties,\n  turf_clone_default as default\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { bbox as turfBBox } from \"@turf/bbox\";\nimport { getCoords, getGeom } from \"@turf/invariant\";\nimport { polygon, multiPolygon, lineString } from \"@turf/helpers\";\nimport { clone } from \"@turf/clone\";\nfunction lineToPolygon(lines, options = {}) {\n  var _a, _b, _c;\n  var properties = options.properties;\n  var autoComplete = (_a = options.autoComplete) != null ? _a : true;\n  var orderCoords = (_b = options.orderCoords) != null ? _b : true;\n  var mutate = (_c = options.mutate) != null ? _c : false;\n  if (!mutate) {\n    lines = clone(lines);\n  }\n  switch (lines.type) {\n    case \"FeatureCollection\":\n      var coords = [];\n      lines.features.forEach(function(line) {\n        coords.push(\n          getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords))\n        );\n      });\n      return multiPolygon(coords, properties);\n    default:\n      return lineStringToPolygon(lines, properties, autoComplete, orderCoords);\n  }\n}\nfunction lineStringToPolygon(line, properties, autoComplete, orderCoords) {\n  properties = properties ? properties : line.type === \"Feature\" ? line.properties : {};\n  var geom = getGeom(line);\n  var coords = geom.coordinates;\n  var type = geom.type;\n  if (!coords.length) throw new Error(\"line must contain coordinates\");\n  switch (type) {\n    case \"LineString\":\n      if (autoComplete) coords = autoCompleteCoords(coords);\n      return polygon([coords], properties);\n    case \"MultiLineString\":\n      var multiCoords = [];\n      var largestArea = 0;\n      coords.forEach(function(coord) {\n        if (autoComplete) coord = autoCompleteCoords(coord);\n        if (orderCoords) {\n          var area = calculateArea(turfBBox(lineString(coord)));\n          if (area > largestArea) {\n            multiCoords.unshift(coord);\n            largestArea = area;\n          } else multiCoords.push(coord);\n        } else {\n          multiCoords.push(coord);\n        }\n      });\n      return polygon(multiCoords, properties);\n    default:\n      throw new Error(\"geometry type \" + type + \" is not supported\");\n  }\n}\nfunction autoCompleteCoords(coords) {\n  var first = coords[0];\n  var x1 = first[0];\n  var y1 = first[1];\n  var last = coords[coords.length - 1];\n  var x2 = last[0];\n  var y2 = last[1];\n  if (x1 !== x2 || y1 !== y2) {\n    coords.push(first);\n  }\n  return coords;\n}\nfunction calculateArea(bbox) {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  return Math.abs(west - east) * Math.abs(south - north);\n}\nvar turf_line_to_polygon_default = lineToPolygon;\nexport {\n  turf_line_to_polygon_default as default,\n  lineToPolygon\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { isNumber } from \"@turf/helpers\";\nfunction getCoord(coord) {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n  if (!Array.isArray(coord)) {\n    if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\n      return [...coord.geometry.coordinates];\n    }\n    if (coord.type === \"Point\") {\n      return [...coord.coordinates];\n    }\n  }\n  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\n    return [...coord];\n  }\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\nfunction getCoords(coords) {\n  if (Array.isArray(coords)) {\n    return coords;\n  }\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n  throw new Error(\n    \"coords must be GeoJSON Feature, Geometry Object or an Array\"\n  );\n}\nfunction containsNumber(coordinates) {\n  if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n    return true;\n  }\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n  throw new Error(\"coordinates must only contain numbers\");\n}\nfunction geojsonType(value, type, name) {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n  if (!value || value.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type\n    );\n  }\n}\nfunction featureOf(feature, type, name) {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\n      \"Invalid input to \" + name + \", Feature with geometry required\"\n    );\n  }\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n    );\n  }\n}\nfunction collectionOf(featureCollection, type, name) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\n      \"Invalid input to \" + name + \", FeatureCollection required\"\n    );\n  }\n  for (const feature of featureCollection.features) {\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\n        \"Invalid input to \" + name + \", Feature with geometry required\"\n      );\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\n        \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n      );\n    }\n  }\n}\nfunction getGeom(geojson) {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n  return geojson;\n}\nfunction getType(geojson, _name) {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n  return geojson.type;\n}\nexport {\n  collectionOf,\n  containsNumber,\n  featureOf,\n  geojsonType,\n  getCoord,\n  getCoords,\n  getGeom,\n  getType\n};\n//# sourceMappingURL=index.js.map","/*\r\n *      bignumber.js v9.3.0\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\nvar\r\n  isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n  mathceil = Math.ceil,\r\n  mathfloor = Math.floor,\r\n\r\n  bignumberError = '[BigNumber Error] ',\r\n  tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n  BASE = 1e14,\r\n  LOG_BASE = 14,\r\n  MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n  // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n  POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n  SQRT_BASE = 1e7,\r\n\r\n  // EDITABLE\r\n  // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n  // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n  MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n/*\r\n * Create and return a BigNumber constructor.\r\n */\r\nfunction clone(configObject) {\r\n  var div, convertBase, parseNumeric,\r\n    P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n    ONE = new BigNumber(1),\r\n\r\n\r\n    //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n    // The default values below must be integers within the inclusive ranges stated.\r\n    // The values can also be changed at run-time using BigNumber.set.\r\n\r\n    // The maximum number of decimal places for operations involving division.\r\n    DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n    // The rounding mode used when rounding to the above decimal places, and when using\r\n    // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n    // UP         0 Away from zero.\r\n    // DOWN       1 Towards zero.\r\n    // CEIL       2 Towards +Infinity.\r\n    // FLOOR      3 Towards -Infinity.\r\n    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n    ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n    // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n    // The exponent value at and beneath which toString returns exponential notation.\r\n    // Number type: -7\r\n    TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n    // The exponent value at and above which toString returns exponential notation.\r\n    // Number type: 21\r\n    TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n    // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n    // The minimum exponent value, beneath which underflow to zero occurs.\r\n    // Number type: -324  (5e-324)\r\n    MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n    // The maximum exponent value, above which overflow to Infinity occurs.\r\n    // Number type:  308  (1.7976931348623157e+308)\r\n    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n    MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n    // Whether to use cryptographically-secure random number generation, if available.\r\n    CRYPTO = false,                          // true or false\r\n\r\n    // The modulo mode used when calculating the modulus: a mod n.\r\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n    // The remainder (r) is calculated as: r = a - n * q.\r\n    //\r\n    // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n    // DOWN      1 The remainder has the same sign as the dividend.\r\n    //             This modulo mode is commonly known as 'truncated division' and is\r\n    //             equivalent to (a % n) in JavaScript.\r\n    // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n    //             The remainder is always positive.\r\n    //\r\n    // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n    // modes are commonly used for the modulus operation.\r\n    // Although the other rounding modes can also be used, they may not give useful results.\r\n    MODULO_MODE = 1,                         // 0 to 9\r\n\r\n    // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n    // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n    POW_PRECISION = 0,                       // 0 to MAX\r\n\r\n    // The format specification used by the BigNumber.prototype.toFormat method.\r\n    FORMAT = {\r\n      prefix: '',\r\n      groupSize: 3,\r\n      secondaryGroupSize: 0,\r\n      groupSeparator: ',',\r\n      decimalSeparator: '.',\r\n      fractionGroupSize: 0,\r\n      fractionGroupSeparator: '\\xA0',        // non-breaking space\r\n      suffix: ''\r\n    },\r\n\r\n    // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n    // '-', '.', whitespace, or repeated character.\r\n    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n    ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',\r\n    alphabetHasNormalDecimalDigits = true;\r\n\r\n\r\n  //------------------------------------------------------------------------------------------\r\n\r\n\r\n  // CONSTRUCTOR\r\n\r\n\r\n  /*\r\n   * The BigNumber constructor and exported function.\r\n   * Create and return a new instance of a BigNumber object.\r\n   *\r\n   * v {number|string|BigNumber} A numeric value.\r\n   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n   */\r\n  function BigNumber(v, b) {\r\n    var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n      x = this;\r\n\r\n    // Enable constructor call without `new`.\r\n    if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n    if (b == null) {\r\n\r\n      if (v && v._isBigNumber === true) {\r\n        x.s = v.s;\r\n\r\n        if (!v.c || v.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n        } else if (v.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = v.e;\r\n          x.c = v.c.slice();\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n        // Use `1 / n` to handle minus zero also.\r\n        x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n        // Fast path for integers, where n < 2147483648 (2**31).\r\n        if (v === ~~v) {\r\n          for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n          if (e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else {\r\n            x.e = e;\r\n            x.c = [v];\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        str = String(v);\r\n      } else {\r\n\r\n        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n      }\r\n\r\n      // Decimal point?\r\n      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n      // Exponential form?\r\n      if ((i = str.search(/e/i)) > 0) {\r\n\r\n        // Determine exponent.\r\n        if (e < 0) e = i;\r\n        e += +str.slice(i + 1);\r\n        str = str.substring(0, i);\r\n      } else if (e < 0) {\r\n\r\n        // Integer.\r\n        e = str.length;\r\n      }\r\n\r\n    } else {\r\n\r\n      // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n      intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n      // Allow exponential notation to be used with base 10 argument, while\r\n      // also rounding to DECIMAL_PLACES as with other bases.\r\n      if (b == 10 && alphabetHasNormalDecimalDigits) {\r\n        x = new BigNumber(v);\r\n        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n      }\r\n\r\n      str = String(v);\r\n\r\n      if (isNum = typeof v == 'number') {\r\n\r\n        // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n          throw Error\r\n           (tooManyDigits + v);\r\n        }\r\n      } else {\r\n        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n      }\r\n\r\n      alphabet = ALPHABET.slice(0, b);\r\n      e = i = 0;\r\n\r\n      // Check that str is a valid base b number.\r\n      // Don't use RegExp, so alphabet can contain special characters.\r\n      for (len = str.length; i < len; i++) {\r\n        if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n          if (c == '.') {\r\n\r\n            // If '.' is not the first character and it has not be found before.\r\n            if (i > e) {\r\n              e = len;\r\n              continue;\r\n            }\r\n          } else if (!caseChanged) {\r\n\r\n            // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n            if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n              caseChanged = true;\r\n              i = -1;\r\n              e = 0;\r\n              continue;\r\n            }\r\n          }\r\n\r\n          return parseNumeric(x, String(v), isNum, b);\r\n        }\r\n      }\r\n\r\n      // Prevent later check for length on converted number.\r\n      isNum = false;\r\n      str = convertBase(str, b, 10, x.s);\r\n\r\n      // Decimal point?\r\n      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n      else e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n    if (str = str.slice(i, ++len)) {\r\n      len -= i;\r\n\r\n      // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n      if (isNum && BigNumber.DEBUG &&\r\n        len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n          throw Error\r\n           (tooManyDigits + (x.s * v));\r\n      }\r\n\r\n       // Overflow?\r\n      if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        x.c = x.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      } else {\r\n        x.e = e;\r\n        x.c = [];\r\n\r\n        // Transform base\r\n\r\n        // e is the base 10 exponent.\r\n        // i is where to slice str to get the first element of the coefficient array.\r\n        i = (e + 1) % LOG_BASE;\r\n        if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n        if (i < len) {\r\n          if (i) x.c.push(+str.slice(0, i));\r\n\r\n          for (len -= LOG_BASE; i < len;) {\r\n            x.c.push(+str.slice(i, i += LOG_BASE));\r\n          }\r\n\r\n          i = LOG_BASE - (str = str.slice(i)).length;\r\n        } else {\r\n          i -= len;\r\n        }\r\n\r\n        for (; i--; str += '0');\r\n        x.c.push(+str);\r\n      }\r\n    } else {\r\n\r\n      // Zero.\r\n      x.c = [x.e = 0];\r\n    }\r\n  }\r\n\r\n\r\n  // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n  BigNumber.clone = clone;\r\n\r\n  BigNumber.ROUND_UP = 0;\r\n  BigNumber.ROUND_DOWN = 1;\r\n  BigNumber.ROUND_CEIL = 2;\r\n  BigNumber.ROUND_FLOOR = 3;\r\n  BigNumber.ROUND_HALF_UP = 4;\r\n  BigNumber.ROUND_HALF_DOWN = 5;\r\n  BigNumber.ROUND_HALF_EVEN = 6;\r\n  BigNumber.ROUND_HALF_CEIL = 7;\r\n  BigNumber.ROUND_HALF_FLOOR = 8;\r\n  BigNumber.EUCLID = 9;\r\n\r\n\r\n  /*\r\n   * Configure infrequently-changing library-wide settings.\r\n   *\r\n   * Accept an object with the following optional properties (if the value of a property is\r\n   * a number, it must be an integer within the inclusive range stated):\r\n   *\r\n   *   DECIMAL_PLACES   {number}           0 to MAX\r\n   *   ROUNDING_MODE    {number}           0 to 8\r\n   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n   *   CRYPTO           {boolean}          true or false\r\n   *   MODULO_MODE      {number}           0 to 9\r\n   *   POW_PRECISION       {number}           0 to MAX\r\n   *   ALPHABET         {string}           A string of two or more unique characters which does\r\n   *                                       not contain '.'.\r\n   *   FORMAT           {object}           An object with some of the following properties:\r\n   *     prefix                 {string}\r\n   *     groupSize              {number}\r\n   *     secondaryGroupSize     {number}\r\n   *     groupSeparator         {string}\r\n   *     decimalSeparator       {string}\r\n   *     fractionGroupSize      {number}\r\n   *     fractionGroupSeparator {string}\r\n   *     suffix                 {string}\r\n   *\r\n   * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n   *\r\n   * E.g.\r\n   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n   *\r\n   * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n   *\r\n   * Return an object with the properties current values.\r\n   */\r\n  BigNumber.config = BigNumber.set = function (obj) {\r\n    var p, v;\r\n\r\n    if (obj != null) {\r\n\r\n      if (typeof obj == 'object') {\r\n\r\n        // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n        // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, MAX, p);\r\n          DECIMAL_PLACES = v;\r\n        }\r\n\r\n        // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n        // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, 8, p);\r\n          ROUNDING_MODE = v;\r\n        }\r\n\r\n        // EXPONENTIAL_AT {number|number[]}\r\n        // Integer, -MAX to MAX inclusive or\r\n        // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n        // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n          v = obj[p];\r\n          if (v && v.pop) {\r\n            intCheck(v[0], -MAX, 0, p);\r\n            intCheck(v[1], 0, MAX, p);\r\n            TO_EXP_NEG = v[0];\r\n            TO_EXP_POS = v[1];\r\n          } else {\r\n            intCheck(v, -MAX, MAX, p);\r\n            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n          }\r\n        }\r\n\r\n        // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n        // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n        // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n        if (obj.hasOwnProperty(p = 'RANGE')) {\r\n          v = obj[p];\r\n          if (v && v.pop) {\r\n            intCheck(v[0], -MAX, -1, p);\r\n            intCheck(v[1], 1, MAX, p);\r\n            MIN_EXP = v[0];\r\n            MAX_EXP = v[1];\r\n          } else {\r\n            intCheck(v, -MAX, MAX, p);\r\n            if (v) {\r\n              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' cannot be zero: ' + v);\r\n            }\r\n          }\r\n        }\r\n\r\n        // CRYPTO {boolean} true or false.\r\n        // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n        // '[BigNumber Error] crypto unavailable'\r\n        if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n          v = obj[p];\r\n          if (v === !!v) {\r\n            if (v) {\r\n              if (typeof crypto != 'undefined' && crypto &&\r\n               (crypto.getRandomValues || crypto.randomBytes)) {\r\n                CRYPTO = v;\r\n              } else {\r\n                CRYPTO = !v;\r\n                throw Error\r\n                 (bignumberError + 'crypto unavailable');\r\n              }\r\n            } else {\r\n              CRYPTO = v;\r\n            }\r\n          } else {\r\n            throw Error\r\n             (bignumberError + p + ' not true or false: ' + v);\r\n          }\r\n        }\r\n\r\n        // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n        // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, 9, p);\r\n          MODULO_MODE = v;\r\n        }\r\n\r\n        // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n        // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, MAX, p);\r\n          POW_PRECISION = v;\r\n        }\r\n\r\n        // FORMAT {object}\r\n        // '[BigNumber Error] FORMAT not an object: {v}'\r\n        if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n          v = obj[p];\r\n          if (typeof v == 'object') FORMAT = v;\r\n          else throw Error\r\n           (bignumberError + p + ' not an object: ' + v);\r\n        }\r\n\r\n        // ALPHABET {string}\r\n        // '[BigNumber Error] ALPHABET invalid: {v}'\r\n        if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n          v = obj[p];\r\n\r\n          // Disallow if less than two characters,\r\n          // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n          if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n            alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';\r\n            ALPHABET = v;\r\n          } else {\r\n            throw Error\r\n             (bignumberError + p + ' invalid: ' + v);\r\n          }\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Object expected: {v}'\r\n        throw Error\r\n         (bignumberError + 'Object expected: ' + obj);\r\n      }\r\n    }\r\n\r\n    return {\r\n      DECIMAL_PLACES: DECIMAL_PLACES,\r\n      ROUNDING_MODE: ROUNDING_MODE,\r\n      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n      RANGE: [MIN_EXP, MAX_EXP],\r\n      CRYPTO: CRYPTO,\r\n      MODULO_MODE: MODULO_MODE,\r\n      POW_PRECISION: POW_PRECISION,\r\n      FORMAT: FORMAT,\r\n      ALPHABET: ALPHABET\r\n    };\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if v is a BigNumber instance, otherwise return false.\r\n   *\r\n   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n   *\r\n   * v {any}\r\n   *\r\n   * '[BigNumber Error] Invalid BigNumber: {v}'\r\n   */\r\n  BigNumber.isBigNumber = function (v) {\r\n    if (!v || v._isBigNumber !== true) return false;\r\n    if (!BigNumber.DEBUG) return true;\r\n\r\n    var i, n,\r\n      c = v.c,\r\n      e = v.e,\r\n      s = v.s;\r\n\r\n    out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n        // If the first element is zero, the BigNumber value must be zero.\r\n        if (c[0] === 0) {\r\n          if (e === 0 && c.length === 1) return true;\r\n          break out;\r\n        }\r\n\r\n        // Calculate number of digits that c[0] should have, based on the exponent.\r\n        i = (e + 1) % LOG_BASE;\r\n        if (i < 1) i += LOG_BASE;\r\n\r\n        // Calculate number of digits of c[0].\r\n        //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n        if (String(c[0]).length == i) {\r\n\r\n          for (i = 0; i < c.length; i++) {\r\n            n = c[i];\r\n            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n          }\r\n\r\n          // Last element cannot be zero, unless it is the only element.\r\n          if (n !== 0) return true;\r\n        }\r\n      }\r\n\r\n    // Infinity/NaN\r\n    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n      return true;\r\n    }\r\n\r\n    throw Error\r\n      (bignumberError + 'Invalid BigNumber: ' + v);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.maximum = BigNumber.max = function () {\r\n    return maxOrMin(arguments, -1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.minimum = BigNumber.min = function () {\r\n    return maxOrMin(arguments, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n   * zeros are produced).\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n   * '[BigNumber Error] crypto unavailable'\r\n   */\r\n  BigNumber.random = (function () {\r\n    var pow2_53 = 0x20000000000000;\r\n\r\n    // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n    // Check if Math.random() produces more than 32 bits of randomness.\r\n    // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n    // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n    var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n     ? function () { return mathfloor(Math.random() * pow2_53); }\r\n     : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n       (Math.random() * 0x800000 | 0); };\r\n\r\n    return function (dp) {\r\n      var a, b, e, k, v,\r\n        i = 0,\r\n        c = [],\r\n        rand = new BigNumber(ONE);\r\n\r\n      if (dp == null) dp = DECIMAL_PLACES;\r\n      else intCheck(dp, 0, MAX);\r\n\r\n      k = mathceil(dp / LOG_BASE);\r\n\r\n      if (CRYPTO) {\r\n\r\n        // Browsers supporting crypto.getRandomValues.\r\n        if (crypto.getRandomValues) {\r\n\r\n          a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n          for (; i < k;) {\r\n\r\n            // 53 bits:\r\n            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n            // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n            //                                     11111 11111111 11111111\r\n            // 0x20000 is 2^21.\r\n            v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n            // Rejection sampling:\r\n            // 0 <= v < 9007199254740992\r\n            // Probability that v >= 9e15, is\r\n            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n            if (v >= 9e15) {\r\n              b = crypto.getRandomValues(new Uint32Array(2));\r\n              a[i] = b[0];\r\n              a[i + 1] = b[1];\r\n            } else {\r\n\r\n              // 0 <= v <= 8999999999999999\r\n              // 0 <= (v % 1e14) <= 99999999999999\r\n              c.push(v % 1e14);\r\n              i += 2;\r\n            }\r\n          }\r\n          i = k / 2;\r\n\r\n        // Node.js supporting crypto.randomBytes.\r\n        } else if (crypto.randomBytes) {\r\n\r\n          // buffer\r\n          a = crypto.randomBytes(k *= 7);\r\n\r\n          for (; i < k;) {\r\n\r\n            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n            // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n            // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n            // 0 <= v < 9007199254740992\r\n            v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n               (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n               (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n            if (v >= 9e15) {\r\n              crypto.randomBytes(7).copy(a, i);\r\n            } else {\r\n\r\n              // 0 <= (v % 1e14) <= 99999999999999\r\n              c.push(v % 1e14);\r\n              i += 7;\r\n            }\r\n          }\r\n          i = k / 7;\r\n        } else {\r\n          CRYPTO = false;\r\n          throw Error\r\n           (bignumberError + 'crypto unavailable');\r\n        }\r\n      }\r\n\r\n      // Use Math.random.\r\n      if (!CRYPTO) {\r\n\r\n        for (; i < k;) {\r\n          v = random53bitInt();\r\n          if (v < 9e15) c[i++] = v % 1e14;\r\n        }\r\n      }\r\n\r\n      k = c[--i];\r\n      dp %= LOG_BASE;\r\n\r\n      // Convert trailing digits to zeros according to dp.\r\n      if (k && dp) {\r\n        v = POWS_TEN[LOG_BASE - dp];\r\n        c[i] = mathfloor(k / v) * v;\r\n      }\r\n\r\n      // Remove trailing elements which are zero.\r\n      for (; c[i] === 0; c.pop(), i--);\r\n\r\n      // Zero?\r\n      if (i < 0) {\r\n        c = [e = 0];\r\n      } else {\r\n\r\n        // Remove leading elements which are zero and adjust exponent accordingly.\r\n        for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n        // Count the digits of the first element of c to determine leading zeros, and...\r\n        for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n        // adjust the exponent accordingly.\r\n        if (i < LOG_BASE) e -= LOG_BASE - i;\r\n      }\r\n\r\n      rand.e = e;\r\n      rand.c = c;\r\n      return rand;\r\n    };\r\n  })();\r\n\r\n\r\n   /*\r\n   * Return a BigNumber whose value is the sum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.sum = function () {\r\n    var i = 1,\r\n      args = arguments,\r\n      sum = new BigNumber(args[0]);\r\n    for (; i < args.length;) sum = sum.plus(args[i++]);\r\n    return sum;\r\n  };\r\n\r\n\r\n  // PRIVATE FUNCTIONS\r\n\r\n\r\n  // Called by BigNumber and BigNumber.prototype.toString.\r\n  convertBase = (function () {\r\n    var decimal = '0123456789';\r\n\r\n    /*\r\n     * Convert string of baseIn to an array of numbers of baseOut.\r\n     * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n     */\r\n    function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n      var j,\r\n        arr = [0],\r\n        arrL,\r\n        i = 0,\r\n        len = str.length;\r\n\r\n      for (; i < len;) {\r\n        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n        arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n        for (j = 0; j < arr.length; j++) {\r\n\r\n          if (arr[j] > baseOut - 1) {\r\n            if (arr[j + 1] == null) arr[j + 1] = 0;\r\n            arr[j + 1] += arr[j] / baseOut | 0;\r\n            arr[j] %= baseOut;\r\n          }\r\n        }\r\n      }\r\n\r\n      return arr.reverse();\r\n    }\r\n\r\n    // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n    // If the caller is toString, we are converting from base 10 to baseOut.\r\n    // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n    return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n      var alphabet, d, e, k, r, x, xc, y,\r\n        i = str.indexOf('.'),\r\n        dp = DECIMAL_PLACES,\r\n        rm = ROUNDING_MODE;\r\n\r\n      // Non-integer.\r\n      if (i >= 0) {\r\n        k = POW_PRECISION;\r\n\r\n        // Unlimited precision.\r\n        POW_PRECISION = 0;\r\n        str = str.replace('.', '');\r\n        y = new BigNumber(baseIn);\r\n        x = y.pow(str.length - i);\r\n        POW_PRECISION = k;\r\n\r\n        // Convert str as if an integer, then restore the fraction part by dividing the\r\n        // result by its base raised to a power.\r\n\r\n        y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n         10, baseOut, decimal);\r\n        y.e = y.c.length;\r\n      }\r\n\r\n      // Convert the number as integer.\r\n\r\n      xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n       ? (alphabet = ALPHABET, decimal)\r\n       : (alphabet = decimal, ALPHABET));\r\n\r\n      // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n      e = k = xc.length;\r\n\r\n      // Remove trailing zeros.\r\n      for (; xc[--k] == 0; xc.pop());\r\n\r\n      // Zero?\r\n      if (!xc[0]) return alphabet.charAt(0);\r\n\r\n      // Does str represent an integer? If so, no need for the division.\r\n      if (i < 0) {\r\n        --e;\r\n      } else {\r\n        x.c = xc;\r\n        x.e = e;\r\n\r\n        // The sign is needed for correct rounding.\r\n        x.s = sign;\r\n        x = div(x, y, dp, rm, baseOut);\r\n        xc = x.c;\r\n        r = x.r;\r\n        e = x.e;\r\n      }\r\n\r\n      // xc now represents str converted to baseOut.\r\n\r\n      // The index of the rounding digit.\r\n      d = e + dp + 1;\r\n\r\n      // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n      i = xc[d];\r\n\r\n      // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n      k = baseOut / 2;\r\n      r = r || d < 0 || xc[d + 1] != null;\r\n\r\n      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n            : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n      // If the index of the rounding digit is not greater than zero, or xc represents\r\n      // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n      // such as 0.00001.\r\n      if (d < 1 || !xc[0]) {\r\n\r\n        // 1^-dp or 0\r\n        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n      } else {\r\n\r\n        // Truncate xc to the required number of decimal places.\r\n        xc.length = d;\r\n\r\n        // Round up?\r\n        if (r) {\r\n\r\n          // Rounding up may mean the previous digit has to be rounded up and so on.\r\n          for (--baseOut; ++xc[--d] > baseOut;) {\r\n            xc[d] = 0;\r\n\r\n            if (!d) {\r\n              ++e;\r\n              xc = [1].concat(xc);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Determine trailing zeros.\r\n        for (k = xc.length; !xc[--k];);\r\n\r\n        // E.g. [4, 11, 15] becomes 4bf.\r\n        for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n        // Add leading zeros, decimal point and trailing zeros as required.\r\n        str = toFixedPoint(str, e, alphabet.charAt(0));\r\n      }\r\n\r\n      // The caller will add the sign.\r\n      return str;\r\n    };\r\n  })();\r\n\r\n\r\n  // Perform division in the specified base. Called by div and convertBase.\r\n  div = (function () {\r\n\r\n    // Assume non-zero x and k.\r\n    function multiply(x, k, base) {\r\n      var m, temp, xlo, xhi,\r\n        carry = 0,\r\n        i = x.length,\r\n        klo = k % SQRT_BASE,\r\n        khi = k / SQRT_BASE | 0;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        xlo = x[i] % SQRT_BASE;\r\n        xhi = x[i] / SQRT_BASE | 0;\r\n        m = khi * xlo + xhi * klo;\r\n        temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n        x[i] = temp % base;\r\n      }\r\n\r\n      if (carry) x = [carry].concat(x);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, cmp;\r\n\r\n      if (aL != bL) {\r\n        cmp = aL > bL ? 1 : -1;\r\n      } else {\r\n\r\n        for (i = cmp = 0; i < aL; i++) {\r\n\r\n          if (a[i] != b[i]) {\r\n            cmp = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return cmp;\r\n    }\r\n\r\n    function subtract(a, b, aL, base) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * base + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n    }\r\n\r\n    // x: dividend, y: divisor.\r\n    return function (x, y, dp, rm, base) {\r\n      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n        yL, yz,\r\n        s = x.s == y.s ? 1 : -1,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n        return new BigNumber(\r\n\r\n         // Return NaN if either NaN, or both Infinity or 0.\r\n         !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n          // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.\r\n          xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n       );\r\n      }\r\n\r\n      q = new BigNumber(s);\r\n      qc = q.c = [];\r\n      e = x.e - y.e;\r\n      s = dp + e + 1;\r\n\r\n      if (!base) {\r\n        base = BASE;\r\n        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n        s = s / LOG_BASE | 0;\r\n      }\r\n\r\n      // Result exponent may be one less then the current value of e.\r\n      // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n      for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n      if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n      if (s < 0) {\r\n        qc.push(1);\r\n        more = true;\r\n      } else {\r\n        xL = xc.length;\r\n        yL = yc.length;\r\n        i = 0;\r\n        s += 2;\r\n\r\n        // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n        n = mathfloor(base / (yc[0] + 1));\r\n\r\n        // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n        // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n        if (n > 1) {\r\n          yc = multiply(yc, n, base);\r\n          xc = multiply(xc, n, base);\r\n          yL = yc.length;\r\n          xL = xc.length;\r\n        }\r\n\r\n        xi = yL;\r\n        rem = xc.slice(0, yL);\r\n        remL = rem.length;\r\n\r\n        // Add zeros to make remainder as long as divisor.\r\n        for (; remL < yL; rem[remL++] = 0);\r\n        yz = yc.slice();\r\n        yz = [0].concat(yz);\r\n        yc0 = yc[0];\r\n        if (yc[1] >= base / 2) yc0++;\r\n        // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n        // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n        do {\r\n          n = 0;\r\n\r\n          // Compare divisor and remainder.\r\n          cmp = compare(yc, rem, yL, remL);\r\n\r\n          // If divisor < remainder.\r\n          if (cmp < 0) {\r\n\r\n            // Calculate trial digit, n.\r\n\r\n            rem0 = rem[0];\r\n            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n            // n is how many times the divisor goes into the current remainder.\r\n            n = mathfloor(rem0 / yc0);\r\n\r\n            //  Algorithm:\r\n            //  product = divisor multiplied by trial digit (n).\r\n            //  Compare product and remainder.\r\n            //  If product is greater than remainder:\r\n            //    Subtract divisor from product, decrement trial digit.\r\n            //  Subtract product from remainder.\r\n            //  If product was less than remainder at the last compare:\r\n            //    Compare new remainder and divisor.\r\n            //    If remainder is greater than divisor:\r\n            //      Subtract divisor from remainder, increment trial digit.\r\n\r\n            if (n > 1) {\r\n\r\n              // n may be > base only when base is 3.\r\n              if (n >= base) n = base - 1;\r\n\r\n              // product = divisor * trial digit.\r\n              prod = multiply(yc, n, base);\r\n              prodL = prod.length;\r\n              remL = rem.length;\r\n\r\n              // Compare product and remainder.\r\n              // If product > remainder then trial digit n too high.\r\n              // n is 1 too high about 5% of the time, and is not known to have\r\n              // ever been more than 1 too high.\r\n              while (compare(prod, rem, prodL, remL) == 1) {\r\n                n--;\r\n\r\n                // Subtract divisor from product.\r\n                subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                prodL = prod.length;\r\n                cmp = 1;\r\n              }\r\n            } else {\r\n\r\n              // n is 0 or 1, cmp is -1.\r\n              // If n is 0, there is no need to compare yc and rem again below,\r\n              // so change cmp to 1 to avoid it.\r\n              // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n              if (n == 0) {\r\n\r\n                // divisor < remainder, so n must be at least 1.\r\n                cmp = n = 1;\r\n              }\r\n\r\n              // product = divisor\r\n              prod = yc.slice();\r\n              prodL = prod.length;\r\n            }\r\n\r\n            if (prodL < remL) prod = [0].concat(prod);\r\n\r\n            // Subtract product from remainder.\r\n            subtract(rem, prod, remL, base);\r\n            remL = rem.length;\r\n\r\n             // If product was < remainder.\r\n            if (cmp == -1) {\r\n\r\n              // Compare divisor and new remainder.\r\n              // If divisor < new remainder, subtract divisor from remainder.\r\n              // Trial digit n too low.\r\n              // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n              while (compare(yc, rem, yL, remL) < 1) {\r\n                n++;\r\n\r\n                // Subtract divisor from remainder.\r\n                subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                remL = rem.length;\r\n              }\r\n            }\r\n          } else if (cmp === 0) {\r\n            n++;\r\n            rem = [0];\r\n          } // else cmp === 1 and n will be 0\r\n\r\n          // Add the next digit, n, to the result array.\r\n          qc[i++] = n;\r\n\r\n          // Update the remainder.\r\n          if (rem[0]) {\r\n            rem[remL++] = xc[xi] || 0;\r\n          } else {\r\n            rem = [xc[xi]];\r\n            remL = 1;\r\n          }\r\n        } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n        more = rem[0] != null;\r\n\r\n        // Leading zero?\r\n        if (!qc[0]) qc.splice(0, 1);\r\n      }\r\n\r\n      if (base == BASE) {\r\n\r\n        // To calculate q.e, first get the number of digits of qc[0].\r\n        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n      // Caller is convertBase.\r\n      } else {\r\n        q.e = e;\r\n        q.r = +more;\r\n      }\r\n\r\n      return q;\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n   * notation rounded to the specified decimal places or significant digits.\r\n   *\r\n   * n: a BigNumber.\r\n   * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n   * rm: the rounding mode.\r\n   * id: 1 (toExponential) or 2 (toPrecision).\r\n   */\r\n  function format(n, i, rm, id) {\r\n    var c0, e, ne, len, str;\r\n\r\n    if (rm == null) rm = ROUNDING_MODE;\r\n    else intCheck(rm, 0, 8);\r\n\r\n    if (!n.c) return n.toString();\r\n\r\n    c0 = n.c[0];\r\n    ne = n.e;\r\n\r\n    if (i == null) {\r\n      str = coeffToString(n.c);\r\n      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n       ? toExponential(str, ne)\r\n       : toFixedPoint(str, ne, '0');\r\n    } else {\r\n      n = round(new BigNumber(n), i, rm);\r\n\r\n      // n.e may have changed if the value was rounded up.\r\n      e = n.e;\r\n\r\n      str = coeffToString(n.c);\r\n      len = str.length;\r\n\r\n      // toPrecision returns exponential notation if the number of significant digits\r\n      // specified is less than the number of digits necessary to represent the integer\r\n      // part of the value in fixed-point notation.\r\n\r\n      // Exponential notation.\r\n      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n        // Append zeros?\r\n        for (; len < i; str += '0', len++);\r\n        str = toExponential(str, e);\r\n\r\n      // Fixed-point notation.\r\n      } else {\r\n        i -= ne;\r\n        str = toFixedPoint(str, e, '0');\r\n\r\n        // Append zeros?\r\n        if (e + 1 > len) {\r\n          if (--i > 0) for (str += '.'; i--; str += '0');\r\n        } else {\r\n          i += e - len;\r\n          if (i > 0) {\r\n            if (e + 1 == len) str += '.';\r\n            for (; i--; str += '0');\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return n.s < 0 && c0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Handle BigNumber.max and BigNumber.min.\r\n  // If any number is NaN, return NaN.\r\n  function maxOrMin(args, n) {\r\n    var k, y,\r\n      i = 1,\r\n      x = new BigNumber(args[0]);\r\n\r\n    for (; i < args.length; i++) {\r\n      y = new BigNumber(args[i]);\r\n      if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {\r\n        x = y;\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n   * Called by minus, plus and times.\r\n   */\r\n  function normalise(n, c, e) {\r\n    var i = 1,\r\n      j = c.length;\r\n\r\n     // Remove trailing zeros.\r\n    for (; !c[--j]; c.pop());\r\n\r\n    // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n    for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n    // Overflow?\r\n    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n      // Infinity.\r\n      n.c = n.e = null;\r\n\r\n    // Underflow?\r\n    } else if (e < MIN_EXP) {\r\n\r\n      // Zero.\r\n      n.c = [n.e = 0];\r\n    } else {\r\n      n.e = e;\r\n      n.c = c;\r\n    }\r\n\r\n    return n;\r\n  }\r\n\r\n\r\n  // Handle values that fail the validity test in BigNumber.\r\n  parseNumeric = (function () {\r\n    var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n      dotAfter = /^([^.]+)\\.$/,\r\n      dotBefore = /^\\.([^.]+)$/,\r\n      isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n      whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n    return function (x, str, isNum, b) {\r\n      var base,\r\n        s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n      // No exception on ±Infinity or NaN.\r\n      if (isInfinityOrNaN.test(s)) {\r\n        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n      } else {\r\n        if (!isNum) {\r\n\r\n          // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n          s = s.replace(basePrefix, function (m, p1, p2) {\r\n            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n            return !b || b == base ? p1 : m;\r\n          });\r\n\r\n          if (b) {\r\n            base = b;\r\n\r\n            // E.g. '1.' to '1', '.1' to '0.1'\r\n            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n          }\r\n\r\n          if (str != s) return new BigNumber(s, base);\r\n        }\r\n\r\n        // '[BigNumber Error] Not a number: {n}'\r\n        // '[BigNumber Error] Not a base {b} number: {n}'\r\n        if (BigNumber.DEBUG) {\r\n          throw Error\r\n            (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n        }\r\n\r\n        // NaN\r\n        x.s = null;\r\n      }\r\n\r\n      x.c = x.e = null;\r\n    }\r\n  })();\r\n\r\n\r\n  /*\r\n   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n   * If r is truthy, it is known that there are more digits after the rounding digit.\r\n   */\r\n  function round(x, sd, rm, r) {\r\n    var d, i, j, k, n, ni, rd,\r\n      xc = x.c,\r\n      pows10 = POWS_TEN;\r\n\r\n    // if x is not Infinity or NaN...\r\n    if (xc) {\r\n\r\n      // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n      // ni is the index of n within x.c.\r\n      // d is the number of digits of n.\r\n      // i is the index of rd within n including leading zeros.\r\n      // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n      out: {\r\n\r\n        // Get the number of digits of the first element of xc.\r\n        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n        i = sd - d;\r\n\r\n        // If the rounding digit is in the first element of xc...\r\n        if (i < 0) {\r\n          i += LOG_BASE;\r\n          j = sd;\r\n          n = xc[ni = 0];\r\n\r\n          // Get the rounding digit at index j of n.\r\n          rd = mathfloor(n / pows10[d - j - 1] % 10);\r\n        } else {\r\n          ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n          if (ni >= xc.length) {\r\n\r\n            if (r) {\r\n\r\n              // Needed by sqrt.\r\n              for (; xc.length <= ni; xc.push(0));\r\n              n = rd = 0;\r\n              d = 1;\r\n              i %= LOG_BASE;\r\n              j = i - LOG_BASE + 1;\r\n            } else {\r\n              break out;\r\n            }\r\n          } else {\r\n            n = k = xc[ni];\r\n\r\n            // Get the number of digits of n.\r\n            for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n            // Get the index of rd within n.\r\n            i %= LOG_BASE;\r\n\r\n            // Get the index of rd within n, adjusted for leading zeros.\r\n            // The number of leading zeros of n is given by LOG_BASE - d.\r\n            j = i - LOG_BASE + d;\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);\r\n          }\r\n        }\r\n\r\n        r = r || sd < 0 ||\r\n\r\n        // Are there any non-zero digits after the rounding digit?\r\n        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n         xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n        r = rm < 4\r\n         ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n         : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n           rm == (x.s < 0 ? 8 : 7));\r\n\r\n        if (sd < 1 || !xc[0]) {\r\n          xc.length = 0;\r\n\r\n          if (r) {\r\n\r\n            // Convert sd to decimal places.\r\n            sd -= x.e + 1;\r\n\r\n            // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n            x.e = -sd || 0;\r\n          } else {\r\n\r\n            // Zero.\r\n            xc[0] = x.e = 0;\r\n          }\r\n\r\n          return x;\r\n        }\r\n\r\n        // Remove excess digits.\r\n        if (i == 0) {\r\n          xc.length = ni;\r\n          k = 1;\r\n          ni--;\r\n        } else {\r\n          xc.length = ni + 1;\r\n          k = pows10[LOG_BASE - i];\r\n\r\n          // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n          // j > 0 means i > number of leading zeros of n.\r\n          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n        }\r\n\r\n        // Round up?\r\n        if (r) {\r\n\r\n          for (; ;) {\r\n\r\n            // If the digit to be rounded up is in the first element of xc...\r\n            if (ni == 0) {\r\n\r\n              // i will be the length of xc[0] before k is added.\r\n              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n              j = xc[0] += k;\r\n              for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n              // if i != k the length has increased.\r\n              if (i != k) {\r\n                x.e++;\r\n                if (xc[0] == BASE) xc[0] = 1;\r\n              }\r\n\r\n              break;\r\n            } else {\r\n              xc[ni] += k;\r\n              if (xc[ni] != BASE) break;\r\n              xc[ni--] = 0;\r\n              k = 1;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Remove trailing zeros.\r\n        for (i = xc.length; xc[--i] === 0; xc.pop());\r\n      }\r\n\r\n      // Overflow? Infinity.\r\n      if (x.e > MAX_EXP) {\r\n        x.c = x.e = null;\r\n\r\n      // Underflow? Zero.\r\n      } else if (x.e < MIN_EXP) {\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function valueOf(n) {\r\n    var str,\r\n      e = n.e;\r\n\r\n    if (e === null) return n.toString();\r\n\r\n    str = coeffToString(n.c);\r\n\r\n    str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n      ? toExponential(str, e)\r\n      : toFixedPoint(str, e, '0');\r\n\r\n    return n.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new BigNumber(this);\r\n    if (x.s < 0) x.s = 1;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   *   0 if they have the same value,\r\n   *   or null if the value of either is NaN.\r\n   */\r\n  P.comparedTo = function (y, b) {\r\n    return compare(this, new BigNumber(y, b));\r\n  };\r\n\r\n\r\n  /*\r\n   * If dp is undefined or null or true or false, return the number of decimal places of the\r\n   * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n   *\r\n   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.decimalPlaces = P.dp = function (dp, rm) {\r\n    var c, n, v,\r\n      x = this;\r\n\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      return round(new BigNumber(x), dp + x.e + 1, rm);\r\n    }\r\n\r\n    if (!(c = x.c)) return null;\r\n    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n    // Subtract the number of trailing zeros of the last number.\r\n    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n    if (n < 0) n = 0;\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */\r\n  P.dividedBy = P.div = function (y, b) {\r\n    return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n   * BigNumber by the value of BigNumber(y, b).\r\n   */\r\n  P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n    return div(this, new BigNumber(y, b), 0, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n   *\r\n   * If m is present, return the result modulo m.\r\n   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n   *\r\n   * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n   *\r\n   * n {number|string|BigNumber} The exponent. An integer.\r\n   * [m] {number|string|BigNumber} The modulus.\r\n   *\r\n   * '[BigNumber Error] Exponent not an integer: {n}'\r\n   */\r\n  P.exponentiatedBy = P.pow = function (n, m) {\r\n    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n      x = this;\r\n\r\n    n = new BigNumber(n);\r\n\r\n    // Allow NaN and ±Infinity, but not other non-integers.\r\n    if (n.c && !n.isInteger()) {\r\n      throw Error\r\n        (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n    }\r\n\r\n    if (m != null) m = new BigNumber(m);\r\n\r\n    // Exponent of MAX_SAFE_INTEGER is 15.\r\n    nIsBig = n.e > 14;\r\n\r\n    // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.\r\n    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n      // The sign of the result of pow when x is negative depends on the evenness of n.\r\n      // If +n overflows to ±Infinity, the evenness of n would be not be known.\r\n      y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));\r\n      return m ? y.mod(m) : y;\r\n    }\r\n\r\n    nIsNeg = n.s < 0;\r\n\r\n    if (m) {\r\n\r\n      // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n      if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n      isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n      if (isModExp) x = x.mod(m);\r\n\r\n    // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n    // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.\r\n    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n      // [1, 240000000]\r\n      ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n      // [80000000000000]  [99999750000000]\r\n      : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n      // If x is negative and n is odd, k = -0, else k = 0.\r\n      k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n      // If x >= 1, k = ±Infinity.\r\n      if (x.e > -1) k = 1 / k;\r\n\r\n      // If n is negative return ±0, else return ±Infinity.\r\n      return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n    } else if (POW_PRECISION) {\r\n\r\n      // Truncating each coefficient array to a length of k after each multiplication\r\n      // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n      // i.e. there will be a minimum of 28 guard digits retained.\r\n      k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n    }\r\n\r\n    if (nIsBig) {\r\n      half = new BigNumber(0.5);\r\n      if (nIsNeg) n.s = 1;\r\n      nIsOdd = isOdd(n);\r\n    } else {\r\n      i = Math.abs(+valueOf(n));\r\n      nIsOdd = i % 2;\r\n    }\r\n\r\n    y = new BigNumber(ONE);\r\n\r\n    // Performs 54 loop iterations for n of 9007199254740991.\r\n    for (; ;) {\r\n\r\n      if (nIsOdd) {\r\n        y = y.times(x);\r\n        if (!y.c) break;\r\n\r\n        if (k) {\r\n          if (y.c.length > k) y.c.length = k;\r\n        } else if (isModExp) {\r\n          y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (i) {\r\n        i = mathfloor(i / 2);\r\n        if (i === 0) break;\r\n        nIsOdd = i % 2;\r\n      } else {\r\n        n = n.times(half);\r\n        round(n, n.e + 1, 1);\r\n\r\n        if (n.e > 14) {\r\n          nIsOdd = isOdd(n);\r\n        } else {\r\n          i = +valueOf(n);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        }\r\n      }\r\n\r\n      x = x.times(x);\r\n\r\n      if (k) {\r\n        if (x.c && x.c.length > k) x.c.length = k;\r\n      } else if (isModExp) {\r\n        x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n      }\r\n    }\r\n\r\n    if (isModExp) return y;\r\n    if (nIsNeg) y = ONE.div(y);\r\n\r\n    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n   */\r\n  P.integerValue = function (rm) {\r\n    var n = new BigNumber(this);\r\n    if (rm == null) rm = ROUNDING_MODE;\r\n    else intCheck(rm, 0, 8);\r\n    return round(n, n.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isEqualTo = P.eq = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n   */\r\n  P.isFinite = function () {\r\n    return !!this.c;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isGreaterThan = P.gt = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is greater than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */\r\n  P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n    return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n   */\r\n  P.isInteger = function () {\r\n    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isLessThan = P.lt = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is less than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */\r\n  P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n    return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n   */\r\n  P.isNaN = function () {\r\n    return !this.s;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is negative, otherwise return false.\r\n   */\r\n  P.isNegative = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is positive, otherwise return false.\r\n   */\r\n  P.isPositive = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n   */\r\n  P.isZero = function () {\r\n    return !!this.c && this.c[0] == 0;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n   * BigNumber(y, b).\r\n   */\r\n  P.minus = function (y, b) {\r\n    var i, j, t, xLTy,\r\n      x = this,\r\n      a = x.s;\r\n\r\n    y = new BigNumber(y, b);\r\n    b = y.s;\r\n\r\n    // Either NaN?\r\n    if (!a || !b) return new BigNumber(NaN);\r\n\r\n    // Signs differ?\r\n    if (a != b) {\r\n      y.s = -b;\r\n      return x.plus(y);\r\n    }\r\n\r\n    var xe = x.e / LOG_BASE,\r\n      ye = y.e / LOG_BASE,\r\n      xc = x.c,\r\n      yc = y.c;\r\n\r\n    if (!xe || !ye) {\r\n\r\n      // Either Infinity?\r\n      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n      // Either zero?\r\n      if (!xc[0] || !yc[0]) {\r\n\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n         // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n         ROUNDING_MODE == 3 ? -0 : 0);\r\n      }\r\n    }\r\n\r\n    xe = bitFloor(xe);\r\n    ye = bitFloor(ye);\r\n    xc = xc.slice();\r\n\r\n    // Determine which is the bigger number.\r\n    if (a = xe - ye) {\r\n\r\n      if (xLTy = a < 0) {\r\n        a = -a;\r\n        t = xc;\r\n      } else {\r\n        ye = xe;\r\n        t = yc;\r\n      }\r\n\r\n      t.reverse();\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      for (b = a; b--; t.push(0));\r\n      t.reverse();\r\n    } else {\r\n\r\n      // Exponents equal. Check digit by digit.\r\n      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n      for (a = b = 0; b < j; b++) {\r\n\r\n        if (xc[b] != yc[b]) {\r\n          xLTy = xc[b] < yc[b];\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // x < y? Point xc to the array of the bigger number.\r\n    if (xLTy) {\r\n      t = xc;\r\n      xc = yc;\r\n      yc = t;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    b = (j = yc.length) - (i = xc.length);\r\n\r\n    // Append zeros to xc if shorter.\r\n    // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n    if (b > 0) for (; b--; xc[i++] = 0);\r\n    b = BASE - 1;\r\n\r\n    // Subtract yc from xc.\r\n    for (; j > a;) {\r\n\r\n      if (xc[--j] < yc[j]) {\r\n        for (i = j; i && !xc[--i]; xc[i] = b);\r\n        --xc[i];\r\n        xc[j] += BASE;\r\n      }\r\n\r\n      xc[j] -= yc[j];\r\n    }\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n    // Zero?\r\n    if (!xc[0]) {\r\n\r\n      // Following IEEE 754 (2008) 6.3,\r\n      // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n      y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n      y.c = [y.e = 0];\r\n      return y;\r\n    }\r\n\r\n    // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n    // for finite x and y.\r\n    return normalise(y, xc, ye);\r\n  };\r\n\r\n\r\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n   * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n   */\r\n  P.modulo = P.mod = function (y, b) {\r\n    var q, s,\r\n      x = this;\r\n\r\n    y = new BigNumber(y, b);\r\n\r\n    // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n    if (!x.c || !y.s || y.c && !y.c[0]) {\r\n      return new BigNumber(NaN);\r\n\r\n    // Return x if y is Infinity or x is zero.\r\n    } else if (!y.c || x.c && !x.c[0]) {\r\n      return new BigNumber(x);\r\n    }\r\n\r\n    if (MODULO_MODE == 9) {\r\n\r\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n      // r = x - qy    where  0 <= r < abs(y)\r\n      s = y.s;\r\n      y.s = 1;\r\n      q = div(x, y, 0, 3);\r\n      y.s = s;\r\n      q.s *= s;\r\n    } else {\r\n      q = div(x, y, 0, MODULO_MODE);\r\n    }\r\n\r\n    y = x.minus(q.times(y));\r\n\r\n    // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n   * of BigNumber(y, b).\r\n   */\r\n  P.multipliedBy = P.times = function (y, b) {\r\n    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n      base, sqrtBase,\r\n      x = this,\r\n      xc = x.c,\r\n      yc = (y = new BigNumber(y, b)).c;\r\n\r\n    // Either NaN, ±Infinity or ±0?\r\n    if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n      // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n        y.c = y.e = y.s = null;\r\n      } else {\r\n        y.s *= x.s;\r\n\r\n        // Return ±Infinity if either is ±Infinity.\r\n        if (!xc || !yc) {\r\n          y.c = y.e = null;\r\n\r\n        // Return ±0 if either is ±0.\r\n        } else {\r\n          y.c = [0];\r\n          y.e = 0;\r\n        }\r\n      }\r\n\r\n      return y;\r\n    }\r\n\r\n    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n    y.s *= x.s;\r\n    xcL = xc.length;\r\n    ycL = yc.length;\r\n\r\n    // Ensure xc points to longer array and xcL to its length.\r\n    if (xcL < ycL) {\r\n      zc = xc;\r\n      xc = yc;\r\n      yc = zc;\r\n      i = xcL;\r\n      xcL = ycL;\r\n      ycL = i;\r\n    }\r\n\r\n    // Initialise the result array with zeros.\r\n    for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n    base = BASE;\r\n    sqrtBase = SQRT_BASE;\r\n\r\n    for (i = ycL; --i >= 0;) {\r\n      c = 0;\r\n      ylo = yc[i] % sqrtBase;\r\n      yhi = yc[i] / sqrtBase | 0;\r\n\r\n      for (k = xcL, j = i + k; j > i;) {\r\n        xlo = xc[--k] % sqrtBase;\r\n        xhi = xc[k] / sqrtBase | 0;\r\n        m = yhi * xlo + xhi * ylo;\r\n        xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n        zc[j--] = xlo % base;\r\n      }\r\n\r\n      zc[j] = c;\r\n    }\r\n\r\n    if (c) {\r\n      ++e;\r\n    } else {\r\n      zc.splice(0, 1);\r\n    }\r\n\r\n    return normalise(y, zc, e);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n   * i.e. multiplied by -1.\r\n   */\r\n  P.negated = function () {\r\n    var x = new BigNumber(this);\r\n    x.s = -x.s || null;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n   * BigNumber(y, b).\r\n   */\r\n  P.plus = function (y, b) {\r\n    var t,\r\n      x = this,\r\n      a = x.s;\r\n\r\n    y = new BigNumber(y, b);\r\n    b = y.s;\r\n\r\n    // Either NaN?\r\n    if (!a || !b) return new BigNumber(NaN);\r\n\r\n    // Signs differ?\r\n     if (a != b) {\r\n      y.s = -b;\r\n      return x.minus(y);\r\n    }\r\n\r\n    var xe = x.e / LOG_BASE,\r\n      ye = y.e / LOG_BASE,\r\n      xc = x.c,\r\n      yc = y.c;\r\n\r\n    if (!xe || !ye) {\r\n\r\n      // Return ±Infinity if either ±Infinity.\r\n      if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n      // Either zero?\r\n      // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n    }\r\n\r\n    xe = bitFloor(xe);\r\n    ye = bitFloor(ye);\r\n    xc = xc.slice();\r\n\r\n    // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n    if (a = xe - ye) {\r\n      if (a > 0) {\r\n        ye = xe;\r\n        t = yc;\r\n      } else {\r\n        a = -a;\r\n        t = xc;\r\n      }\r\n\r\n      t.reverse();\r\n      for (; a--; t.push(0));\r\n      t.reverse();\r\n    }\r\n\r\n    a = xc.length;\r\n    b = yc.length;\r\n\r\n    // Point xc to the longer array, and b to the shorter length.\r\n    if (a - b < 0) {\r\n      t = yc;\r\n      yc = xc;\r\n      xc = t;\r\n      b = a;\r\n    }\r\n\r\n    // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n    for (a = 0; b;) {\r\n      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n    }\r\n\r\n    if (a) {\r\n      xc = [a].concat(xc);\r\n      ++ye;\r\n    }\r\n\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    // ye = MAX_EXP + 1 possible\r\n    return normalise(y, xc, ye);\r\n  };\r\n\r\n\r\n  /*\r\n   * If sd is undefined or null or true or false, return the number of significant digits of\r\n   * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n   * If sd is true include integer-part trailing zeros in the count.\r\n   *\r\n   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n   *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */\r\n  P.precision = P.sd = function (sd, rm) {\r\n    var c, n, v,\r\n      x = this;\r\n\r\n    if (sd != null && sd !== !!sd) {\r\n      intCheck(sd, 1, MAX);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      return round(new BigNumber(x), sd, rm);\r\n    }\r\n\r\n    if (!(c = x.c)) return null;\r\n    v = c.length - 1;\r\n    n = v * LOG_BASE + 1;\r\n\r\n    if (v = c[v]) {\r\n\r\n      // Subtract the number of trailing zeros of the last element.\r\n      for (; v % 10 == 0; v /= 10, n--);\r\n\r\n      // Add the number of digits of the first element.\r\n      for (v = c[0]; v >= 10; v /= 10, n++);\r\n    }\r\n\r\n    if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n   *\r\n   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n   */\r\n  P.shiftedBy = function (k) {\r\n    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n    return this.times('1e' + k);\r\n  };\r\n\r\n\r\n  /*\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N) =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I) =  I\r\n   *  sqrt(0) =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var m, n, r, rep, t,\r\n      x = this,\r\n      c = x.c,\r\n      s = x.s,\r\n      e = x.e,\r\n      dp = DECIMAL_PLACES + 4,\r\n      half = new BigNumber('0.5');\r\n\r\n    // Negative/NaN/Infinity/zero?\r\n    if (s !== 1 || !c || !c[0]) {\r\n      return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n    }\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+valueOf(x));\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = coeffToString(c);\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(+n);\r\n      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new BigNumber(n);\r\n    } else {\r\n      r = new BigNumber(s + '');\r\n    }\r\n\r\n    // Check for zero.\r\n    // r could be zero if MIN_EXP is changed after the this value was created.\r\n    // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n    // coeffToString to throw.\r\n    if (r.c[0]) {\r\n      e = r.e;\r\n      s = e + dp;\r\n      if (s < 3) s = 0;\r\n\r\n      // Newton-Raphson iteration.\r\n      for (; ;) {\r\n        t = r;\r\n        r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n          // The exponent of r may here be one less than the final result exponent,\r\n          // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n          // are indexed correctly.\r\n          if (r.e < e) --s;\r\n          n = n.slice(s - 3, s + 1);\r\n\r\n          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n          // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n          // iteration.\r\n          if (n == '9999' || !rep && n == '4999') {\r\n\r\n            // On the first iteration only, check to see if rounding up gives the\r\n            // exact result as the nines may infinitely repeat.\r\n            if (!rep) {\r\n              round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n              if (t.times(t).eq(x)) {\r\n                r = t;\r\n                break;\r\n              }\r\n            }\r\n\r\n            dp += 4;\r\n            s += 4;\r\n            rep = 1;\r\n          } else {\r\n\r\n            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n            // result. If not, then there are further digits and m will be truthy.\r\n            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n              // Truncate to the first rounding digit.\r\n              round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n              m = !r.times(r).eq(x);\r\n            }\r\n\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in exponential notation and\r\n   * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      dp++;\r\n    }\r\n    return format(this, dp, rm, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n   * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      dp = dp + this.e + 1;\r\n    }\r\n    return format(this, dp, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n   * of the format or FORMAT object (see BigNumber.set).\r\n   *\r\n   * The formatting object may contain some or all of the properties shown below.\r\n   *\r\n   * FORMAT = {\r\n   *   prefix: '',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 0,\r\n   *   groupSeparator: ',',\r\n   *   decimalSeparator: '.',\r\n   *   fractionGroupSize: 0,\r\n   *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n   *   suffix: ''\r\n   * };\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   * [format] {object} Formatting options. See FORMAT pbject above.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   * '[BigNumber Error] Argument not an object: {format}'\r\n   */\r\n  P.toFormat = function (dp, rm, format) {\r\n    var str,\r\n      x = this;\r\n\r\n    if (format == null) {\r\n      if (dp != null && rm && typeof rm == 'object') {\r\n        format = rm;\r\n        rm = null;\r\n      } else if (dp && typeof dp == 'object') {\r\n        format = dp;\r\n        dp = rm = null;\r\n      } else {\r\n        format = FORMAT;\r\n      }\r\n    } else if (typeof format != 'object') {\r\n      throw Error\r\n        (bignumberError + 'Argument not an object: ' + format);\r\n    }\r\n\r\n    str = x.toFixed(dp, rm);\r\n\r\n    if (x.c) {\r\n      var i,\r\n        arr = str.split('.'),\r\n        g1 = +format.groupSize,\r\n        g2 = +format.secondaryGroupSize,\r\n        groupSeparator = format.groupSeparator || '',\r\n        intPart = arr[0],\r\n        fractionPart = arr[1],\r\n        isNeg = x.s < 0,\r\n        intDigits = isNeg ? intPart.slice(1) : intPart,\r\n        len = intDigits.length;\r\n\r\n      if (g2) {\r\n        i = g1;\r\n        g1 = g2;\r\n        g2 = i;\r\n        len -= i;\r\n      }\r\n\r\n      if (g1 > 0 && len > 0) {\r\n        i = len % g1 || g1;\r\n        intPart = intDigits.substr(0, i);\r\n        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n        if (isNeg) intPart = '-' + intPart;\r\n      }\r\n\r\n      str = fractionPart\r\n       ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n        ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n         '$&' + (format.fractionGroupSeparator || ''))\r\n        : fractionPart)\r\n       : intPart;\r\n    }\r\n\r\n    return (format.prefix || '') + str + (format.suffix || '');\r\n  };\r\n\r\n\r\n  /*\r\n   * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n   * fraction with an integer numerator and an integer denominator.\r\n   * The denominator will be a positive non-zero value less than or equal to the specified\r\n   * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n   * the lowest value necessary to represent the number exactly.\r\n   *\r\n   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n   *\r\n   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n   */\r\n  P.toFraction = function (md) {\r\n    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n      x = this,\r\n      xc = x.c;\r\n\r\n    if (md != null) {\r\n      n = new BigNumber(md);\r\n\r\n      // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n        throw Error\r\n          (bignumberError + 'Argument ' +\r\n            (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n      }\r\n    }\r\n\r\n    if (!xc) return new BigNumber(x);\r\n\r\n    d = new BigNumber(ONE);\r\n    n1 = d0 = new BigNumber(ONE);\r\n    d1 = n0 = new BigNumber(ONE);\r\n    s = coeffToString(xc);\r\n\r\n    // Determine initial denominator.\r\n    // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n    e = d.e = s.length - x.e - 1;\r\n    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n    md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n    exp = MAX_EXP;\r\n    MAX_EXP = 1 / 0;\r\n    n = new BigNumber(s);\r\n\r\n    // n0 = d1 = 0\r\n    n0.c[0] = 0;\r\n\r\n    for (; ;)  {\r\n      q = div(n, d, 0, 1);\r\n      d2 = d0.plus(q.times(d1));\r\n      if (d2.comparedTo(md) == 1) break;\r\n      d0 = d1;\r\n      d1 = d2;\r\n      n1 = n0.plus(q.times(d2 = n1));\r\n      n0 = d2;\r\n      d = n.minus(q.times(d2 = d));\r\n      n = d2;\r\n    }\r\n\r\n    d2 = div(md.minus(d0), d1, 0, 1);\r\n    n0 = n0.plus(d2.times(n1));\r\n    d0 = d0.plus(d2.times(d1));\r\n    n0.s = n1.s = x.s;\r\n    e = e * 2;\r\n\r\n    // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n    MAX_EXP = exp;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this BigNumber converted to a number primitive.\r\n   */\r\n  P.toNumber = function () {\r\n    return +valueOf(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n   * necessary to represent the integer part of the value in fixed-point notation, then use\r\n   * exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    if (sd != null) intCheck(sd, 1, MAX);\r\n    return format(this, sd, rm, 2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n   * TO_EXP_NEG, return exponential notation.\r\n   *\r\n   * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n   *\r\n   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n   */\r\n  P.toString = function (b) {\r\n    var str,\r\n      n = this,\r\n      s = n.s,\r\n      e = n.e;\r\n\r\n    // Infinity or NaN?\r\n    if (e === null) {\r\n      if (s) {\r\n        str = 'Infinity';\r\n        if (s < 0) str = '-' + str;\r\n      } else {\r\n        str = 'NaN';\r\n      }\r\n    } else {\r\n      if (b == null) {\r\n        str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n         ? toExponential(coeffToString(n.c), e)\r\n         : toFixedPoint(coeffToString(n.c), e, '0');\r\n      } else if (b === 10 && alphabetHasNormalDecimalDigits) {\r\n        n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n        str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n      } else {\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n        str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n      }\r\n\r\n      if (s < 0 && n.c[0]) str = '-' + str;\r\n    }\r\n\r\n    return str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return as toString, but do not accept a base argument, and include the minus sign for\r\n   * negative zero.\r\n   */\r\n  P.valueOf = P.toJSON = function () {\r\n    return valueOf(this);\r\n  };\r\n\r\n\r\n  P._isBigNumber = true;\r\n\r\n  P[Symbol.toStringTag] = 'BigNumber';\r\n\r\n  // Node.js v10.12.0+\r\n  P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;\r\n\r\n  if (configObject != null) BigNumber.set(configObject);\r\n\r\n  return BigNumber;\r\n}\r\n\r\n\r\n// PRIVATE HELPER FUNCTIONS\r\n\r\n// These functions don't need access to variables,\r\n// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\nfunction bitFloor(n) {\r\n  var i = n | 0;\r\n  return n > 0 || n === i ? i : i - 1;\r\n}\r\n\r\n\r\n// Return a coefficient array as a string of base 10 digits.\r\nfunction coeffToString(a) {\r\n  var s, z,\r\n    i = 1,\r\n    j = a.length,\r\n    r = a[0] + '';\r\n\r\n  for (; i < j;) {\r\n    s = a[i++] + '';\r\n    z = LOG_BASE - s.length;\r\n    for (; z--; s = '0' + s);\r\n    r += s;\r\n  }\r\n\r\n  // Determine trailing zeros.\r\n  for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n  return r.slice(0, j + 1 || 1);\r\n}\r\n\r\n\r\n// Compare the value of BigNumbers x and y.\r\nfunction compare(x, y) {\r\n  var a, b,\r\n    xc = x.c,\r\n    yc = y.c,\r\n    i = x.s,\r\n    j = y.s,\r\n    k = x.e,\r\n    l = y.e;\r\n\r\n  // Either NaN?\r\n  if (!i || !j) return null;\r\n\r\n  a = xc && !xc[0];\r\n  b = yc && !yc[0];\r\n\r\n  // Either zero?\r\n  if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n  // Signs differ?\r\n  if (i != j) return i;\r\n\r\n  a = i < 0;\r\n  b = k == l;\r\n\r\n  // Either Infinity?\r\n  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n  // Compare exponents.\r\n  if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n  j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n  // Compare digit by digit.\r\n  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n  // Compare lengths.\r\n  return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n}\r\n\r\n\r\n/*\r\n * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n */\r\nfunction intCheck(n, min, max, name) {\r\n  if (n < min || n > max || n !== mathfloor(n)) {\r\n    throw Error\r\n     (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n       ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n       : ' not a primitive number: ') + String(n));\r\n  }\r\n}\r\n\r\n\r\n// Assumes finite n.\r\nfunction isOdd(n) {\r\n  var k = n.c.length - 1;\r\n  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n}\r\n\r\n\r\nfunction toExponential(str, e) {\r\n  return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n   (e < 0 ? 'e' : 'e+') + e;\r\n}\r\n\r\n\r\nfunction toFixedPoint(str, e, z) {\r\n  var len, zs;\r\n\r\n  // Negative exponent?\r\n  if (e < 0) {\r\n\r\n    // Prepend zeros.\r\n    for (zs = z + '.'; ++e; zs += z);\r\n    str = zs + str;\r\n\r\n  // Positive exponent\r\n  } else {\r\n    len = str.length;\r\n\r\n    // Append zeros.\r\n    if (++e > len) {\r\n      for (zs = z, e -= len; --e; zs += z);\r\n      str += zs;\r\n    } else if (e < len) {\r\n      str = str.slice(0, e) + '.' + str.slice(e);\r\n    }\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\n\r\n// EXPORT\r\n\r\n\r\nexport var BigNumber = clone();\r\n\r\nexport default BigNumber;\r\n","// src/index.ts\nvar SplayTreeNode = class {\n  key;\n  left = null;\n  right = null;\n  constructor(key) {\n    this.key = key;\n  }\n};\nvar SplayTreeSetNode = class extends SplayTreeNode {\n  constructor(key) {\n    super(key);\n  }\n};\nvar SplayTreeMapNode = class _SplayTreeMapNode extends SplayTreeNode {\n  value;\n  constructor(key, value) {\n    super(key);\n    this.value = value;\n  }\n  replaceValue(value) {\n    const node = new _SplayTreeMapNode(this.key, value);\n    node.left = this.left;\n    node.right = this.right;\n    return node;\n  }\n};\nvar SplayTree = class {\n  size = 0;\n  modificationCount = 0;\n  splayCount = 0;\n  splay(key) {\n    const root = this.root;\n    if (root == null) {\n      this.compare(key, key);\n      return -1;\n    }\n    let right = null;\n    let newTreeRight = null;\n    let left = null;\n    let newTreeLeft = null;\n    let current = root;\n    const compare = this.compare;\n    let comp;\n    while (true) {\n      comp = compare(current.key, key);\n      if (comp > 0) {\n        let currentLeft = current.left;\n        if (currentLeft == null) break;\n        comp = compare(currentLeft.key, key);\n        if (comp > 0) {\n          current.left = currentLeft.right;\n          currentLeft.right = current;\n          current = currentLeft;\n          currentLeft = current.left;\n          if (currentLeft == null) break;\n        }\n        if (right == null) {\n          newTreeRight = current;\n        } else {\n          right.left = current;\n        }\n        right = current;\n        current = currentLeft;\n      } else if (comp < 0) {\n        let currentRight = current.right;\n        if (currentRight == null) break;\n        comp = compare(currentRight.key, key);\n        if (comp < 0) {\n          current.right = currentRight.left;\n          currentRight.left = current;\n          current = currentRight;\n          currentRight = current.right;\n          if (currentRight == null) break;\n        }\n        if (left == null) {\n          newTreeLeft = current;\n        } else {\n          left.right = current;\n        }\n        left = current;\n        current = currentRight;\n      } else {\n        break;\n      }\n    }\n    if (left != null) {\n      left.right = current.left;\n      current.left = newTreeLeft;\n    }\n    if (right != null) {\n      right.left = current.right;\n      current.right = newTreeRight;\n    }\n    if (this.root !== current) {\n      this.root = current;\n      this.splayCount++;\n    }\n    return comp;\n  }\n  splayMin(node) {\n    let current = node;\n    let nextLeft = current.left;\n    while (nextLeft != null) {\n      const left = nextLeft;\n      current.left = left.right;\n      left.right = current;\n      current = left;\n      nextLeft = current.left;\n    }\n    return current;\n  }\n  splayMax(node) {\n    let current = node;\n    let nextRight = current.right;\n    while (nextRight != null) {\n      const right = nextRight;\n      current.right = right.left;\n      right.left = current;\n      current = right;\n      nextRight = current.right;\n    }\n    return current;\n  }\n  _delete(key) {\n    if (this.root == null) return null;\n    const comp = this.splay(key);\n    if (comp != 0) return null;\n    let root = this.root;\n    const result = root;\n    const left = root.left;\n    this.size--;\n    if (left == null) {\n      this.root = root.right;\n    } else {\n      const right = root.right;\n      root = this.splayMax(left);\n      root.right = right;\n      this.root = root;\n    }\n    this.modificationCount++;\n    return result;\n  }\n  addNewRoot(node, comp) {\n    this.size++;\n    this.modificationCount++;\n    const root = this.root;\n    if (root == null) {\n      this.root = node;\n      return;\n    }\n    if (comp < 0) {\n      node.left = root;\n      node.right = root.right;\n      root.right = null;\n    } else {\n      node.right = root;\n      node.left = root.left;\n      root.left = null;\n    }\n    this.root = node;\n  }\n  _first() {\n    const root = this.root;\n    if (root == null) return null;\n    this.root = this.splayMin(root);\n    return this.root;\n  }\n  _last() {\n    const root = this.root;\n    if (root == null) return null;\n    this.root = this.splayMax(root);\n    return this.root;\n  }\n  clear() {\n    this.root = null;\n    this.size = 0;\n    this.modificationCount++;\n  }\n  has(key) {\n    return this.validKey(key) && this.splay(key) == 0;\n  }\n  defaultCompare() {\n    return (a, b) => a < b ? -1 : a > b ? 1 : 0;\n  }\n  wrap() {\n    return {\n      getRoot: () => {\n        return this.root;\n      },\n      setRoot: (root) => {\n        this.root = root;\n      },\n      getSize: () => {\n        return this.size;\n      },\n      getModificationCount: () => {\n        return this.modificationCount;\n      },\n      getSplayCount: () => {\n        return this.splayCount;\n      },\n      setSplayCount: (count) => {\n        this.splayCount = count;\n      },\n      splay: (key) => {\n        return this.splay(key);\n      },\n      has: (key) => {\n        return this.has(key);\n      }\n    };\n  }\n};\nvar SplayTreeMap = class extends SplayTree {\n  root = null;\n  compare;\n  validKey;\n  constructor(compare, isValidKey) {\n    super();\n    this.compare = compare ?? this.defaultCompare();\n    this.validKey = isValidKey ?? ((a) => a != null && a != void 0);\n  }\n  delete(key) {\n    if (!this.validKey(key)) return false;\n    return this._delete(key) != null;\n  }\n  forEach(f) {\n    const nodes = new SplayTreeMapEntryIterableIterator(this.wrap());\n    let result;\n    while (result = nodes.next(), !result.done) {\n      f(result.value[1], result.value[0], this);\n    }\n  }\n  get(key) {\n    if (!this.validKey(key)) return void 0;\n    if (this.root != null) {\n      const comp = this.splay(key);\n      if (comp == 0) {\n        return this.root.value;\n      }\n    }\n    return void 0;\n  }\n  hasValue(value) {\n    const initialSplayCount = this.splayCount;\n    const visit = (node) => {\n      while (node != null) {\n        if (node.value == value) return true;\n        if (initialSplayCount != this.splayCount) {\n          throw \"Concurrent modification during iteration.\";\n        }\n        if (node.right != null && visit(node.right)) {\n          return true;\n        }\n        node = node.left;\n      }\n      return false;\n    };\n    return visit(this.root);\n  }\n  set(key, value) {\n    const comp = this.splay(key);\n    if (comp == 0) {\n      this.root = this.root.replaceValue(value);\n      this.splayCount += 1;\n      return this;\n    }\n    this.addNewRoot(new SplayTreeMapNode(key, value), comp);\n    return this;\n  }\n  setAll(other) {\n    other.forEach((value, key) => {\n      this.set(key, value);\n    });\n  }\n  setIfAbsent(key, ifAbsent) {\n    let comp = this.splay(key);\n    if (comp == 0) {\n      return this.root.value;\n    }\n    const modificationCount = this.modificationCount;\n    const splayCount = this.splayCount;\n    const value = ifAbsent();\n    if (modificationCount != this.modificationCount) {\n      throw \"Concurrent modification during iteration.\";\n    }\n    if (splayCount != this.splayCount) {\n      comp = this.splay(key);\n    }\n    this.addNewRoot(new SplayTreeMapNode(key, value), comp);\n    return value;\n  }\n  isEmpty() {\n    return this.root == null;\n  }\n  isNotEmpty() {\n    return !this.isEmpty();\n  }\n  firstKey() {\n    if (this.root == null) return null;\n    return this._first().key;\n  }\n  lastKey() {\n    if (this.root == null) return null;\n    return this._last().key;\n  }\n  lastKeyBefore(key) {\n    if (key == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(key);\n    if (comp < 0) return this.root.key;\n    let node = this.root.left;\n    if (node == null) return null;\n    let nodeRight = node.right;\n    while (nodeRight != null) {\n      node = nodeRight;\n      nodeRight = node.right;\n    }\n    return node.key;\n  }\n  firstKeyAfter(key) {\n    if (key == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(key);\n    if (comp > 0) return this.root.key;\n    let node = this.root.right;\n    if (node == null) return null;\n    let nodeLeft = node.left;\n    while (nodeLeft != null) {\n      node = nodeLeft;\n      nodeLeft = node.left;\n    }\n    return node.key;\n  }\n  update(key, update, ifAbsent) {\n    let comp = this.splay(key);\n    if (comp == 0) {\n      const modificationCount = this.modificationCount;\n      const splayCount = this.splayCount;\n      const newValue = update(this.root.value);\n      if (modificationCount != this.modificationCount) {\n        throw \"Concurrent modification during iteration.\";\n      }\n      if (splayCount != this.splayCount) {\n        this.splay(key);\n      }\n      this.root = this.root.replaceValue(newValue);\n      this.splayCount += 1;\n      return newValue;\n    }\n    if (ifAbsent != null) {\n      const modificationCount = this.modificationCount;\n      const splayCount = this.splayCount;\n      const newValue = ifAbsent();\n      if (modificationCount != this.modificationCount) {\n        throw \"Concurrent modification during iteration.\";\n      }\n      if (splayCount != this.splayCount) {\n        comp = this.splay(key);\n      }\n      this.addNewRoot(new SplayTreeMapNode(key, newValue), comp);\n      return newValue;\n    }\n    throw \"Invalid argument (key): Key not in map.\";\n  }\n  updateAll(update) {\n    const root = this.root;\n    if (root == null) return;\n    const iterator = new SplayTreeMapEntryIterableIterator(this.wrap());\n    let node;\n    while (node = iterator.next(), !node.done) {\n      const newValue = update(...node.value);\n      iterator.replaceValue(newValue);\n    }\n  }\n  keys() {\n    return new SplayTreeKeyIterableIterator(this.wrap());\n  }\n  values() {\n    return new SplayTreeValueIterableIterator(this.wrap());\n  }\n  entries() {\n    return this[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return new SplayTreeMapEntryIterableIterator(this.wrap());\n  }\n  [Symbol.toStringTag] = \"[object Map]\";\n};\nvar SplayTreeSet = class _SplayTreeSet extends SplayTree {\n  root = null;\n  compare;\n  validKey;\n  constructor(compare, isValidKey) {\n    super();\n    this.compare = compare ?? this.defaultCompare();\n    this.validKey = isValidKey ?? ((v) => v != null && v != void 0);\n  }\n  delete(element) {\n    if (!this.validKey(element)) return false;\n    return this._delete(element) != null;\n  }\n  deleteAll(elements) {\n    for (const element of elements) {\n      this.delete(element);\n    }\n  }\n  forEach(f) {\n    const nodes = this[Symbol.iterator]();\n    let result;\n    while (result = nodes.next(), !result.done) {\n      f(result.value, result.value, this);\n    }\n  }\n  add(element) {\n    const compare = this.splay(element);\n    if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);\n    return this;\n  }\n  addAndReturn(element) {\n    const compare = this.splay(element);\n    if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);\n    return this.root.key;\n  }\n  addAll(elements) {\n    for (const element of elements) {\n      this.add(element);\n    }\n  }\n  isEmpty() {\n    return this.root == null;\n  }\n  isNotEmpty() {\n    return this.root != null;\n  }\n  single() {\n    if (this.size == 0) throw \"Bad state: No element\";\n    if (this.size > 1) throw \"Bad state: Too many element\";\n    return this.root.key;\n  }\n  first() {\n    if (this.size == 0) throw \"Bad state: No element\";\n    return this._first().key;\n  }\n  last() {\n    if (this.size == 0) throw \"Bad state: No element\";\n    return this._last().key;\n  }\n  lastBefore(element) {\n    if (element == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(element);\n    if (comp < 0) return this.root.key;\n    let node = this.root.left;\n    if (node == null) return null;\n    let nodeRight = node.right;\n    while (nodeRight != null) {\n      node = nodeRight;\n      nodeRight = node.right;\n    }\n    return node.key;\n  }\n  firstAfter(element) {\n    if (element == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(element);\n    if (comp > 0) return this.root.key;\n    let node = this.root.right;\n    if (node == null) return null;\n    let nodeLeft = node.left;\n    while (nodeLeft != null) {\n      node = nodeLeft;\n      nodeLeft = node.left;\n    }\n    return node.key;\n  }\n  retainAll(elements) {\n    const retainSet = new _SplayTreeSet(this.compare, this.validKey);\n    const modificationCount = this.modificationCount;\n    for (const object of elements) {\n      if (modificationCount != this.modificationCount) {\n        throw \"Concurrent modification during iteration.\";\n      }\n      if (this.validKey(object) && this.splay(object) == 0) {\n        retainSet.add(this.root.key);\n      }\n    }\n    if (retainSet.size != this.size) {\n      this.root = retainSet.root;\n      this.size = retainSet.size;\n      this.modificationCount++;\n    }\n  }\n  lookup(object) {\n    if (!this.validKey(object)) return null;\n    const comp = this.splay(object);\n    if (comp != 0) return null;\n    return this.root.key;\n  }\n  intersection(other) {\n    const result = new _SplayTreeSet(this.compare, this.validKey);\n    for (const element of this) {\n      if (other.has(element)) result.add(element);\n    }\n    return result;\n  }\n  difference(other) {\n    const result = new _SplayTreeSet(this.compare, this.validKey);\n    for (const element of this) {\n      if (!other.has(element)) result.add(element);\n    }\n    return result;\n  }\n  union(other) {\n    const u = this.clone();\n    u.addAll(other);\n    return u;\n  }\n  clone() {\n    const set = new _SplayTreeSet(this.compare, this.validKey);\n    set.size = this.size;\n    set.root = this.copyNode(this.root);\n    return set;\n  }\n  copyNode(node) {\n    if (node == null) return null;\n    function copyChildren(node2, dest) {\n      let left;\n      let right;\n      do {\n        left = node2.left;\n        right = node2.right;\n        if (left != null) {\n          const newLeft = new SplayTreeSetNode(left.key);\n          dest.left = newLeft;\n          copyChildren(left, newLeft);\n        }\n        if (right != null) {\n          const newRight = new SplayTreeSetNode(right.key);\n          dest.right = newRight;\n          node2 = right;\n          dest = newRight;\n        }\n      } while (right != null);\n    }\n    const result = new SplayTreeSetNode(node.key);\n    copyChildren(node, result);\n    return result;\n  }\n  toSet() {\n    return this.clone();\n  }\n  entries() {\n    return new SplayTreeSetEntryIterableIterator(this.wrap());\n  }\n  keys() {\n    return this[Symbol.iterator]();\n  }\n  values() {\n    return this[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return new SplayTreeKeyIterableIterator(this.wrap());\n  }\n  [Symbol.toStringTag] = \"[object Set]\";\n};\nvar SplayTreeIterableIterator = class {\n  tree;\n  path = new Array();\n  modificationCount = null;\n  splayCount;\n  constructor(tree) {\n    this.tree = tree;\n    this.splayCount = tree.getSplayCount();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    if (this.moveNext()) return { done: false, value: this.current() };\n    return { done: true, value: null };\n  }\n  current() {\n    if (!this.path.length) return null;\n    const node = this.path[this.path.length - 1];\n    return this.getValue(node);\n  }\n  rebuildPath(key) {\n    this.path.splice(0, this.path.length);\n    this.tree.splay(key);\n    this.path.push(this.tree.getRoot());\n    this.splayCount = this.tree.getSplayCount();\n  }\n  findLeftMostDescendent(node) {\n    while (node != null) {\n      this.path.push(node);\n      node = node.left;\n    }\n  }\n  moveNext() {\n    if (this.modificationCount != this.tree.getModificationCount()) {\n      if (this.modificationCount == null) {\n        this.modificationCount = this.tree.getModificationCount();\n        let node2 = this.tree.getRoot();\n        while (node2 != null) {\n          this.path.push(node2);\n          node2 = node2.left;\n        }\n        return this.path.length > 0;\n      }\n      throw \"Concurrent modification during iteration.\";\n    }\n    if (!this.path.length) return false;\n    if (this.splayCount != this.tree.getSplayCount()) {\n      this.rebuildPath(this.path[this.path.length - 1].key);\n    }\n    let node = this.path[this.path.length - 1];\n    let next = node.right;\n    if (next != null) {\n      while (next != null) {\n        this.path.push(next);\n        next = next.left;\n      }\n      return true;\n    }\n    this.path.pop();\n    while (this.path.length && this.path[this.path.length - 1].right === node) {\n      node = this.path.pop();\n    }\n    return this.path.length > 0;\n  }\n};\nvar SplayTreeKeyIterableIterator = class extends SplayTreeIterableIterator {\n  getValue(node) {\n    return node.key;\n  }\n};\nvar SplayTreeSetEntryIterableIterator = class extends SplayTreeIterableIterator {\n  getValue(node) {\n    return [node.key, node.key];\n  }\n};\nvar SplayTreeValueIterableIterator = class extends SplayTreeIterableIterator {\n  constructor(map) {\n    super(map);\n  }\n  getValue(node) {\n    return node.value;\n  }\n};\nvar SplayTreeMapEntryIterableIterator = class extends SplayTreeIterableIterator {\n  constructor(map) {\n    super(map);\n  }\n  getValue(node) {\n    return [node.key, node.value];\n  }\n  replaceValue(value) {\n    if (this.modificationCount != this.tree.getModificationCount()) {\n      throw \"Concurrent modification during iteration.\";\n    }\n    if (this.splayCount != this.tree.getSplayCount()) {\n      this.rebuildPath(this.path[this.path.length - 1].key);\n    }\n    const last = this.path.pop();\n    const newLast = last.replaceValue(value);\n    if (!this.path.length) {\n      this.tree.setRoot(newLast);\n    } else {\n      const parent = this.path[this.path.length - 1];\n      if (last === parent.left) {\n        parent.left = newLast;\n      } else {\n        parent.right = newLast;\n      }\n    }\n    this.path.push(newLast);\n    const count = this.tree.getSplayCount() + 1;\n    this.tree.setSplayCount(count);\n    this.splayCount = count;\n  }\n};\nexport {\n  SplayTreeMap,\n  SplayTreeSet\n};\n//# sourceMappingURL=index.js.map","// src/geom-in.ts\nimport BigNumber2 from \"bignumber.js\";\n\n// src/constant.ts\nvar constant_default = (x) => {\n  return () => {\n    return x;\n  };\n};\n\n// src/compare.ts\nvar compare_default = (eps) => {\n  const almostEqual = eps ? (a, b) => b.minus(a).abs().isLessThanOrEqualTo(eps) : constant_default(false);\n  return (a, b) => {\n    if (almostEqual(a, b)) return 0;\n    return a.comparedTo(b);\n  };\n};\n\n// src/orient.ts\nfunction orient_default(eps) {\n  const almostCollinear = eps ? (area2, ax, ay, cx, cy) => area2.exponentiatedBy(2).isLessThanOrEqualTo(\n    cx.minus(ax).exponentiatedBy(2).plus(cy.minus(ay).exponentiatedBy(2)).times(eps)\n  ) : constant_default(false);\n  return (a, b, c) => {\n    const ax = a.x, ay = a.y, cx = c.x, cy = c.y;\n    const area2 = ay.minus(cy).times(b.x.minus(cx)).minus(ax.minus(cx).times(b.y.minus(cy)));\n    if (almostCollinear(area2, ax, ay, cx, cy)) return 0;\n    return area2.comparedTo(0);\n  };\n}\n\n// src/snap.ts\nimport BigNumber from \"bignumber.js\";\nimport { SplayTreeSet } from \"splaytree-ts\";\n\n// src/identity.ts\nvar identity_default = (x) => {\n  return x;\n};\n\n// src/snap.ts\nvar snap_default = (eps) => {\n  if (eps) {\n    const xTree = new SplayTreeSet(compare_default(eps));\n    const yTree = new SplayTreeSet(compare_default(eps));\n    const snapCoord = (coord, tree) => {\n      return tree.addAndReturn(coord);\n    };\n    const snap = (v) => {\n      return {\n        x: snapCoord(v.x, xTree),\n        y: snapCoord(v.y, yTree)\n      };\n    };\n    snap({ x: new BigNumber(0), y: new BigNumber(0) });\n    return snap;\n  }\n  return identity_default;\n};\n\n// src/precision.ts\nvar set = (eps) => {\n  return {\n    set: (eps2) => {\n      precision = set(eps2);\n    },\n    reset: () => set(eps),\n    compare: compare_default(eps),\n    snap: snap_default(eps),\n    orient: orient_default(eps)\n  };\n};\nvar precision = set();\n\n// src/bbox.ts\nvar isInBbox = (bbox, point) => {\n  return bbox.ll.x.isLessThanOrEqualTo(point.x) && point.x.isLessThanOrEqualTo(bbox.ur.x) && bbox.ll.y.isLessThanOrEqualTo(point.y) && point.y.isLessThanOrEqualTo(bbox.ur.y);\n};\nvar getBboxOverlap = (b1, b2) => {\n  if (b2.ur.x.isLessThan(b1.ll.x) || b1.ur.x.isLessThan(b2.ll.x) || b2.ur.y.isLessThan(b1.ll.y) || b1.ur.y.isLessThan(b2.ll.y))\n    return null;\n  const lowerX = b1.ll.x.isLessThan(b2.ll.x) ? b2.ll.x : b1.ll.x;\n  const upperX = b1.ur.x.isLessThan(b2.ur.x) ? b1.ur.x : b2.ur.x;\n  const lowerY = b1.ll.y.isLessThan(b2.ll.y) ? b2.ll.y : b1.ll.y;\n  const upperY = b1.ur.y.isLessThan(b2.ur.y) ? b1.ur.y : b2.ur.y;\n  return { ll: { x: lowerX, y: lowerY }, ur: { x: upperX, y: upperY } };\n};\n\n// src/operation.ts\nimport { SplayTreeSet as SplayTreeSet3 } from \"splaytree-ts\";\n\n// src/vector.ts\nvar crossProduct = (a, b) => a.x.times(b.y).minus(a.y.times(b.x));\nvar dotProduct = (a, b) => a.x.times(b.x).plus(a.y.times(b.y));\nvar length = (v) => dotProduct(v, v).sqrt();\nvar sineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = { x: pBase.x.minus(pShared.x), y: pBase.y.minus(pShared.y) };\n  const vAngle = { x: pAngle.x.minus(pShared.x), y: pAngle.y.minus(pShared.y) };\n  return crossProduct(vAngle, vBase).div(length(vAngle)).div(length(vBase));\n};\nvar cosineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = { x: pBase.x.minus(pShared.x), y: pBase.y.minus(pShared.y) };\n  const vAngle = { x: pAngle.x.minus(pShared.x), y: pAngle.y.minus(pShared.y) };\n  return dotProduct(vAngle, vBase).div(length(vAngle)).div(length(vBase));\n};\nvar horizontalIntersection = (pt, v, y) => {\n  if (v.y.isZero()) return null;\n  return { x: pt.x.plus(v.x.div(v.y).times(y.minus(pt.y))), y };\n};\nvar verticalIntersection = (pt, v, x) => {\n  if (v.x.isZero()) return null;\n  return { x, y: pt.y.plus(v.y.div(v.x).times(x.minus(pt.x))) };\n};\nvar intersection = (pt1, v1, pt2, v2) => {\n  if (v1.x.isZero()) return verticalIntersection(pt2, v2, pt1.x);\n  if (v2.x.isZero()) return verticalIntersection(pt1, v1, pt2.x);\n  if (v1.y.isZero()) return horizontalIntersection(pt2, v2, pt1.y);\n  if (v2.y.isZero()) return horizontalIntersection(pt1, v1, pt2.y);\n  const kross = crossProduct(v1, v2);\n  if (kross.isZero()) return null;\n  const ve = { x: pt2.x.minus(pt1.x), y: pt2.y.minus(pt1.y) };\n  const d1 = crossProduct(ve, v1).div(kross);\n  const d2 = crossProduct(ve, v2).div(kross);\n  const x1 = pt1.x.plus(d2.times(v1.x)), x2 = pt2.x.plus(d1.times(v2.x));\n  const y1 = pt1.y.plus(d2.times(v1.y)), y2 = pt2.y.plus(d1.times(v2.y));\n  const x = x1.plus(x2).div(2);\n  const y = y1.plus(y2).div(2);\n  return { x, y };\n};\n\n// src/sweep-event.ts\nvar SweepEvent = class _SweepEvent {\n  point;\n  isLeft;\n  segment;\n  otherSE;\n  consumedBy;\n  // for ordering sweep events in the sweep event queue\n  static compare(a, b) {\n    const ptCmp = _SweepEvent.comparePoints(a.point, b.point);\n    if (ptCmp !== 0) return ptCmp;\n    if (a.point !== b.point) a.link(b);\n    if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;\n    return Segment.compare(a.segment, b.segment);\n  }\n  // for ordering points in sweep line order\n  static comparePoints(aPt, bPt) {\n    if (aPt.x.isLessThan(bPt.x)) return -1;\n    if (aPt.x.isGreaterThan(bPt.x)) return 1;\n    if (aPt.y.isLessThan(bPt.y)) return -1;\n    if (aPt.y.isGreaterThan(bPt.y)) return 1;\n    return 0;\n  }\n  // Warning: 'point' input will be modified and re-used (for performance)\n  constructor(point, isLeft) {\n    if (point.events === void 0) point.events = [this];\n    else point.events.push(this);\n    this.point = point;\n    this.isLeft = isLeft;\n  }\n  link(other) {\n    if (other.point === this.point) {\n      throw new Error(\"Tried to link already linked events\");\n    }\n    const otherEvents = other.point.events;\n    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {\n      const evt = otherEvents[i];\n      this.point.events.push(evt);\n      evt.point = this.point;\n    }\n    this.checkForConsuming();\n  }\n  /* Do a pass over our linked events and check to see if any pair\n   * of segments match, and should be consumed. */\n  checkForConsuming() {\n    const numEvents = this.point.events.length;\n    for (let i = 0; i < numEvents; i++) {\n      const evt1 = this.point.events[i];\n      if (evt1.segment.consumedBy !== void 0) continue;\n      for (let j = i + 1; j < numEvents; j++) {\n        const evt2 = this.point.events[j];\n        if (evt2.consumedBy !== void 0) continue;\n        if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n        evt1.segment.consume(evt2.segment);\n      }\n    }\n  }\n  getAvailableLinkedEvents() {\n    const events = [];\n    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {\n      const evt = this.point.events[i];\n      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n        events.push(evt);\n      }\n    }\n    return events;\n  }\n  /**\n   * Returns a comparator function for sorting linked events that will\n   * favor the event that will give us the smallest left-side angle.\n   * All ring construction starts as low as possible heading to the right,\n   * so by always turning left as sharp as possible we'll get polygons\n   * without uncessary loops & holes.\n   *\n   * The comparator function has a compute cache such that it avoids\n   * re-computing already-computed values.\n   */\n  getLeftmostComparator(baseEvent) {\n    const cache = /* @__PURE__ */ new Map();\n    const fillCache = (linkedEvent) => {\n      const nextEvent = linkedEvent.otherSE;\n      cache.set(linkedEvent, {\n        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),\n        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)\n      });\n    };\n    return (a, b) => {\n      if (!cache.has(a)) fillCache(a);\n      if (!cache.has(b)) fillCache(b);\n      const { sine: asine, cosine: acosine } = cache.get(a);\n      const { sine: bsine, cosine: bcosine } = cache.get(b);\n      if (asine.isGreaterThanOrEqualTo(0) && bsine.isGreaterThanOrEqualTo(0)) {\n        if (acosine.isLessThan(bcosine)) return 1;\n        if (acosine.isGreaterThan(bcosine)) return -1;\n        return 0;\n      }\n      if (asine.isLessThan(0) && bsine.isLessThan(0)) {\n        if (acosine.isLessThan(bcosine)) return -1;\n        if (acosine.isGreaterThan(bcosine)) return 1;\n        return 0;\n      }\n      if (bsine.isLessThan(asine)) return -1;\n      if (bsine.isGreaterThan(asine)) return 1;\n      return 0;\n    };\n  }\n};\n\n// src/geom-out.ts\nvar RingOut = class _RingOut {\n  events;\n  poly;\n  _isExteriorRing;\n  _enclosingRing;\n  /* Given the segments from the sweep line pass, compute & return a series\n   * of closed rings from all the segments marked to be part of the result */\n  static factory(allSegments) {\n    const ringsOut = [];\n    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {\n      const segment = allSegments[i];\n      if (!segment.isInResult() || segment.ringOut) continue;\n      let prevEvent = null;\n      let event = segment.leftSE;\n      let nextEvent = segment.rightSE;\n      const events = [event];\n      const startingPoint = event.point;\n      const intersectionLEs = [];\n      while (true) {\n        prevEvent = event;\n        event = nextEvent;\n        events.push(event);\n        if (event.point === startingPoint) break;\n        while (true) {\n          const availableLEs = event.getAvailableLinkedEvents();\n          if (availableLEs.length === 0) {\n            const firstPt = events[0].point;\n            const lastPt = events[events.length - 1].point;\n            throw new Error(\n              `Unable to complete output ring starting at [${firstPt.x}, ${firstPt.y}]. Last matching segment found ends at [${lastPt.x}, ${lastPt.y}].`\n            );\n          }\n          if (availableLEs.length === 1) {\n            nextEvent = availableLEs[0].otherSE;\n            break;\n          }\n          let indexLE = null;\n          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n            if (intersectionLEs[j].point === event.point) {\n              indexLE = j;\n              break;\n            }\n          }\n          if (indexLE !== null) {\n            const intersectionLE = intersectionLEs.splice(indexLE)[0];\n            const ringEvents = events.splice(intersectionLE.index);\n            ringEvents.unshift(ringEvents[0].otherSE);\n            ringsOut.push(new _RingOut(ringEvents.reverse()));\n            continue;\n          }\n          intersectionLEs.push({\n            index: events.length,\n            point: event.point\n          });\n          const comparator = event.getLeftmostComparator(prevEvent);\n          nextEvent = availableLEs.sort(comparator)[0].otherSE;\n          break;\n        }\n      }\n      ringsOut.push(new _RingOut(events));\n    }\n    return ringsOut;\n  }\n  constructor(events) {\n    this.events = events;\n    for (let i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this;\n    }\n    this.poly = null;\n  }\n  getGeom() {\n    let prevPt = this.events[0].point;\n    const points = [prevPt];\n    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n      const pt2 = this.events[i].point;\n      const nextPt2 = this.events[i + 1].point;\n      if (precision.orient(pt2, prevPt, nextPt2) === 0) continue;\n      points.push(pt2);\n      prevPt = pt2;\n    }\n    if (points.length === 1) return null;\n    const pt = points[0];\n    const nextPt = points[1];\n    if (precision.orient(pt, prevPt, nextPt) === 0) points.shift();\n    points.push(points[0]);\n    const step = this.isExteriorRing() ? 1 : -1;\n    const iStart = this.isExteriorRing() ? 0 : points.length - 1;\n    const iEnd = this.isExteriorRing() ? points.length : -1;\n    const orderedPoints = [];\n    for (let i = iStart; i != iEnd; i += step)\n      orderedPoints.push([points[i].x.toNumber(), points[i].y.toNumber()]);\n    return orderedPoints;\n  }\n  isExteriorRing() {\n    if (this._isExteriorRing === void 0) {\n      const enclosing = this.enclosingRing();\n      this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n    }\n    return this._isExteriorRing;\n  }\n  enclosingRing() {\n    if (this._enclosingRing === void 0) {\n      this._enclosingRing = this._calcEnclosingRing();\n    }\n    return this._enclosingRing;\n  }\n  /* Returns the ring that encloses this one, if any */\n  _calcEnclosingRing() {\n    let leftMostEvt = this.events[0];\n    for (let i = 1, iMax = this.events.length; i < iMax; i++) {\n      const evt = this.events[i];\n      if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n    }\n    let prevSeg = leftMostEvt.segment.prevInResult();\n    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n    while (true) {\n      if (!prevSeg) return null;\n      if (!prevPrevSeg) return prevSeg.ringOut;\n      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n        if (prevPrevSeg.ringOut?.enclosingRing() !== prevSeg.ringOut) {\n          return prevSeg.ringOut;\n        } else return prevSeg.ringOut?.enclosingRing();\n      }\n      prevSeg = prevPrevSeg.prevInResult();\n      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n    }\n  }\n};\nvar PolyOut = class {\n  exteriorRing;\n  interiorRings;\n  constructor(exteriorRing) {\n    this.exteriorRing = exteriorRing;\n    exteriorRing.poly = this;\n    this.interiorRings = [];\n  }\n  addInterior(ring) {\n    this.interiorRings.push(ring);\n    ring.poly = this;\n  }\n  getGeom() {\n    const geom0 = this.exteriorRing.getGeom();\n    if (geom0 === null) return null;\n    const geom = [geom0];\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringGeom = this.interiorRings[i].getGeom();\n      if (ringGeom === null) continue;\n      geom.push(ringGeom);\n    }\n    return geom;\n  }\n};\nvar MultiPolyOut = class {\n  rings;\n  polys;\n  constructor(rings) {\n    this.rings = rings;\n    this.polys = this._composePolys(rings);\n  }\n  getGeom() {\n    const geom = [];\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polyGeom = this.polys[i].getGeom();\n      if (polyGeom === null) continue;\n      geom.push(polyGeom);\n    }\n    return geom;\n  }\n  _composePolys(rings) {\n    const polys = [];\n    for (let i = 0, iMax = rings.length; i < iMax; i++) {\n      const ring = rings[i];\n      if (ring.poly) continue;\n      if (ring.isExteriorRing()) polys.push(new PolyOut(ring));\n      else {\n        const enclosingRing = ring.enclosingRing();\n        if (!enclosingRing?.poly) polys.push(new PolyOut(enclosingRing));\n        enclosingRing?.poly?.addInterior(ring);\n      }\n    }\n    return polys;\n  }\n};\n\n// src/sweep-line.ts\nimport { SplayTreeSet as SplayTreeSet2 } from \"splaytree-ts\";\nvar SweepLine = class {\n  queue;\n  tree;\n  segments;\n  constructor(queue, comparator = Segment.compare) {\n    this.queue = queue;\n    this.tree = new SplayTreeSet2(comparator);\n    this.segments = [];\n  }\n  process(event) {\n    const segment = event.segment;\n    const newEvents = [];\n    if (event.consumedBy) {\n      if (event.isLeft) this.queue.delete(event.otherSE);\n      else this.tree.delete(segment);\n      return newEvents;\n    }\n    if (event.isLeft) this.tree.add(segment);\n    let prevSeg = segment;\n    let nextSeg = segment;\n    do {\n      prevSeg = this.tree.lastBefore(prevSeg);\n    } while (prevSeg != null && prevSeg.consumedBy != void 0);\n    do {\n      nextSeg = this.tree.firstAfter(nextSeg);\n    } while (nextSeg != null && nextSeg.consumedBy != void 0);\n    if (event.isLeft) {\n      let prevMySplitter = null;\n      if (prevSeg) {\n        const prevInter = prevSeg.getIntersection(segment);\n        if (prevInter !== null) {\n          if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n          if (!prevSeg.isAnEndpoint(prevInter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n      let nextMySplitter = null;\n      if (nextSeg) {\n        const nextInter = nextSeg.getIntersection(segment);\n        if (nextInter !== null) {\n          if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n          if (!nextSeg.isAnEndpoint(nextInter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n      if (prevMySplitter !== null || nextMySplitter !== null) {\n        let mySplitter = null;\n        if (prevMySplitter === null) mySplitter = nextMySplitter;\n        else if (nextMySplitter === null) mySplitter = prevMySplitter;\n        else {\n          const cmpSplitters = SweepEvent.comparePoints(\n            prevMySplitter,\n            nextMySplitter\n          );\n          mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n        }\n        this.queue.delete(segment.rightSE);\n        newEvents.push(segment.rightSE);\n        const newEventsFromSplit = segment.split(mySplitter);\n        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n          newEvents.push(newEventsFromSplit[i]);\n        }\n      }\n      if (newEvents.length > 0) {\n        this.tree.delete(segment);\n        newEvents.push(event);\n      } else {\n        this.segments.push(segment);\n        segment.prev = prevSeg;\n      }\n    } else {\n      if (prevSeg && nextSeg) {\n        const inter = prevSeg.getIntersection(nextSeg);\n        if (inter !== null) {\n          if (!prevSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, inter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n          if (!nextSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, inter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n      this.tree.delete(segment);\n    }\n    return newEvents;\n  }\n  /* Safely split a segment that is currently in the datastructures\n   * IE - a segment other than the one that is currently being processed. */\n  _splitSafely(seg, pt) {\n    this.tree.delete(seg);\n    const rightSE = seg.rightSE;\n    this.queue.delete(rightSE);\n    const newEvents = seg.split(pt);\n    newEvents.push(rightSE);\n    if (seg.consumedBy === void 0) this.tree.add(seg);\n    return newEvents;\n  }\n};\n\n// src/operation.ts\nvar Operation = class {\n  type;\n  numMultiPolys;\n  run(type, geom, moreGeoms) {\n    operation.type = type;\n    const multipolys = [new MultiPolyIn(geom, true)];\n    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n      multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n    }\n    operation.numMultiPolys = multipolys.length;\n    if (operation.type === \"difference\") {\n      const subject = multipolys[0];\n      let i = 1;\n      while (i < multipolys.length) {\n        if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;\n        else multipolys.splice(i, 1);\n      }\n    }\n    if (operation.type === \"intersection\") {\n      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n        const mpA = multipolys[i];\n        for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {\n          if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n        }\n      }\n    }\n    const queue = new SplayTreeSet3(SweepEvent.compare);\n    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n      const sweepEvents = multipolys[i].getSweepEvents();\n      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {\n        queue.add(sweepEvents[j]);\n      }\n    }\n    const sweepLine = new SweepLine(queue);\n    let evt = null;\n    if (queue.size != 0) {\n      evt = queue.first();\n      queue.delete(evt);\n    }\n    while (evt) {\n      const newEvents = sweepLine.process(evt);\n      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {\n        const evt2 = newEvents[i];\n        if (evt2.consumedBy === void 0) queue.add(evt2);\n      }\n      if (queue.size != 0) {\n        evt = queue.first();\n        queue.delete(evt);\n      } else {\n        evt = null;\n      }\n    }\n    precision.reset();\n    const ringsOut = RingOut.factory(sweepLine.segments);\n    const result = new MultiPolyOut(ringsOut);\n    return result.getGeom();\n  }\n};\nvar operation = new Operation();\nvar operation_default = operation;\n\n// src/segment.ts\nvar segmentId = 0;\nvar Segment = class _Segment {\n  id;\n  leftSE;\n  rightSE;\n  rings;\n  windings;\n  ringOut;\n  consumedBy;\n  prev;\n  _prevInResult;\n  _beforeState;\n  _afterState;\n  _isInResult;\n  /* This compare() function is for ordering segments in the sweep\n   * line tree, and does so according to the following criteria:\n   *\n   * Consider the vertical line that lies an infinestimal step to the\n   * right of the right-more of the two left endpoints of the input\n   * segments. Imagine slowly moving a point up from negative infinity\n   * in the increasing y direction. Which of the two segments will that\n   * point intersect first? That segment comes 'before' the other one.\n   *\n   * If neither segment would be intersected by such a line, (if one\n   * or more of the segments are vertical) then the line to be considered\n   * is directly on the right-more of the two left inputs.\n   */\n  static compare(a, b) {\n    const alx = a.leftSE.point.x;\n    const blx = b.leftSE.point.x;\n    const arx = a.rightSE.point.x;\n    const brx = b.rightSE.point.x;\n    if (brx.isLessThan(alx)) return 1;\n    if (arx.isLessThan(blx)) return -1;\n    const aly = a.leftSE.point.y;\n    const bly = b.leftSE.point.y;\n    const ary = a.rightSE.point.y;\n    const bry = b.rightSE.point.y;\n    if (alx.isLessThan(blx)) {\n      if (bly.isLessThan(aly) && bly.isLessThan(ary)) return 1;\n      if (bly.isGreaterThan(aly) && bly.isGreaterThan(ary)) return -1;\n      const aCmpBLeft = a.comparePoint(b.leftSE.point);\n      if (aCmpBLeft < 0) return 1;\n      if (aCmpBLeft > 0) return -1;\n      const bCmpARight = b.comparePoint(a.rightSE.point);\n      if (bCmpARight !== 0) return bCmpARight;\n      return -1;\n    }\n    if (alx.isGreaterThan(blx)) {\n      if (aly.isLessThan(bly) && aly.isLessThan(bry)) return -1;\n      if (aly.isGreaterThan(bly) && aly.isGreaterThan(bry)) return 1;\n      const bCmpALeft = b.comparePoint(a.leftSE.point);\n      if (bCmpALeft !== 0) return bCmpALeft;\n      const aCmpBRight = a.comparePoint(b.rightSE.point);\n      if (aCmpBRight < 0) return 1;\n      if (aCmpBRight > 0) return -1;\n      return 1;\n    }\n    if (aly.isLessThan(bly)) return -1;\n    if (aly.isGreaterThan(bly)) return 1;\n    if (arx.isLessThan(brx)) {\n      const bCmpARight = b.comparePoint(a.rightSE.point);\n      if (bCmpARight !== 0) return bCmpARight;\n    }\n    if (arx.isGreaterThan(brx)) {\n      const aCmpBRight = a.comparePoint(b.rightSE.point);\n      if (aCmpBRight < 0) return 1;\n      if (aCmpBRight > 0) return -1;\n    }\n    if (!arx.eq(brx)) {\n      const ay = ary.minus(aly);\n      const ax = arx.minus(alx);\n      const by = bry.minus(bly);\n      const bx = brx.minus(blx);\n      if (ay.isGreaterThan(ax) && by.isLessThan(bx)) return 1;\n      if (ay.isLessThan(ax) && by.isGreaterThan(bx)) return -1;\n    }\n    if (arx.isGreaterThan(brx)) return 1;\n    if (arx.isLessThan(brx)) return -1;\n    if (ary.isLessThan(bry)) return -1;\n    if (ary.isGreaterThan(bry)) return 1;\n    if (a.id < b.id) return -1;\n    if (a.id > b.id) return 1;\n    return 0;\n  }\n  /* Warning: a reference to ringWindings input will be stored,\n   *  and possibly will be later modified */\n  constructor(leftSE, rightSE, rings, windings) {\n    this.id = ++segmentId;\n    this.leftSE = leftSE;\n    leftSE.segment = this;\n    leftSE.otherSE = rightSE;\n    this.rightSE = rightSE;\n    rightSE.segment = this;\n    rightSE.otherSE = leftSE;\n    this.rings = rings;\n    this.windings = windings;\n  }\n  static fromRing(pt1, pt2, ring) {\n    let leftPt, rightPt, winding;\n    const cmpPts = SweepEvent.comparePoints(pt1, pt2);\n    if (cmpPts < 0) {\n      leftPt = pt1;\n      rightPt = pt2;\n      winding = 1;\n    } else if (cmpPts > 0) {\n      leftPt = pt2;\n      rightPt = pt1;\n      winding = -1;\n    } else\n      throw new Error(\n        `Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`\n      );\n    const leftSE = new SweepEvent(leftPt, true);\n    const rightSE = new SweepEvent(rightPt, false);\n    return new _Segment(leftSE, rightSE, [ring], [winding]);\n  }\n  /* When a segment is split, the rightSE is replaced with a new sweep event */\n  replaceRightSE(newRightSE) {\n    this.rightSE = newRightSE;\n    this.rightSE.segment = this;\n    this.rightSE.otherSE = this.leftSE;\n    this.leftSE.otherSE = this.rightSE;\n  }\n  bbox() {\n    const y1 = this.leftSE.point.y;\n    const y2 = this.rightSE.point.y;\n    return {\n      ll: { x: this.leftSE.point.x, y: y1.isLessThan(y2) ? y1 : y2 },\n      ur: { x: this.rightSE.point.x, y: y1.isGreaterThan(y2) ? y1 : y2 }\n    };\n  }\n  /* A vector from the left point to the right */\n  vector() {\n    return {\n      x: this.rightSE.point.x.minus(this.leftSE.point.x),\n      y: this.rightSE.point.y.minus(this.leftSE.point.y)\n    };\n  }\n  isAnEndpoint(pt) {\n    return pt.x.eq(this.leftSE.point.x) && pt.y.eq(this.leftSE.point.y) || pt.x.eq(this.rightSE.point.x) && pt.y.eq(this.rightSE.point.y);\n  }\n  /* Compare this segment with a point.\n   *\n   * A point P is considered to be colinear to a segment if there\n   * exists a distance D such that if we travel along the segment\n   * from one * endpoint towards the other a distance D, we find\n   * ourselves at point P.\n   *\n   * Return value indicates:\n   *\n   *   1: point lies above the segment (to the left of vertical)\n   *   0: point is colinear to segment\n   *  -1: point lies below the segment (to the right of vertical)\n   */\n  comparePoint(point) {\n    return precision.orient(this.leftSE.point, point, this.rightSE.point);\n  }\n  /**\n   * Given another segment, returns the first non-trivial intersection\n   * between the two segments (in terms of sweep line ordering), if it exists.\n   *\n   * A 'non-trivial' intersection is one that will cause one or both of the\n   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n   *\n   *   * endpoint of segA with endpoint of segB --> trivial\n   *   * endpoint of segA with point along segB --> non-trivial\n   *   * endpoint of segB with point along segA --> non-trivial\n   *   * point along segA with point along segB --> non-trivial\n   *\n   * If no non-trivial intersection exists, return null\n   * Else, return null.\n   */\n  getIntersection(other) {\n    const tBbox = this.bbox();\n    const oBbox = other.bbox();\n    const bboxOverlap = getBboxOverlap(tBbox, oBbox);\n    if (bboxOverlap === null) return null;\n    const tlp = this.leftSE.point;\n    const trp = this.rightSE.point;\n    const olp = other.leftSE.point;\n    const orp = other.rightSE.point;\n    const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n    const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n    const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n    const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;\n    if (touchesThisLSE && touchesOtherLSE) {\n      if (touchesThisRSE && !touchesOtherRSE) return trp;\n      if (!touchesThisRSE && touchesOtherRSE) return orp;\n      return null;\n    }\n    if (touchesThisLSE) {\n      if (touchesOtherRSE) {\n        if (tlp.x.eq(orp.x) && tlp.y.eq(orp.y)) return null;\n      }\n      return tlp;\n    }\n    if (touchesOtherLSE) {\n      if (touchesThisRSE) {\n        if (trp.x.eq(olp.x) && trp.y.eq(olp.y)) return null;\n      }\n      return olp;\n    }\n    if (touchesThisRSE && touchesOtherRSE) return null;\n    if (touchesThisRSE) return trp;\n    if (touchesOtherRSE) return orp;\n    const pt = intersection(tlp, this.vector(), olp, other.vector());\n    if (pt === null) return null;\n    if (!isInBbox(bboxOverlap, pt)) return null;\n    return precision.snap(pt);\n  }\n  /**\n   * Split the given segment into multiple segments on the given points.\n   *  * Each existing segment will retain its leftSE and a new rightSE will be\n   *    generated for it.\n   *  * A new segment will be generated which will adopt the original segment's\n   *    rightSE, and a new leftSE will be generated for it.\n   *  * If there are more than two points given to split on, new segments\n   *    in the middle will be generated with new leftSE and rightSE's.\n   *  * An array of the newly generated SweepEvents will be returned.\n   *\n   * Warning: input array of points is modified\n   */\n  split(point) {\n    const newEvents = [];\n    const alreadyLinked = point.events !== void 0;\n    const newLeftSE = new SweepEvent(point, true);\n    const newRightSE = new SweepEvent(point, false);\n    const oldRightSE = this.rightSE;\n    this.replaceRightSE(newRightSE);\n    newEvents.push(newRightSE);\n    newEvents.push(newLeftSE);\n    const newSeg = new _Segment(\n      newLeftSE,\n      oldRightSE,\n      this.rings.slice(),\n      this.windings.slice()\n    );\n    if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n      newSeg.swapEvents();\n    }\n    if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n      this.swapEvents();\n    }\n    if (alreadyLinked) {\n      newLeftSE.checkForConsuming();\n      newRightSE.checkForConsuming();\n    }\n    return newEvents;\n  }\n  /* Swap which event is left and right */\n  swapEvents() {\n    const tmpEvt = this.rightSE;\n    this.rightSE = this.leftSE;\n    this.leftSE = tmpEvt;\n    this.leftSE.isLeft = true;\n    this.rightSE.isLeft = false;\n    for (let i = 0, iMax = this.windings.length; i < iMax; i++) {\n      this.windings[i] *= -1;\n    }\n  }\n  /* Consume another segment. We take their rings under our wing\n   * and mark them as consumed. Use for perfectly overlapping segments */\n  consume(other) {\n    let consumer = this;\n    let consumee = other;\n    while (consumer.consumedBy) consumer = consumer.consumedBy;\n    while (consumee.consumedBy) consumee = consumee.consumedBy;\n    const cmp = _Segment.compare(consumer, consumee);\n    if (cmp === 0) return;\n    if (cmp > 0) {\n      const tmp = consumer;\n      consumer = consumee;\n      consumee = tmp;\n    }\n    if (consumer.prev === consumee) {\n      const tmp = consumer;\n      consumer = consumee;\n      consumee = tmp;\n    }\n    for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n      const ring = consumee.rings[i];\n      const winding = consumee.windings[i];\n      const index = consumer.rings.indexOf(ring);\n      if (index === -1) {\n        consumer.rings.push(ring);\n        consumer.windings.push(winding);\n      } else consumer.windings[index] += winding;\n    }\n    consumee.rings = null;\n    consumee.windings = null;\n    consumee.consumedBy = consumer;\n    consumee.leftSE.consumedBy = consumer.leftSE;\n    consumee.rightSE.consumedBy = consumer.rightSE;\n  }\n  /* The first segment previous segment chain that is in the result */\n  prevInResult() {\n    if (this._prevInResult !== void 0) return this._prevInResult;\n    if (!this.prev) this._prevInResult = null;\n    else if (this.prev.isInResult()) this._prevInResult = this.prev;\n    else this._prevInResult = this.prev.prevInResult();\n    return this._prevInResult;\n  }\n  beforeState() {\n    if (this._beforeState !== void 0) return this._beforeState;\n    if (!this.prev)\n      this._beforeState = {\n        rings: [],\n        windings: [],\n        multiPolys: []\n      };\n    else {\n      const seg = this.prev.consumedBy || this.prev;\n      this._beforeState = seg.afterState();\n    }\n    return this._beforeState;\n  }\n  afterState() {\n    if (this._afterState !== void 0) return this._afterState;\n    const beforeState = this.beforeState();\n    this._afterState = {\n      rings: beforeState.rings.slice(0),\n      windings: beforeState.windings.slice(0),\n      multiPolys: []\n    };\n    const ringsAfter = this._afterState.rings;\n    const windingsAfter = this._afterState.windings;\n    const mpsAfter = this._afterState.multiPolys;\n    for (let i = 0, iMax = this.rings.length; i < iMax; i++) {\n      const ring = this.rings[i];\n      const winding = this.windings[i];\n      const index = ringsAfter.indexOf(ring);\n      if (index === -1) {\n        ringsAfter.push(ring);\n        windingsAfter.push(winding);\n      } else windingsAfter[index] += winding;\n    }\n    const polysAfter = [];\n    const polysExclude = [];\n    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {\n      if (windingsAfter[i] === 0) continue;\n      const ring = ringsAfter[i];\n      const poly = ring.poly;\n      if (polysExclude.indexOf(poly) !== -1) continue;\n      if (ring.isExterior) polysAfter.push(poly);\n      else {\n        if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n        const index = polysAfter.indexOf(ring.poly);\n        if (index !== -1) polysAfter.splice(index, 1);\n      }\n    }\n    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {\n      const mp = polysAfter[i].multiPoly;\n      if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n    }\n    return this._afterState;\n  }\n  /* Is this segment part of the final result? */\n  isInResult() {\n    if (this.consumedBy) return false;\n    if (this._isInResult !== void 0) return this._isInResult;\n    const mpsBefore = this.beforeState().multiPolys;\n    const mpsAfter = this.afterState().multiPolys;\n    switch (operation_default.type) {\n      case \"union\": {\n        const noBefores = mpsBefore.length === 0;\n        const noAfters = mpsAfter.length === 0;\n        this._isInResult = noBefores !== noAfters;\n        break;\n      }\n      case \"intersection\": {\n        let least;\n        let most;\n        if (mpsBefore.length < mpsAfter.length) {\n          least = mpsBefore.length;\n          most = mpsAfter.length;\n        } else {\n          least = mpsAfter.length;\n          most = mpsBefore.length;\n        }\n        this._isInResult = most === operation_default.numMultiPolys && least < most;\n        break;\n      }\n      case \"xor\": {\n        const diff = Math.abs(mpsBefore.length - mpsAfter.length);\n        this._isInResult = diff % 2 === 1;\n        break;\n      }\n      case \"difference\": {\n        const isJustSubject = (mps) => mps.length === 1 && mps[0].isSubject;\n        this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n        break;\n      }\n    }\n    return this._isInResult;\n  }\n};\n\n// src/geom-in.ts\nvar RingIn = class {\n  poly;\n  isExterior;\n  segments;\n  bbox;\n  constructor(geomRing, poly, isExterior) {\n    if (!Array.isArray(geomRing) || geomRing.length === 0) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    this.poly = poly;\n    this.isExterior = isExterior;\n    this.segments = [];\n    if (typeof geomRing[0][0] !== \"number\" || typeof geomRing[0][1] !== \"number\") {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    const firstPoint = precision.snap({ x: new BigNumber2(geomRing[0][0]), y: new BigNumber2(geomRing[0][1]) });\n    this.bbox = {\n      ll: { x: firstPoint.x, y: firstPoint.y },\n      ur: { x: firstPoint.x, y: firstPoint.y }\n    };\n    let prevPoint = firstPoint;\n    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {\n      if (typeof geomRing[i][0] !== \"number\" || typeof geomRing[i][1] !== \"number\") {\n        throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n      }\n      const point = precision.snap({ x: new BigNumber2(geomRing[i][0]), y: new BigNumber2(geomRing[i][1]) });\n      if (point.x.eq(prevPoint.x) && point.y.eq(prevPoint.y)) continue;\n      this.segments.push(Segment.fromRing(prevPoint, point, this));\n      if (point.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = point.x;\n      if (point.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = point.y;\n      if (point.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = point.x;\n      if (point.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = point.y;\n      prevPoint = point;\n    }\n    if (!firstPoint.x.eq(prevPoint.x) || !firstPoint.y.eq(prevPoint.y)) {\n      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n    }\n  }\n  getSweepEvents() {\n    const sweepEvents = [];\n    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {\n      const segment = this.segments[i];\n      sweepEvents.push(segment.leftSE);\n      sweepEvents.push(segment.rightSE);\n    }\n    return sweepEvents;\n  }\n};\nvar PolyIn = class {\n  multiPoly;\n  exteriorRing;\n  interiorRings;\n  bbox;\n  constructor(geomPoly, multiPoly) {\n    if (!Array.isArray(geomPoly)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    this.exteriorRing = new RingIn(geomPoly[0], this, true);\n    this.bbox = {\n      ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },\n      ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y }\n    };\n    this.interiorRings = [];\n    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      const ring = new RingIn(geomPoly[i], this, false);\n      if (ring.bbox.ll.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = ring.bbox.ll.x;\n      if (ring.bbox.ll.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = ring.bbox.ll.y;\n      if (ring.bbox.ur.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = ring.bbox.ur.x;\n      if (ring.bbox.ur.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = ring.bbox.ur.y;\n      this.interiorRings.push(ring);\n    }\n    this.multiPoly = multiPoly;\n  }\n  getSweepEvents() {\n    const sweepEvents = this.exteriorRing.getSweepEvents();\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringSweepEvents = this.interiorRings[i].getSweepEvents();\n      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(ringSweepEvents[j]);\n      }\n    }\n    return sweepEvents;\n  }\n};\nvar MultiPolyIn = class {\n  isSubject;\n  polys;\n  bbox;\n  constructor(geom, isSubject) {\n    if (!Array.isArray(geom)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    try {\n      if (typeof geom[0][0][0] === \"number\") geom = [geom];\n    } catch (ex) {\n    }\n    this.polys = [];\n    this.bbox = {\n      ll: { x: new BigNumber2(Number.POSITIVE_INFINITY), y: new BigNumber2(Number.POSITIVE_INFINITY) },\n      ur: { x: new BigNumber2(Number.NEGATIVE_INFINITY), y: new BigNumber2(Number.NEGATIVE_INFINITY) }\n    };\n    for (let i = 0, iMax = geom.length; i < iMax; i++) {\n      const poly = new PolyIn(geom[i], this);\n      if (poly.bbox.ll.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = poly.bbox.ll.x;\n      if (poly.bbox.ll.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = poly.bbox.ll.y;\n      if (poly.bbox.ur.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = poly.bbox.ur.x;\n      if (poly.bbox.ur.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = poly.bbox.ur.y;\n      this.polys.push(poly);\n    }\n    this.isSubject = isSubject;\n  }\n  getSweepEvents() {\n    const sweepEvents = [];\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polySweepEvents = this.polys[i].getSweepEvents();\n      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(polySweepEvents[j]);\n      }\n    }\n    return sweepEvents;\n  }\n};\n\n// src/index.ts\nvar union = (geom, ...moreGeoms) => operation_default.run(\"union\", geom, moreGeoms);\nvar intersection2 = (geom, ...moreGeoms) => operation_default.run(\"intersection\", geom, moreGeoms);\nvar xor = (geom, ...moreGeoms) => operation_default.run(\"xor\", geom, moreGeoms);\nvar difference = (geom, ...moreGeoms) => operation_default.run(\"difference\", geom, moreGeoms);\nvar setPrecision = precision.set;\nexport {\n  difference,\n  intersection2 as intersection,\n  setPrecision,\n  union,\n  xor\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport * as polyclip from \"polyclip-ts\";\nimport { polygon, multiPolygon } from \"@turf/helpers\";\nimport { geomEach } from \"@turf/meta\";\nfunction difference2(features) {\n  const geoms = [];\n  geomEach(features, (geom) => {\n    geoms.push(geom.coordinates);\n  });\n  if (geoms.length < 2) {\n    throw new Error(\"Must have at least two features\");\n  }\n  const properties = features.features[0].properties || {};\n  const differenced = polyclip.difference(geoms[0], ...geoms.slice(1));\n  if (differenced.length === 0) return null;\n  if (differenced.length === 1) return polygon(differenced[0], properties);\n  return multiPolygon(differenced, properties);\n}\nvar turf_difference_default = difference2;\nexport {\n  turf_difference_default as default,\n  difference2 as difference\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { feature, point, lineString, isObject } from \"@turf/helpers\";\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  if (geojson === null) return;\n  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === \"FeatureCollection\", isFeature = type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(\n            coords,\n            coordIndex,\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(\n              coords[j],\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false)\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(\n                coords[j][k],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false)\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(\n                  coords[j][k][l],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false)\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (coordIndex === 0 && initialValue === void 0)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function(currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function(currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function(coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\nfunction geomEach(geojson, callback) {\n  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === \"FeatureCollection\", isFeature = geojson.type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      if (geometry === null) {\n        if (callback(\n          null,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        ) === false)\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (callback(\n            geometry,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false)\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (callback(\n              geometry.geometries[j],\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false)\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    featureIndex++;\n  }\n}\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(\n          feature(geometry, properties, { bbox, id }),\n          featureIndex,\n          0\n        ) === false)\n          return false;\n        return;\n    }\n    var geomType;\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)\n        return false;\n    }\n  });\n}\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function(currentFeature, featureIndex, multiFeatureIndex) {\n      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n    if (!feature2.geometry) return;\n    var type = feature2.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(\n      feature2,\n      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n          previousCoords = currentCoord;\n          previousFeatureIndex = featureIndex;\n          previousMultiIndex = multiPartIndexCoord;\n          prevGeomIndex = geometryIndex;\n          segmentIndex = 0;\n          return;\n        }\n        var currentSegment = lineString(\n          [previousCoords, currentCoord],\n          feature2.properties\n        );\n        if (callback(\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        ) === false)\n          return false;\n        segmentIndex++;\n        previousCoords = currentCoord;\n      }\n    ) === false)\n      return false;\n  });\n}\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n      if (started === false && initialValue === void 0)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\nfunction lineEach(geojson, callback) {\n  if (!geojson) throw new Error(\"geojson is required\");\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    if (feature2.geometry === null) return;\n    var type = feature2.geometry.type;\n    var coords = feature2.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(\n            lineString(coords[geometryIndex], feature2.properties),\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n        }\n        break;\n    }\n  });\n}\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction findSegment(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nfunction findPoint(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nexport {\n  coordAll,\n  coordEach,\n  coordReduce,\n  featureEach,\n  featureReduce,\n  findPoint,\n  findSegment,\n  flattenEach,\n  flattenReduce,\n  geomEach,\n  geomReduce,\n  lineEach,\n  lineReduce,\n  propEach,\n  propReduce,\n  segmentEach,\n  segmentReduce\n};\n//# sourceMappingURL=index.js.map","import { coordEach } from \"@turf/meta\";\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexport default bbox;\n","import { getCoord, getGeom } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nexport default function booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = getCoord(point);\n    var geom = getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] &&\n        ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&\n            (xi - pt[0]) * (xj - pt[0]) <= 0 &&\n            (yi - pt[1]) * (yj - pt[1]) <= 0;\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = yi > pt[1] !== yj > pt[1] &&\n            pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);\n}\n","import { getCoord, getCoords } from \"@turf/invariant\";\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @param {number} [options.epsilon] Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\nfunction booleanPointOnLine(pt, line, options) {\n    if (options === void 0) { options = {}; }\n    // Normalize inputs\n    var ptCoords = getCoord(pt);\n    var lineCoords = getCoords(line);\n    // Main\n    for (var i = 0; i < lineCoords.length - 1; i++) {\n        var ignoreBoundary = false;\n        if (options.ignoreEndVertices) {\n            if (i === 0) {\n                ignoreBoundary = \"start\";\n            }\n            if (i === lineCoords.length - 2) {\n                ignoreBoundary = \"end\";\n            }\n            if (i === 0 && i + 1 === lineCoords.length - 1) {\n                ignoreBoundary = \"both\";\n            }\n        }\n        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === \"undefined\" ? null : options.epsilon)) {\n            return true;\n        }\n    }\n    return false;\n}\n// See http://stackoverflow.com/a/4833823/1979085\n// See https://stackoverflow.com/a/328122/1048847\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * @param {number} epsilon Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {\n    var x = pt[0];\n    var y = pt[1];\n    var x1 = lineSegmentStart[0];\n    var y1 = lineSegmentStart[1];\n    var x2 = lineSegmentEnd[0];\n    var y2 = lineSegmentEnd[1];\n    var dxc = pt[0] - x1;\n    var dyc = pt[1] - y1;\n    var dxl = x2 - x1;\n    var dyl = y2 - y1;\n    var cross = dxc * dyl - dyc * dxl;\n    if (epsilon !== null) {\n        if (Math.abs(cross) > epsilon) {\n            return false;\n        }\n    }\n    else if (cross !== 0) {\n        return false;\n    }\n    if (!excludeBoundary) {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n    }\n    else if (excludeBoundary === \"start\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n    }\n    else if (excludeBoundary === \"end\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n    }\n    else if (excludeBoundary === \"both\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n    }\n    return false;\n}\nexport default booleanPointOnLine;\n","import calcBbox from \"@turf/bbox\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport isPointOnLine from \"@turf/boolean-point-on-line\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Boolean-contains returns True if the second geometry is completely contained by the first geometry.\n * The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b)\n * must not intersect the exterior of the primary (geometry a).\n * Boolean-contains returns the exact opposite result of the `@turf/boolean-within`.\n *\n * @name booleanContains\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n * var point = turf.point([1, 2]);\n *\n * turf.booleanContains(line, point);\n * //=true\n */\nexport default function booleanContains(feature1, feature2) {\n    var geom1 = getGeom(feature1);\n    var geom2 = getGeom(feature2);\n    var type1 = geom1.type;\n    var type2 = geom2.type;\n    var coords1 = geom1.coordinates;\n    var coords2 = geom2.coordinates;\n    switch (type1) {\n        case \"Point\":\n            switch (type2) {\n                case \"Point\":\n                    return compareCoords(coords1, coords2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"MultiPoint\":\n            switch (type2) {\n                case \"Point\":\n                    return isPointInMultiPoint(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointInMultiPoint(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"LineString\":\n            switch (type2) {\n                case \"Point\":\n                    return isPointOnLine(geom2, geom1, { ignoreEndVertices: true });\n                case \"LineString\":\n                    return isLineOnLine(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointOnLine(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"Polygon\":\n            switch (type2) {\n                case \"Point\":\n                    return booleanPointInPolygon(geom2, geom1, { ignoreBoundary: true });\n                case \"LineString\":\n                    return isLineInPoly(geom1, geom2);\n                case \"Polygon\":\n                    return isPolyInPoly(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointInPoly(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        default:\n            throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n    }\n}\nexport function isPointInMultiPoint(multiPoint, pt) {\n    var i;\n    var output = false;\n    for (i = 0; i < multiPoint.coordinates.length; i++) {\n        if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {\n            output = true;\n            break;\n        }\n    }\n    return output;\n}\nexport function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {\n    for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {\n        var coord2 = _a[_i];\n        var matchFound = false;\n        for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {\n            var coord1 = _c[_b];\n            if (compareCoords(coord2, coord1)) {\n                matchFound = true;\n                break;\n            }\n        }\n        if (!matchFound) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function isMultiPointOnLine(lineString, multiPoint) {\n    var haveFoundInteriorPoint = false;\n    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (isPointOnLine(coord, lineString, { ignoreEndVertices: true })) {\n            haveFoundInteriorPoint = true;\n        }\n        if (!isPointOnLine(coord, lineString)) {\n            return false;\n        }\n    }\n    if (haveFoundInteriorPoint) {\n        return true;\n    }\n    return false;\n}\nexport function isMultiPointInPoly(polygon, multiPoint) {\n    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (!booleanPointInPolygon(coord, polygon, { ignoreBoundary: true })) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function isLineOnLine(lineString1, lineString2) {\n    var haveFoundInteriorPoint = false;\n    for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {\n        var coords = _a[_i];\n        if (isPointOnLine({ type: \"Point\", coordinates: coords }, lineString1, {\n            ignoreEndVertices: true,\n        })) {\n            haveFoundInteriorPoint = true;\n        }\n        if (!isPointOnLine({ type: \"Point\", coordinates: coords }, lineString1, {\n            ignoreEndVertices: false,\n        })) {\n            return false;\n        }\n    }\n    return haveFoundInteriorPoint;\n}\nexport function isLineInPoly(polygon, linestring) {\n    var output = false;\n    var i = 0;\n    var polyBbox = calcBbox(polygon);\n    var lineBbox = calcBbox(linestring);\n    if (!doBBoxOverlap(polyBbox, lineBbox)) {\n        return false;\n    }\n    for (i; i < linestring.coordinates.length - 1; i++) {\n        var midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);\n        if (booleanPointInPolygon({ type: \"Point\", coordinates: midPoint }, polygon, {\n            ignoreBoundary: true,\n        })) {\n            output = true;\n            break;\n        }\n    }\n    return output;\n}\n/**\n * Is Polygon2 in Polygon1\n * Only takes into account outer rings\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nexport function isPolyInPoly(feature1, feature2) {\n    // Handle Nulls\n    if (feature1.type === \"Feature\" && feature1.geometry === null) {\n        return false;\n    }\n    if (feature2.type === \"Feature\" && feature2.geometry === null) {\n        return false;\n    }\n    var poly1Bbox = calcBbox(feature1);\n    var poly2Bbox = calcBbox(feature2);\n    if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {\n        return false;\n    }\n    var coords = getGeom(feature2).coordinates;\n    for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {\n        var ring = coords_1[_i];\n        for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {\n            var coord = ring_1[_a];\n            if (!booleanPointInPolygon(coord, feature1)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nexport function doBBoxOverlap(bbox1, bbox2) {\n    if (bbox1[0] > bbox2[0]) {\n        return false;\n    }\n    if (bbox1[2] < bbox2[2]) {\n        return false;\n    }\n    if (bbox1[1] > bbox2[1]) {\n        return false;\n    }\n    if (bbox1[3] < bbox2[3]) {\n        return false;\n    }\n    return true;\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nexport function compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexport function getMidpoint(pair1, pair2) {\n    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];\n}\n","export const modeName = \"split_polygon\";\n\n/// This mode uses the `mapbox-gl-draw-passing-mode` mode to draw the spilitting lineString.\n/// here is the name used to add that mode:\nexport const passingModeName = `${modeName}_passing_draw_line_string`;\n\n/// when a (multi-)polygon feature is selected to be splitted, it gets highlighted.\n/// here is the name of the property indicating the highlight.\nexport const highlightPropertyName = `${modeName}_highlight`;\n\nexport const defaultOptions = {\n  highlightColor: \"#222\",\n  lineWidth: 0,\n  lineWidthUnit: \"kilometers\",\n  onSelectFeatureRequest() {\n    throw new Error(\"no Feature is selected to split.\");\n  },\n};\n\nexport const splitPolygonModeEvents = {\n  SPLIT_POLYGON_MODE_STOP: 'draw:split_polygon_mode:stop',\n  SPLIT_POLYGON_MORE_THAN_TWO_POLYGONS: 'draw:split_polygon_mode:more_than_two_polygons',\n}","import { flattenEach } from '@turf/turf';\n\n/**\n * Extract all polygons from a Feature or geometry object.\n * @param {GeoJSON.Feature<GeoJSON.Polygon|GeoJSON.MultiPolygon>} feature\n * @returns {GeoJSON.Feature<GeoJSON.Polygon>[]} Array of polygon features\n */\nfunction extractPolygons(feature) {\n    const polygons = [];\n  \n    flattenEach(feature, (polyFeature) => {\n      if (polyFeature.geometry.type === 'Polygon') {\n        polygons.push(polyFeature);\n      }\n    });\n  \n    return polygons;\n  }\n\nexport { extractPolygons };","import polygonSplitter from \"polygon-splitter\";\n\nimport { geojsonTypes, events } from \"@mapbox/mapbox-gl-draw/src/constants\";\n\nimport lineIntersect from \"@turf/line-intersect\";\nimport booleanDisjoint from \"@turf/boolean-disjoint\";\nimport lineOffset from \"@turf/line-offset\";\nimport lineToPolygon from \"@turf/line-to-polygon\";\nimport difference from \"@turf/difference\";\nimport { lineString } from \"@turf/helpers\";\nimport booleanContains from \"@turf/boolean-contains\";\n\nimport {\n  modeName,\n  passingModeName,\n  highlightPropertyName,\n  defaultOptions,\n  splitPolygonModeEvents,\n} from \"./constants\";\nimport { extractPolygons } from \"./utils\";\n\nconst SplitPolygonMode = {};\n\nSplitPolygonMode.onSetup = function (opt) {\n  const {\n    featureIds = [],\n    highlightColor = defaultOptions.highlightColor,\n    lineWidth = defaultOptions.lineWidth,\n    lineWidthUnit = defaultOptions.lineWidthUnit,\n    onSelectFeatureRequest = defaultOptions.onSelectFeatureRequest,\n  } = opt || {};\n\n  const api = this._ctx.api;\n\n  const featuresToSplit = [];\n  const selectedFeatures = this.getSelected();\n\n  if (featureIds.length !== 0) {\n    featuresToSplit.push.apply(\n      featuresToSplit,\n      featureIds.map((id) => api.get(id))\n    );\n  } else if (selectedFeatures.length !== 0) {\n    featuresToSplit.push.apply(\n      featuresToSplit,\n      selectedFeatures\n        .filter(\n          (f) =>\n            f.type === geojsonTypes.POLYGON ||\n            f.type === geojsonTypes.MULTI_POLYGON\n        )\n        .map((f) => f.toGeoJSON())\n    );\n  } else {\n    return onSelectFeatureRequest();\n  }\n\n  const state = {\n    options: {\n      highlightColor,\n      lineWidth,\n      lineWidthUnit,\n    },\n    featuresToSplit,\n    api,\n  };\n\n  /// `onSetup` job should complete for this mode to work.\n  /// so `setTimeout` is used to bupass mode change after `onSetup` is done executing.\n  setTimeout(this.drawAndSplit.bind(this, state), 0);\n  this.highlighFeatures(state);\n\n  return state;\n};\n\nSplitPolygonMode.drawAndSplit = function (state) {\n  const { api, options } = state;\n  const { lineWidth, lineWidthUnit } = options;\n\n  try {\n    this.changeMode(passingModeName, {\n      onDraw: (cuttingLineString) => {\n        const newPolygons = [];\n        let isInvalidLine = false;\n\n        if (!cuttingLineString) {\n          isInvalidLine = true;\n        }\n        \n        \n        state.featuresToSplit.forEach((el) => {\n          try {\n            if (booleanContains(el, cuttingLineString)) {\n              isInvalidLine = true;\n              return;\n            }\n            \n            if (booleanDisjoint(el, cuttingLineString)) {\n              isInvalidLine = true;\n              return;\n            } else if (lineWidth === 0) {\n              const polycut = polygonCut(el.geometry, cuttingLineString.geometry);\n              polycut.id = el.id;\n              api.add(polycut);\n              newPolygons.push(polycut);\n            } else {\n              const polycut = polygonCutWithSpacing(\n                el.geometry,\n                cuttingLineString.geometry,\n                {\n                  line_width: lineWidth,\n                  line_width_unit: lineWidthUnit,\n                }\n              );\n              polycut.id = el.id;\n              api.add(polycut);\n              newPolygons.push(polycut);\n            }\n          } catch (error) {\n            console.error(\"Error processing polygon split:\", error);\n          }\n        });\n        \n        this.fireUpdate(newPolygons);\n        this.highlighFeatures(state, false);\n        \n        if (isInvalidLine || newPolygons.length !== 1 || (newPolygons[0].geometry?.type === 'MultiPolygon' && newPolygons[0].geometry?.coordinates?.length !== 2)) {\n          this.map.fire(splitPolygonModeEvents.SPLIT_POLYGON_MORE_THAN_TWO_POLYGONS, {\n            newPolygons,\n          });\n        }\n\n        let numberOfPolygons = 0;\n        if (!isInvalidLine && newPolygons.length !== 0) {\n            numberOfPolygons = extractPolygons(newPolygons[0]).length;\n        }\n\n        console.log(numberOfPolygons, 'numberOfPolygons');\n\n      },\n      onCancel: () => {\n        this.highlighFeatures(state, false);\n        this.map.fire(splitPolygonModeEvents.SPLIT_POLYGON_MODE_STOP);\n      },\n    });\n  } catch (err) {\n    console.error(\"🚀 ~ file: mode.js ~ line 118 ~ err\", err);\n  }\n};\n\nSplitPolygonMode.highlighFeatures = function (state, shouldHighlight = true) {\n  const color = shouldHighlight ? state.options.highlightColor : undefined;\n\n  state.featuresToSplit.forEach((f) => {\n    state.api.setFeatureProperty(f.id, highlightPropertyName, color);\n  });\n};\n\nSplitPolygonMode.toDisplayFeatures = function (state, geojson, display) {\n  display(geojson);\n};\n\nSplitPolygonMode.fireUpdate = function (newF) {\n  this.map.fire(events.UPDATE, {\n    action: modeName,\n    features: newF,\n  });\n};\n\nexport default SplitPolygonMode;\n\n/// Note: currently has some issues, but generally is a better approach\nfunction polygonCut(poly, line) {\n  return polygonSplitter(poly, line);\n}\n\n/// Adopted from https://gis.stackexchange.com/a/344277/145409\nfunction polygonCutWithSpacing(poly, line, options) {\n  const { line_width, line_width_unit } = options || {};\n\n  const offsetLine = [];\n  const retVal = null;\n  let i, j, intersectPoints, forCut, forSelect;\n  let thickLineString, thickLinePolygon, clipped;\n\n  if (\n    typeof line_width === \"undefined\" ||\n    typeof line_width_unit === \"undefined\" ||\n    (poly.type != geojsonTypes.POLYGON &&\n      poly.type != geojsonTypes.MULTI_POLYGON) ||\n    line.type != geojsonTypes.LINE_STRING\n  ) {\n    return retVal;\n  }\n\n  /// if line and polygon don't intersect return.\n  if (booleanDisjoint(line, poly)) {\n    return retVal;\n  }\n\n  intersectPoints = lineIntersect(poly, line);\n  if (intersectPoints.features.length === 0) {\n    return retVal;\n  }\n\n  /// Creating two new lines at sides of the splitting lineString\n  offsetLine[0] = lineOffset(line, line_width, {\n    units: line_width_unit,\n  });\n  offsetLine[1] = lineOffset(line, -line_width, {\n    units: line_width_unit,\n  });\n\n  for (i = 0; i <= 1; i++) {\n    forCut = i;\n    forSelect = (i + 1) % 2;\n    const polyCoords = [];\n    for (j = 0; j < line.coordinates.length; j++) {\n      polyCoords.push(line.coordinates[j]);\n    }\n    for (j = offsetLine[forCut].geometry.coordinates.length - 1; j >= 0; j--) {\n      polyCoords.push(offsetLine[forCut].geometry.coordinates[j]);\n    }\n    polyCoords.push(line.coordinates[0]);\n\n    thickLineString = lineString(polyCoords);\n    thickLinePolygon = lineToPolygon(thickLineString);\n    clipped = difference(poly, thickLinePolygon);\n  }\n\n  return clipped;\n}\n","import {\n  modeName,\n  highlightPropertyName as _highlightPropertyName,\n} from \"./constants\";\n\nconst highlightPropertyName = `user_${_highlightPropertyName}`;\n\nconst customDrawStyles = (defaultStyle) =>\n  defaultStyle\n    .map((style) => {\n      if (style.id.endsWith(\"inactive\")) {\n        return {\n          ...style,\n          /// here \"!has\" is used cause the gl-draw supported that instead of ['!', ['has', ...]]\n          filter: [...style.filter, [\"!has\", highlightPropertyName]],\n        };\n      }\n\n      return style;\n    })\n    .concat([\n      {\n        id: `${modeName}-fill-active`,\n        type: \"fill\",\n        filter: [\n          \"all\",\n          [\"==\", \"active\", \"false\"],\n          [\"==\", \"$type\", \"Polygon\"],\n          [\"has\", highlightPropertyName],\n        ],\n        paint: {\n          \"fill-color\": [\"get\", highlightPropertyName],\n          \"fill-outline-color\": [\"get\", highlightPropertyName],\n          \"fill-opacity\": 0.1,\n        },\n      },\n      {\n        id: `${modeName}-stroke-active`,\n        type: \"line\",\n        filter: [\n          \"all\",\n          [\"==\", \"active\", \"false\"],\n          [\"==\", \"$type\", \"Polygon\"],\n          [\"has\", highlightPropertyName],\n        ],\n        layout: {\n          \"line-cap\": \"round\",\n          \"line-join\": \"round\",\n        },\n        paint: {\n          \"line-color\": [\"get\", highlightPropertyName],\n          \"line-dasharray\": [0.2, 2],\n          \"line-width\": 2,\n        },\n      },\n    ]);\n\nexport default customDrawStyles;\n","import * as Constants from '../constants';\n\nexport function isOfMetaType(type) {\n  return function(e) {\n    const featureTarget = e.featureTarget;\n    if (!featureTarget) return false;\n    if (!featureTarget.properties) return false;\n    return featureTarget.properties.meta === type;\n  };\n}\n\nexport function isShiftMousedown(e) {\n  if (!e.originalEvent) return false;\n  if (!e.originalEvent.shiftKey) return false;\n  return e.originalEvent.button === 0;\n}\n\nexport function isActiveFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.active === Constants.activeStates.ACTIVE &&\n    e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function isInactiveFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.active === Constants.activeStates.INACTIVE &&\n    e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function noTarget(e) {\n  return e.featureTarget === undefined;\n}\n\nexport function isFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function isVertex(e) {\n  const featureTarget = e.featureTarget;\n  if (!featureTarget) return false;\n  if (!featureTarget.properties) return false;\n  return featureTarget.properties.meta === Constants.meta.VERTEX;\n}\n\nexport function isShiftDown(e) {\n  if (!e.originalEvent) return false;\n  return e.originalEvent.shiftKey === true;\n}\n\nexport function isEscapeKey(e) {\n  return e.keyCode === 27;\n}\n\nexport function isEnterKey(e) {\n  return e.keyCode === 13;\n}\n\nexport function isTrue() {\n  return true;\n}\n","import * as CommonSelectors from '../lib/common_selectors';\nimport * as Constants from '../constants';\n\nconst DrawPoint = {};\n\nDrawPoint.onSetup = function() {\n  const point = this.newFeature({\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: Constants.geojsonTypes.POINT,\n      coordinates: []\n    }\n  });\n\n  this.addFeature(point);\n\n  this.clearSelectedFeatures();\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.activateUIButton(Constants.types.POINT);\n\n  this.setActionableState({\n    trash: true\n  });\n\n  return { point };\n};\n\nDrawPoint.stopDrawingAndRemove = function(state) {\n  this.deleteFeature([state.point.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nDrawPoint.onTap = DrawPoint.onClick = function(state, e) {\n  this.updateUIClasses({ mouse: Constants.cursors.MOVE });\n  state.point.updateCoordinate('', e.lngLat.lng, e.lngLat.lat);\n  this.map.fire(Constants.events.CREATE, {\n    features: [state.point.toGeoJSON()]\n  });\n  this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.point.id] });\n};\n\nDrawPoint.onStop = function(state) {\n  this.activateUIButton();\n  if (!state.point.getCoordinate().length) {\n    this.deleteFeature([state.point.id], { silent: true });\n  }\n};\n\nDrawPoint.toDisplayFeatures = function(state, geojson, display) {\n  // Never render the point we're drawing\n  const isActivePoint = geojson.properties.id === state.point.id;\n  geojson.properties.active = (isActivePoint) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  if (!isActivePoint) return display(geojson);\n};\n\nDrawPoint.onTrash = DrawPoint.stopDrawingAndRemove;\n\nDrawPoint.onKeyUp = function(state, e) {\n  if (CommonSelectors.isEscapeKey(e) || CommonSelectors.isEnterKey(e)) {\n    return this.stopDrawingAndRemove(state, e);\n  }\n};\n\nexport default DrawPoint;\n","import draw_point from \"@mapbox/mapbox-gl-draw/src/modes/draw_point\";\nimport * as Constants from \"@mapbox/mapbox-gl-draw/src/constants\";\n\nconst {\n  onSetup: originOnSetup,\n  onClick: originOnClick,\n  ...restOriginMethods\n} = draw_point;\n\nconst passing_draw_point = {\n  originOnSetup,\n  originOnClick,\n  ...restOriginMethods,\n};\n\npassing_draw_point.onSetup = function (opt) {\n  const state = this.originOnSetup();\n  const { onDraw, onCancel } = opt;\n  state.onDraw = onDraw;\n  state.onCancel = onCancel;\n  return state;\n};\n\npassing_draw_point.onTap = passing_draw_point.onClick = function (state, e) {\n  this.updateUIClasses({ mouse: Constants.cursors.MOVE });\n  state.point.updateCoordinate(\"\", e.lngLat.lng, e.lngLat.lat);\n\n  if (typeof state.onDraw === \"function\") state.onDraw(state.point.toGeoJSON());\n  else\n    this.map.fire(\"draw.passing-create\", {\n      features: [state.point.toGeoJSON()],\n    });\n\n  this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n};\n\npassing_draw_point.onMouseMove = function (state, e) {\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  state.point.updateCoordinate(e.lngLat.lng, e.lngLat.lat);\n};\n\npassing_draw_point.onStop = function (state) {\n  const f = state.point;\n\n  /// check to see if we've deleted this feature\n  const drawnFeature = this.getFeature(f.id);\n  if (drawnFeature === undefined) {\n    /// Call `onCancel` if exists.\n    if (typeof state.onCancel === \"function\") state.onCancel();\n    return;\n  }\n\n  this.activateUIButton();\n  this.deleteFeature([state.point.id], { silent: true });\n};\n\nexport default passing_draw_point;\n","function isEventAtCoordinates(event, coordinates) {\n  if (!event.lngLat) return false;\n  return event.lngLat.lng === coordinates[0] && event.lngLat.lat === coordinates[1];\n}\n\nexport default isEventAtCoordinates;\n","export default {\n  enable(ctx) {\n    setTimeout(() => {\n      // First check we've got a map and some context.\n      if (!ctx.map || !ctx.map.doubleClickZoom || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue) return;\n      // Now check initial state wasn't false (we leave it disabled if so)\n      if (!ctx._ctx.store.getInitialConfigValue('doubleClickZoom')) return;\n      ctx.map.doubleClickZoom.enable();\n    }, 0);\n  },\n  disable(ctx) {\n    setTimeout(() => {\n      if (!ctx.map || !ctx.map.doubleClickZoom) return;\n      // Always disable here, as it's necessary in some cases.\n      ctx.map.doubleClickZoom.disable();\n    }, 0);\n  }\n};\n","import * as Constants from '../constants';\n\n/**\n * Returns GeoJSON for a Point representing the\n * vertex of another feature.\n *\n * @param {string} parentId\n * @param {Array<number>} coordinates\n * @param {string} path - Dot-separated numbers indicating exactly\n *   where the point exists within its parent feature's coordinates.\n * @param {boolean} selected\n * @return {GeoJSON} Point\n */\nexport default function(parentId, coordinates, path, selected) {\n  return {\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {\n      meta: Constants.meta.VERTEX,\n      parent: parentId,\n      coord_path: path,\n      active: (selected) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE\n    },\n    geometry: {\n      type: Constants.geojsonTypes.POINT,\n      coordinates\n    }\n  };\n}\n","import * as CommonSelectors from '../lib/common_selectors';\nimport isEventAtCoordinates from '../lib/is_event_at_coordinates';\nimport doubleClickZoom from '../lib/double_click_zoom';\nimport * as Constants from '../constants';\nimport createVertex from '../lib/create_vertex';\n\nconst DrawLineString = {};\n\nDrawLineString.onSetup = function(opts) {\n  opts = opts || {};\n  const featureId = opts.featureId;\n\n  let line, currentVertexPosition;\n  let direction = 'forward';\n  if (featureId) {\n    line = this.getFeature(featureId);\n    if (!line) {\n      throw new Error('Could not find a feature with the provided featureId');\n    }\n    let from = opts.from;\n    if (from && from.type === 'Feature' && from.geometry && from.geometry.type === 'Point') {\n      from = from.geometry;\n    }\n    if (from && from.type === 'Point' && from.coordinates && from.coordinates.length === 2) {\n      from = from.coordinates;\n    }\n    if (!from || !Array.isArray(from)) {\n      throw new Error('Please use the `from` property to indicate which point to continue the line from');\n    }\n    const lastCoord = line.coordinates.length - 1;\n    if (line.coordinates[lastCoord][0] === from[0] && line.coordinates[lastCoord][1] === from[1]) {\n      currentVertexPosition = lastCoord + 1;\n      // add one new coordinate to continue from\n      line.addCoordinate(currentVertexPosition, ...line.coordinates[lastCoord]);\n    } else if (line.coordinates[0][0] === from[0] && line.coordinates[0][1] === from[1]) {\n      direction = 'backwards';\n      currentVertexPosition = 0;\n      // add one new coordinate to continue from\n      line.addCoordinate(currentVertexPosition, ...line.coordinates[0]);\n    } else {\n      throw new Error('`from` should match the point at either the start or the end of the provided LineString');\n    }\n  } else {\n    line = this.newFeature({\n      type: Constants.geojsonTypes.FEATURE,\n      properties: {},\n      geometry: {\n        type: Constants.geojsonTypes.LINE_STRING,\n        coordinates: []\n      }\n    });\n    currentVertexPosition = 0;\n    this.addFeature(line);\n  }\n\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.activateUIButton(Constants.types.LINE);\n  this.setActionableState({\n    trash: true\n  });\n\n  return {\n    line,\n    currentVertexPosition,\n    direction\n  };\n};\n\nDrawLineString.clickAnywhere = function(state, e) {\n  if (state.currentVertexPosition > 0 && isEventAtCoordinates(e, state.line.coordinates[state.currentVertexPosition - 1]) ||\n      state.direction === 'backwards' && isEventAtCoordinates(e, state.line.coordinates[state.currentVertexPosition + 1])) {\n    return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });\n  }\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);\n  if (state.direction === 'forward') {\n    state.currentVertexPosition++;\n    state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);\n  } else {\n    state.line.addCoordinate(0, e.lngLat.lng, e.lngLat.lat);\n  }\n};\n\nDrawLineString.clickOnVertex = function(state) {\n  return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });\n};\n\nDrawLineString.onMouseMove = function(state, e) {\n  state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);\n  if (CommonSelectors.isVertex(e)) {\n    this.updateUIClasses({ mouse: Constants.cursors.POINTER });\n  }\n};\n\nDrawLineString.onTap = DrawLineString.onClick = function(state, e) {\n  if (CommonSelectors.isVertex(e)) return this.clickOnVertex(state, e);\n  this.clickAnywhere(state, e);\n};\n\nDrawLineString.onKeyUp = function(state, e) {\n  if (CommonSelectors.isEnterKey(e)) {\n    this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });\n  } else if (CommonSelectors.isEscapeKey(e)) {\n    this.deleteFeature([state.line.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT);\n  }\n};\n\nDrawLineString.onStop = function(state) {\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  // check to see if we've deleted this feature\n  if (this.getFeature(state.line.id) === undefined) return;\n\n  //remove last added coordinate\n  state.line.removeCoordinate(`${state.currentVertexPosition}`);\n  if (state.line.isValid()) {\n    this.map.fire(Constants.events.CREATE, {\n      features: [state.line.toGeoJSON()]\n    });\n  } else {\n    this.deleteFeature([state.line.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n  }\n};\n\nDrawLineString.onTrash = function(state) {\n  this.deleteFeature([state.line.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nDrawLineString.toDisplayFeatures = function(state, geojson, display) {\n  const isActiveLine = geojson.properties.id === state.line.id;\n  geojson.properties.active = (isActiveLine) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  if (!isActiveLine) return display(geojson);\n  // Only render the line if it has at least one real coordinate\n  if (geojson.geometry.coordinates.length < 2) return;\n  geojson.properties.meta = Constants.meta.FEATURE;\n  display(createVertex(\n    state.line.id,\n    geojson.geometry.coordinates[state.direction === 'forward' ? geojson.geometry.coordinates.length - 2 : 1],\n    `${state.direction === 'forward' ? geojson.geometry.coordinates.length - 2 : 1}`,\n    false\n  ));\n\n  display(geojson);\n};\n\nexport default DrawLineString;\n","import draw_line_string from \"@mapbox/mapbox-gl-draw/src/modes/draw_line_string\";\nimport doubleClickZoom from \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\";\nimport * as Constants from \"@mapbox/mapbox-gl-draw/src/constants\";\n\nconst {\n  onSetup: originOnSetup,\n  onMouseMove: originOnMouseMove,\n  ...restOriginMethods\n} = draw_line_string;\n\nconst passing_draw_line_string = {\n  originOnSetup,\n  originOnMouseMove,\n  ...restOriginMethods,\n};\n\npassing_draw_line_string.onSetup = function (opt) {\n  const state = this.originOnSetup();\n  const { onDraw, onCancel } = opt;\n  state.onDraw = onDraw;\n  state.onCancel = onCancel;\n  return state;\n};\n\npassing_draw_line_string.onMouseMove = function (state, e) {\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.originOnMouseMove(state, e);\n};\n\npassing_draw_line_string.onStop = function (state) {\n  const f = state.line;\n\n  this.updateUIClasses({ mouse: Constants.cursors.NONE });\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  /// check to see if we've deleted this feature\n  const drawnFeature = this.getFeature(f.id);\n  if (drawnFeature === undefined) {\n    /// Call `onCancel` if exists.\n    if (typeof state.onCancel === \"function\") state.onCancel();\n    return;\n  }\n  /// remove last added coordinate\n  else f.removeCoordinate(`${state.currentVertexPosition}`);\n\n  if (f.isValid()) {\n    if (typeof state.onDraw === \"function\") state.onDraw(f.toGeoJSON());\n    else\n      this.map.fire(\"draw.passing-create\", {\n        features: [f.toGeoJSON()],\n      });\n  }\n  this.deleteFeature([f.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n};\n\nexport default passing_draw_line_string;\n","import * as CommonSelectors from '../lib/common_selectors';\nimport doubleClickZoom from '../lib/double_click_zoom';\nimport * as Constants from '../constants';\nimport isEventAtCoordinates from '../lib/is_event_at_coordinates';\nimport createVertex from '../lib/create_vertex';\n\nconst DrawPolygon = {};\n\nDrawPolygon.onSetup = function() {\n  const polygon = this.newFeature({\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: Constants.geojsonTypes.POLYGON,\n      coordinates: [[]]\n    }\n  });\n\n  this.addFeature(polygon);\n\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.activateUIButton(Constants.types.POLYGON);\n  this.setActionableState({\n    trash: true\n  });\n\n  return {\n    polygon,\n    currentVertexPosition: 0\n  };\n};\n\nDrawPolygon.clickAnywhere = function(state, e) {\n  if (state.currentVertexPosition > 0 && isEventAtCoordinates(e, state.polygon.coordinates[0][state.currentVertexPosition - 1])) {\n    return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });\n  }\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);\n  state.currentVertexPosition++;\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);\n};\n\nDrawPolygon.clickOnVertex = function(state) {\n  return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });\n};\n\nDrawPolygon.onMouseMove = function(state, e) {\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);\n  if (CommonSelectors.isVertex(e)) {\n    this.updateUIClasses({ mouse: Constants.cursors.POINTER });\n  }\n};\n\nDrawPolygon.onTap = DrawPolygon.onClick = function(state, e) {\n  if (CommonSelectors.isVertex(e)) return this.clickOnVertex(state, e);\n  return this.clickAnywhere(state, e);\n};\n\nDrawPolygon.onKeyUp = function(state, e) {\n  if (CommonSelectors.isEscapeKey(e)) {\n    this.deleteFeature([state.polygon.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT);\n  } else if (CommonSelectors.isEnterKey(e)) {\n    this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });\n  }\n};\n\nDrawPolygon.onStop = function(state) {\n  this.updateUIClasses({ mouse: Constants.cursors.NONE });\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  // check to see if we've deleted this feature\n  if (this.getFeature(state.polygon.id) === undefined) return;\n\n  //remove last added coordinate\n  state.polygon.removeCoordinate(`0.${state.currentVertexPosition}`);\n  if (state.polygon.isValid()) {\n    this.map.fire(Constants.events.CREATE, {\n      features: [state.polygon.toGeoJSON()]\n    });\n  } else {\n    this.deleteFeature([state.polygon.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n  }\n};\n\nDrawPolygon.toDisplayFeatures = function(state, geojson, display) {\n  const isActivePolygon = geojson.properties.id === state.polygon.id;\n  geojson.properties.active = (isActivePolygon) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  if (!isActivePolygon) return display(geojson);\n\n  // Don't render a polygon until it has two positions\n  // (and a 3rd which is just the first repeated)\n  if (geojson.geometry.coordinates.length === 0) return;\n\n  const coordinateCount = geojson.geometry.coordinates[0].length;\n  // 2 coordinates after selecting a draw type\n  // 3 after creating the first point\n  if (coordinateCount < 3) {\n    return;\n  }\n  geojson.properties.meta = Constants.meta.FEATURE;\n  display(createVertex(state.polygon.id, geojson.geometry.coordinates[0][0], '0.0', false));\n  if (coordinateCount > 3) {\n    // Add a start position marker to the map, clicking on this will finish the feature\n    // This should only be shown when we're in a valid spot\n    const endPos = geojson.geometry.coordinates[0].length - 3;\n    display(createVertex(state.polygon.id, geojson.geometry.coordinates[0][endPos], `0.${endPos}`, false));\n  }\n  if (coordinateCount <= 4) {\n    // If we've only drawn two positions (plus the closer),\n    // make a LineString instead of a Polygon\n    const lineCoordinates = [\n      [geojson.geometry.coordinates[0][0][0], geojson.geometry.coordinates[0][0][1]], [geojson.geometry.coordinates[0][1][0], geojson.geometry.coordinates[0][1][1]]\n    ];\n    // create an initial vertex so that we can track the first point on mobile devices\n    display({\n      type: Constants.geojsonTypes.FEATURE,\n      properties: geojson.properties,\n      geometry: {\n        coordinates: lineCoordinates,\n        type: Constants.geojsonTypes.LINE_STRING\n      }\n    });\n    if (coordinateCount === 3) {\n      return;\n    }\n  }\n  // render the Polygon\n  return display(geojson);\n};\n\nDrawPolygon.onTrash = function(state) {\n  this.deleteFeature([state.polygon.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nexport default DrawPolygon;\n","import draw_polygon from \"@mapbox/mapbox-gl-draw/src/modes/draw_polygon\";\nimport doubleClickZoom from \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\";\nimport * as Constants from \"@mapbox/mapbox-gl-draw/src/constants\";\n\nconst {\n  onSetup: originOnSetup,\n  onMouseMove: originOnMouseMove,\n  ...restOriginMethods\n} = draw_polygon;\n\nconst passing_draw_polygon = {\n  originOnSetup,\n  originOnMouseMove,\n  ...restOriginMethods,\n};\n\npassing_draw_polygon.onSetup = function (opt) {\n  const state = this.originOnSetup();\n  const { onDraw, onCancel } = opt;\n  state.onDraw = onDraw;\n  state.onCancel = onCancel;\n  return state;\n};\n\npassing_draw_polygon.onMouseMove = function (state, e) {\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.originOnMouseMove(state, e);\n};\n\npassing_draw_polygon.onStop = function (state) {\n  const f = state.polygon;\n\n  this.updateUIClasses({ mouse: Constants.cursors.NONE });\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  /// check to see if we've deleted this feature\n  const drawnFeature = this.getFeature(f.id);\n  if (drawnFeature === undefined) {\n    /// Call `onCancel` if exists.\n    if (typeof state.onCancel === \"function\") state.onCancel();\n    return;\n  }\n  /// remove last added coordinate\n  else f.removeCoordinate(`${state.currentVertexPosition}`);\n\n  if (f.isValid()) {\n    if (typeof state.onDraw === \"function\") state.onDraw(f.toGeoJSON());\n    else\n      this.map.fire(\"draw.passing-create\", {\n        features: [f.toGeoJSON()],\n      });\n  }\n  this.deleteFeature([f.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n};\n\nexport default passing_draw_polygon;\n","export const modeName = \"select_feature\";\n\n/// when a (multi-)polygon feature is hovered to be selected, it gets highlighted.\n/// here is the name of the property indicating the highlight.\nexport const highlightPropertyName = `${modeName}_highlight`;\n\nexport const defaultOptions = {\n  highlightColor: \"#222\",\n};\n","import doubleClickZoom from \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\";\nimport * as Constants from \"@mapbox/mapbox-gl-draw/src/constants\";\nimport { isEscapeKey } from \"@mapbox/mapbox-gl-draw/src/lib/common_selectors\";\n\nimport { defaultOptions, highlightPropertyName } from \"./constants\";\n\nconst select_mode = {};\n\nselect_mode.onSetup = function (opt) {\n  const { selectHighlightColor, onSelect, onCancel } = opt;\n  const state = {};\n  state.hoveredFeatureID = null;\n  state.selectedFeatureID = null;\n  state.onSelect = onSelect;\n  state.onCancel = onCancel;\n  state.api = this._ctx.api;\n  const {\n    selectHighlightColor:\n      defaultSelectHighlightColor = defaultOptions.highlightColor,\n  } = this._ctx.options;\n  state.options = {\n    selectHighlightColor: selectHighlightColor || defaultSelectHighlightColor,\n  };\n\n  return state;\n};\n\nselect_mode.onMouseMove = function (state, e) {\n  const { api } = state;\n  const { featureTarget } = e;\n  // this.originOnMouseMove(state, e);\n\n  if (featureTarget) {\n    this.updateUIClasses({ mouse: Constants.cursors.POINTER });\n    const hoveringFeatureID = featureTarget.properties.id;\n    if (\n      state.hoveredFeatureID !== null &&\n      state.hoveredFeatureID !== hoveringFeatureID\n    ) {\n      api.setFeatureProperty(\n        state.hoveredFeatureID,\n        highlightPropertyName,\n        undefined\n      );\n    }\n    state.hoveredFeatureID = hoveringFeatureID;\n    api.setFeatureProperty(\n      state.hoveredFeatureID,\n      highlightPropertyName,\n      state.options.selectHighlightColor\n    );\n  } else {\n    if (state.hoveredFeatureID)\n      api.setFeatureProperty(\n        state.hoveredFeatureID,\n        highlightPropertyName,\n        undefined\n      );\n    state.hoveredFeatureID = null;\n  }\n};\n\nselect_mode.onClick = function (state, e) {\n  state.selectedFeatureID = state.hoveredFeatureID;\n  this.onStop(state, e);\n};\n\nselect_mode.toDisplayFeatures = function (state, geojson, display) {\n  display(geojson);\n};\n\nselect_mode.onKeyUp = function (state, e) {\n  if (isEscapeKey(e)) {\n    this.changeMode(Constants.modes.SIMPLE_SELECT);\n  }\n};\n\nselect_mode.onStop = function (state) {\n  this.updateUIClasses({ mouse: Constants.cursors.NONE });\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  if (state.selectedFeatureID) {\n    if (typeof state.onSelect === \"function\")\n      state.onSelect(state.selectedFeatureID);\n    else\n      this.map.fire(\"draw.select_mode.select\", {\n        featureID: state.selectedFeatureID,\n      });\n\n    state.selectedFeatureID = null;\n    this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n  } else {\n    /// Call `onCancel` if exists.\n    if (typeof state.onCancel === \"function\") state.onCancel();\n  }\n\n  if (state.hoveredFeatureID) {\n    this._ctx.api.setFeatureProperty(\n      state.hoveredFeatureID,\n      highlightPropertyName,\n      undefined\n    );\n    state.hoveredFeatureID = null;\n  }\n};\n\nexport default select_mode;\n","import { default as selectFeatureMode } from \"./mode.js\";\nimport { default as drawStyles } from \"./customDrawStyles.js\";\n\nimport { modeName } from \"./constants\";\n\nexport { selectFeatureMode };\nexport { drawStyles };\n\nexport default function SelectFeatureMode(modes) {\n  return {\n    ...modes,\n    [modeName]: selectFeatureMode,\n  };\n}\n","import { default as splitPolygonMode } from \"./mode.js\";\nimport { default as drawStyles } from \"./customDrawStyles.js\";\nimport * as Constants from \"./constants\";\n\nimport { passing_draw_line_string } from \"mapbox-gl-draw-passing-mode\";\nimport SelectFeatureMode from \"mapbox-gl-draw-select-mode\";\nimport { modeName, passingModeName } from \"./constants\";\n\nexport { splitPolygonMode };\nexport { drawStyles };\nexport { Constants };\n\nexport default function SplitPolygonMode(modes) {\n  return {\n    ...SelectFeatureMode(modes),\n    [passingModeName]: passing_draw_line_string,\n    [modeName]: splitPolygonMode,\n  };\n}\n"],"names":["clone","geojson","Error","type","cloneFeature","cloned","Object","keys","forEach","key","features","map","feature","cloneFeatureCollection","cloneGeometry","properties","cloneProperties","geometry","value","Array","isArray","item","geom","bbox","geometries","g","coordinates","deepSlice","coords","slice","coord","getCoord","length","getCoords","getGeom","booleanClockwise","line","prev","cur","ring","sum","i","options","feat","id","coordEach","callback","excludeWrapCoord","j","k","l","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","featureEach","geomEach","featureProperties","featureBBox","featureId","undefined","rewind","input","constructor","reverse","mutate","results","rewindFeature","result","push","fc","featureCollection","rewindLineString","rewindPolygon","lineCoords","pointInPolygon","p","polygon","ii","f","u1","v1","u2","v2","currentP","nextP","x","y","numContours","contourLen","contour","splitter","elen","e","flen","h","Q","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","vec","n","Float64Array","B","C1","C2","D","u","orient2d","ax","ay","bx","by","cx","cy","detleft","detright","det","detsum","Math","abs","acxtail","acytail","bcxtail","bcytail","c","ahi","alo","bhi","blo","_i","_j","_0","s1","s0","t1","t0","u3","acx","bcx","acy","bcy","estimate","errbound","C1len","C2len","Dlen","orient2dadapt","Edge","p1","p2","edgeType","index","contourId","this","originalIndex","polygonContourId","interiorRing","minX","min","minY","maxX","max","maxY","intersectionPoints","nextEdge","Point","Contour","rawCoords","edgeIntersectsBbox","edge","IntersectionPoint","edge1","edge2","isHeadingIn","polylineEdge","polygonEdge","distanceFromPolylineEdgeStart","distance","distanceFromPolygonEdgeStart","visitCount","xs","ys","sqrt","prototype","incrementVisitCount","crossProduct","a","b","dotProduct","toPoint","s","d","getEdgeIntersection","lineEdge","potentialEdge","noEndpointTouch","va","vb","kross","sqrKross","sqrLenA","t","sqrLenE","sa","sb","smin","smax","intersections","polygonEdges","polylineEdges","contours","polyEdges","lineEdges","polylineBbox","numberOfRingsInPolygon","linegeom","linecoords","edgeCount","lineLength","prevEdge","nextPoint","prevPoint","polygeom","polycoords","polyLength","i$1","polyLenth2","ii$1","polygonSet","polyLenth3","firstPoint","p1$1","p2$1","e$1","prevEdge$1","firstEdge","iii","intersectPolylineBbox","fillQueue","Infinity","intersectingPoints","count","polyCount","intersection","ip","sort","findIntersectionPoints","numberIntersectionsByRing","infiniteLoopGuard","outPolys","firstPolyStart","pe","polyStart","nextPolyStart","unvisitedPolyFound","index$1","outPoly","nextIntersection","walkPolygonForwards","override","index$2","walkPolylineForwards","walkPolylineBackwards","unvisitedPolyFound$1","index$3","intersection$2","outCoordinates","poly","index$4","createAsHoleOrAddAsNewOuterRing","findRingFromEdge","findFirstPolygonEdge","parseInt","find","unusedRing","existingRing","inside","intersectionPoint","currentIndex","findIndexOfIntersectionPoint","nextIp","condition","lastPointOnEdge","nextIntersection$1","lastIntersection","cursors","types","geojsonTypes","modes","events","meta","activeStates","earthRadius","factors","centimeters","centimetres","degrees","PI","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","lineString","multiLineString","multiPolygon","lengthToDegrees","units","factor","lengthToRadians","isNumber","num","isNaN","TinyQueue","data","compare","defaultCompare","_down","_up","pop","top","bottom","peek","pos","parent","current","halfLength","left","best","right","checkWhichEventIsLeft","e1","e2","checkWhichSegmentHasRightEndpointFirst","seg1","seg2","rightSweepEvent","Event","ringId","eventId","otherEvent","isLeftEndpoint","isSamePoint","eventToCheck","processFeature","featureOrGeometry","eventQueue","Segment$1","event","leftSweepEvent","testSegmentIntersect","x1","y1","x2","y2","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","sweeplineIntersections","ignoreSelfIntersections","fillEventQueue","outQueue","segment","Segment","otherSeg","runCheck","lineIntersect","line1","line2","removeDuplicates","concat","unique","join","r","point","turf_line_intersect_default","booleanPointInPolygon","pt","polys","inBBox","polyResult","pip","ignoreBoundary","flattenEach","coordinate","polygonToLine","coordsToLine","singlePolygonToLine","multiPoly","lines","multiPolygonToLine","isPointOnLine","isPointOnLineSegment","isLineInPoly","lineSegmentStart","lineSegmentEnd","dxc","dyc","dxl","dyl","turf_boolean_disjoint_default","feature1","feature2","bool","flatten1","flatten2","geom1","geom2","pair1","pair2","lineString1","lineString2","isLineOnLine","coord1","coord2","isPolyInPoly","disjoint","ab","start","end","isParallel","q","cross","intersection2","add","v","scalarMult","intersectSegments","lineOffsetFeature","segments","offsetDegrees","finalCoords","currentCoords","point1","point2","offset","L","out1x","out2x","out1y","out2y","seg2Coords","intersects","turf_line_offset_default","_name","getType","recompute","lineStringToPolygon","autoComplete","orderCoords","autoCompleteCoords","multiCoords","largestArea","area","west","south","east","north","calculateArea","turfBBox","unshift","first","last","turf_line_to_polygon_default","_a","_b","_c","isNumeric","mathceil","ceil","mathfloor","floor","bignumberError","tooManyDigits","BASE","LOG_BASE","MAX_SAFE_INTEGER","POWS_TEN","SQRT_BASE","MAX","bitFloor","coeffToString","z","charCodeAt","xc","yc","intCheck","name","String","isOdd","toExponential","str","charAt","toFixedPoint","len","zs","BigNumber","configObject","div","convertBase","parseNumeric","pow2_53","random53bitInt","basePrefix","dotAfter","dotBefore","isInfinityOrNaN","whitespaceOrPlus","P","toString","valueOf","ONE","DECIMAL_PLACES","ROUNDING_MODE","TO_EXP_NEG","TO_EXP_POS","MIN_EXP","MAX_EXP","CRYPTO","MODULO_MODE","POW_PRECISION","FORMAT","prefix","groupSize","secondaryGroupSize","groupSeparator","decimalSeparator","fractionGroupSize","fractionGroupSeparator","suffix","ALPHABET","alphabetHasNormalDecimalDigits","alphabet","caseChanged","isNum","_isBigNumber","test","indexOf","replace","search","substring","round","DEBUG","toUpperCase","toLowerCase","format","rm","c0","ne","maxOrMin","args","normalise","sd","ni","rd","pows10","out","ROUND_UP","ROUND_DOWN","ROUND_CEIL","ROUND_FLOOR","ROUND_HALF_UP","ROUND_HALF_DOWN","ROUND_HALF_EVEN","ROUND_HALF_CEIL","ROUND_HALF_FLOOR","EUCLID","config","set","obj","hasOwnProperty","crypto","getRandomValues","randomBytes","EXPONENTIAL_AT","RANGE","isBigNumber","call","maximum","arguments","minimum","random","dp","rand","Uint32Array","copy","splice","plus","decimal","toBaseOut","baseIn","baseOut","arrL","arr","sign","callerIsToString","pow","multiply","base","m","temp","xlo","xhi","carry","klo","khi","aL","bL","cmp","subtract","more","prod","prodL","qc","rem","remL","rem0","xi","xL","yc0","yL","yz","NaN","absoluteValue","comparedTo","decimalPlaces","dividedBy","dividedToIntegerBy","idiv","exponentiatedBy","half","isModExp","nIsBig","nIsNeg","nIsOdd","isInteger","mod","times","integerValue","isEqualTo","eq","isFinite","isGreaterThan","gt","isGreaterThanOrEqualTo","gte","isLessThan","lt","isLessThanOrEqualTo","lte","isNegative","isPositive","isZero","minus","xLTy","xe","ye","modulo","multipliedBy","xcL","ycL","ylo","yhi","zc","sqrtBase","negated","precision","shiftedBy","squareRoot","rep","toFixed","toFormat","split","g1","g2","intPart","fractionPart","isNeg","intDigits","substr","RegExp","toFraction","md","d0","d1","d2","exp","n0","n1","toNumber","toPrecision","toJSON","Symbol","toStringTag","for","SplayTreeNode","SplayTreeSetNode","super","SplayTree","size","modificationCount","splayCount","splay","root","newTreeRight","newTreeLeft","comp","currentLeft","currentRight","splayMin","node","nextLeft","splayMax","nextRight","_delete","addNewRoot","_first","_last","clear","has","validKey","wrap","getRoot","setRoot","getSize","getModificationCount","getSplayCount","setSplayCount","SplayTreeSet","_SplayTreeSet","isValidKey","delete","element","deleteAll","elements","nodes","iterator","next","done","addAndReturn","addAll","isEmpty","isNotEmpty","single","lastBefore","nodeRight","firstAfter","nodeLeft","retainAll","retainSet","object","lookup","other","difference","union","copyNode","copyChildren","node2","dest","newLeft","newRight","toSet","entries","SplayTreeSetEntryIterableIterator","values","SplayTreeKeyIterableIterator","SplayTreeIterableIterator","tree","path","moveNext","getValue","rebuildPath","findLeftMostDescendent","constant_default","compare_default","eps","almostEqual","orient_default","almostCollinear","area2","identity_default","snap_default","xTree","yTree","snapCoord","snap","eps2","reset","orient","isInBbox","ll","ur","getBboxOverlap","b1","b2","lowerX","upperX","sineOfAngle","pShared","pBase","pAngle","vBase","vAngle","cosineOfAngle","horizontalIntersection","verticalIntersection","SweepEvent","_SweepEvent","isLeft","otherSE","consumedBy","static","ptCmp","comparePoints","link","aPt","bPt","otherEvents","iMax","evt","checkForConsuming","numEvents","evt1","evt2","consume","getAvailableLinkedEvents","ringOut","isInResult","getLeftmostComparator","baseEvent","cache","Map","fillCache","linkedEvent","nextEvent","sine","cosine","asine","acosine","get","bsine","bcosine","RingOut","_RingOut","_isExteriorRing","_enclosingRing","allSegments","ringsOut","prevEvent","leftSE","rightSE","startingPoint","intersectionLEs","availableLEs","firstPt","lastPt","indexLE","jMax","intersectionLE","ringEvents","comparator","prevPt","points","pt2","nextPt2","nextPt","shift","step","isExteriorRing","iStart","iEnd","orderedPoints","enclosing","enclosingRing","_calcEnclosingRing","leftMostEvt","prevSeg","prevInResult","prevPrevSeg","PolyOut","exteriorRing","interiorRings","addInterior","geom0","ringGeom","operation","numMultiPolys","run","moreGeoms","multipolys","MultiPolyIn","subject","mpA","queue","SplayTreeSet3","sweepEvents","getSweepEvents","sweepLine","SplayTreeSet2","process","newEvents","nextSeg","prevMySplitter","prevInter","getIntersection","isAnEndpoint","newEventsFromSplit","_splitSafely","nextMySplitter","nextInter","mySplitter","inter","seg","factory","rings","_composePolys","polyGeom","operation_default","segmentId","_Segment","windings","_prevInResult","_beforeState","_afterState","_isInResult","alx","blx","arx","brx","aly","bly","ary","bry","aCmpBLeft","comparePoint","bCmpARight","bCmpALeft","aCmpBRight","pt1","leftPt","rightPt","winding","cmpPts","replaceRightSE","newRightSE","vector","tBbox","oBbox","bboxOverlap","tlp","trp","olp","orp","touchesOtherLSE","touchesThisLSE","touchesOtherRSE","touchesThisRSE","ve","alreadyLinked","newLeftSE","oldRightSE","newSeg","swapEvents","tmpEvt","consumer","consumee","tmp","beforeState","afterState","multiPolys","ringsAfter","windingsAfter","mpsAfter","polysAfter","polysExclude","isExterior","mp","mpsBefore","noBefores","noAfters","least","most","diff","isJustSubject","mps","isSubject","RingIn","geomRing","BigNumber2","fromRing","PolyIn","geomPoly","ringSweepEvents","ex","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","polySweepEvents","turf_difference_default","geoms","differenced","polyclip.difference","insidePoly","inRing","inHole","isInside","yi","xj","yj","booleanPointOnLine","ptCoords","ignoreEndVertices","epsilon","excludeBoundary","booleanContains","type1","type2","coords1","coords2","compareCoords","multiPoint","output","isPointInMultiPoint","multiPoint1","multiPoint2","matchFound","isMultiPointInMultiPoint","haveFoundInteriorPoint","isMultiPointOnLine","linestring","polyBbox","calcBbox","lineBbox","doBBoxOverlap","getMidpoint","poly1Bbox","poly2Bbox","coords_1","ring_1","isMultiPointInPoly","bbox1","bbox2","modeName","passingModeName","highlightPropertyName","defaultOptions","highlightColor","lineWidth","lineWidthUnit","onSelectFeatureRequest","splitPolygonModeEvents","SPLIT_POLYGON_MODE_STOP","SPLIT_POLYGON_MORE_THAN_TWO_POLYGONS","extractPolygons","polygons","polyFeature","SplitPolygonMode","onSetup","opt","featureIds","api","_ctx","featuresToSplit","selectedFeatures","getSelected","apply","filter","toGeoJSON","state","setTimeout","drawAndSplit","bind","highlighFeatures","changeMode","onDraw","cuttingLineString","newPolygons","isInvalidLine","el","booleanDisjoint","polycut","polygonSplitter","line_width","line_width_unit","offsetLine","retVal","intersectPoints","forCut","thickLineString","clipped","lineOffset","polyCoords","lineToPolygon","polygonCutWithSpacing","error","console","fireUpdate","fire","numberOfPolygons","log","onCancel","err","SplitPolygonMode$1","shouldHighlight","color","setFeatureProperty","toDisplayFeatures","display","newF","action","isVertex","featureTarget","Constants.meta","isEscapeKey","keyCode","isEnterKey","DrawPoint","newFeature","Constants.geojsonTypes","addFeature","clearSelectedFeatures","updateUIClasses","mouse","Constants.cursors","activateUIButton","Constants.types","setActionableState","trash","deleteFeature","silent","Constants.modes","onTap","onClick","updateCoordinate","lngLat","lng","lat","Constants.events","onStop","getCoordinate","isActivePoint","active","Constants.activeStates","onTrash","stopDrawingAndRemove","onKeyUp","CommonSelectors.isEscapeKey","CommonSelectors.isEnterKey","originOnSetup","originOnClick","restOriginMethods","draw_point","isEventAtCoordinates","doubleClickZoom","enable","ctx","store","getInitialConfigValue","disable","createVertex","parentId","selected","coord_path","DrawLineString","opts","currentVertexPosition","direction","getFeature","from","lastCoord","addCoordinate","CommonSelectors.isVertex","clickOnVertex","clickAnywhere","removeCoordinate","isValid","isActiveLine","onMouseMove","originOnMouseMove","draw_line_string","passing_draw_line_string","DrawPolygon","isActivePolygon","coordinateCount","endPos","lineCoordinates","draw_polygon","select_mode","SelectFeatureMode","selectFeatureMode","selectHighlightColor","onSelect","defaultSelectHighlightColor","hoveringFeatureID","hoveredFeatureID","selectedFeatureID","featureID","modeName$1","splitPolygonMode","defaultStyle","style","endsWith","paint","layout"],"mappings":"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"}